<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[欢迎]]></title>
    <url>%2Fstart%2F</url>
    <content type="text"><![CDATA[欢迎来到$\text{Lu-Anlai’s Blog}$本博客由 Hexo 强力驱动 v3.8.0 | 主题 – NexT.Gemini v7.0.0 公式渲染引擎是$\text{MathJax}$。 博客主要内容是题解（水题题解），之前在洛谷博客和$\text{CSDN}$博客发布的文章不久就会转移到这个博客上来（咕咕咕）。 更新日志 2019-03-05 优化博客结构 2019-03-09 修补了一些$BUG$]]></content>
  </entry>
  <entry>
    <title><![CDATA[信息学奥赛一本通（C++版）第二部分 基础算法 第三章 递推算法]]></title>
    <url>%2FSolution%2FYBT%2F2.3%2F</url>
    <content type="text"><![CDATA[信息学奥赛一本通（C++版）第二部分 基础算法 第三章 递推算法 T1312 : 昆虫繁殖【题目描述】科学家在热带森林中发现了一种特殊的昆虫，这种昆虫的繁殖能力很强。每对成虫过$x$个月产$y$对卵，每对卵要过两个月长成成虫。假设每个成虫不死，第一个月只有一对成虫，且卵长成成虫后的第一个月不产卵(过$x$个月产卵)，问过$z$个月以后，共有成虫多少对？$0 \leq x \leq 20,1 \leq y \leq 20,x \leq z \leq 50$。 【输入】$x,y,z$的数值。 【输出】过$z$个月以后，共有成虫对数。 【输入样例】11 2 8 【输出样例】137 【答案&amp;代码】12345678910111213#include&lt;stdio.h&gt;long long adult[64],born[64];int main(void)&#123; int x,y,z; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); for(int i=1;i&lt;=x;i++) adult[i]=1,born[i]=0; for(int i=x+1;i&lt;=z+1;i++) born[i]=y*adult[i-x], adult[i]=adult[i-1]+born[i-2]; printf("%lld",adult[z+1]); return 0;&#125; T1313 : 位数问题【题目描述】在所有的$N$位数中，有多少个数中有偶数个数字$3$？由于结果可能很大，你只需要输出这个答案对$12345$取余的值。 【输入】读入一个数$N$。 【输出】输出有多少个数中有偶数个数字$3$。 【输入样例】12 【输出样例】173 【答案&amp;代码】12345678910111213141516#include&lt;stdio.h&gt;int f[1001][2];int main(void)&#123; int n; f[1][0]=9,f[1][1]=1; scanf("%d",&amp;n); for(int i=2,x;i&lt;=n;i++)&#123; x=f[1][0]; if(i==n) x--; f[i][0]=(f[i-1][0]*x+f[i-1][1])%12345, f[i][1]=(f[i-1][1]*x+f[i-1][0])%12345; &#125; printf("%d",f[n][0]); return 0; &#125; T1314: 过河卒【题目描述】棋盘上$A$点有一个过河卒，需要走到目标$B$点。卒行走的规则：可以向下、或者向右。同时在棋盘上的某一点有一个对方的马（如$C$点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点，如图中的$C$点和$P_{1},…,P_{8}$，卒不能通过对方马的控制点。棋盘用坐标表示，$A$点$(0,0)$、$B$点$(n,m)$（$n,m$为不超过$20$的整数），同样马的位置坐标是需要给出的，$C≠A$且$C≠B$。现在要求你计算出卒从$A$点能够到达$B$点的路径的条数。 【输入】给出$n,m$和$C$点的坐标。 【输出】从$A$点能够到达$B$点的路径的条数。 【输入样例】18 6 0 4 【输出样例】11617 【答案&amp;代码】12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;unsigned long long dp[21][21]=&#123;0&#125;;int main(void)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int mx,my; scanf("%d%d",&amp;mx,&amp;my); dp[0][0]=1; for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=m;j++) if(i==mx&amp;&amp;j==my|| i==mx-1&amp;&amp;j==my-2|| i==mx-2&amp;&amp;j==my-1|| i==mx-2&amp;&amp;j==my+1|| i==mx+1&amp;&amp;j==my-2|| i==mx+2&amp;&amp;j==my-1|| i==mx+1&amp;&amp;j==my+2 ) dp[i][j]=0; else if(i==0&amp;&amp;j!=0) dp[i][j]=dp[i][j-1]; else if(j==0&amp;&amp;i!=0) dp[i][j]=dp[i-1][j]; else if(i==0&amp;&amp;j==0) dp[i][j]=1; else dp[i][j]=dp[i-1][j]+dp[i][j-1]; &#125; printf("%lld",dp[n][m]); return 0;&#125; T1188: 菲波那契数列(2)【题目描述】菲波那契数列是指这样的数列:数列的第一个和第二个数都为$1$，接下来每个数都等于前面$2$个数之和。 给出一个正整数$a$，要求菲波那契数列中第$a$个数对$1000$取模的结果是多少。 【输入】第$1$行是测试数据的组数$n$，后面跟着$n$行输入。每组测试数据占$1$行，包括一个正整数$a(1 \leq a \leq 1000000)$。 【输出】$n$行，每行输出对应一个输入。输出应是一个正整数，为菲波那契数列中第$a$个数对$1000$取模得到的结果。 【输入样例】12345452191 【输出样例】1234511811 【答案&amp;代码】1234567891011121314151617#include&lt;stdio.h&gt;int fun(int n)&#123; int F1=1,F2=1,Fn=1; for(int i=3;i&lt;=n;i++) Fn=F1+F2,F1=F2,F2=Fn,Fn%=1000,F1%=1000,F2%=1000; return Fn;&#125;int main(void)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; int temp; scanf("%d",&amp;temp); printf("%d\n",fun(temp)%1000); &#125; return 0;&#125; T1189: Pell数列【题目描述】Pell数列$a_{1},a_{2},a_{3},…$的定义是这样的，$a_{1}=1,a_{2}=2,…,a_{n}=2a_{n-1}+a_{n-2}(n&gt;2)$。 给出一个正整数$k$，要求Pell数列的第$k$项模上$32767$是多少。 【输入】第$1$行是测试数据的组数$n$，后面跟着$n$行输入。每组测试数据占$1$行，包括一个正整数$k(1 \leq k&lt;1000000)$。 【输出】$n$行，每行输出对应一个输入。输出应是一个非负整数。 【输入样例】123218 【输出样例】121408 【答案&amp;代码】12345678910111213#include&lt;stdio.h&gt;unsigned int a[1000005]=&#123;0,1,2&#125;;int main(void)&#123; for(int i=3;i&lt;=1000000;i++) a[i]=(a[i-1]&lt;&lt;1)+a[i-2],a[i]%=32767; int n; scanf("%d",&amp;n); for(int i=0,temp;i&lt;n;i++)&#123; scanf("%d",&amp;temp); printf("%d\n",a[temp]); &#125; return 0;&#125; T1190: 上台阶【题目描述】楼梯有$n(71&gt;n&gt;0)$阶台阶,上楼时可以一步上$1$阶,也可以一步上$2$阶,也可以一步上$3$阶，编程计算共有多少种不同的走法。 【输入】输入的每一行包括一组测试数据，即为台阶数$n$。最后一行为$0$，表示测试结束。 【输出】每一行输出对应一行输入的结果，即为走法的数目。 【输入样例】1234512340 【输出样例】12341247 【答案&amp;代码】1234567891011#include&lt;stdio.h&gt;long long d[110];int main(void)&#123; d[1]=1,d[2]=2,d[3]=4; for(int i=4;i&lt;=100;i++) d[i]=d[i-1]+d[i-2]+d[i-3]; int n; while(scanf("%d",&amp;n)==1&amp;&amp;n) printf("%lld\n",d[n]); return 0;&#125; T1191: 流感传染【题目描述】有一批易感人群住在网格状的宿舍区内，宿舍区为$n*n$的矩阵，每个格点为一个房间，房间里可能住人，也可能空着。在第一天，有些房间里的人得了流感，以后每天，得流感的人会使其邻居传染上流感，（已经得病的不变），空房间不会传染。请输出第$m$天得流感的人数。 【输入】第一行一个数字$n$，$n$不超过$100$，表示有$n*n$的宿舍房间。 接下来的$n$行，每行$n$个字符，.表示第一天该房间住着健康的人，#表示该房间空着，@表示第一天该房间住着得流感的人。 接下来的一行是一个整数$m$，$m$不超过$100$。 【输出】输出第$m$天，得流感的人数。 【输入样例】12345675....#.#.@..#@..#.........4 【输出样例】116 【答案&amp;代码】123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;char map[101][102],temp[101][102];#include&lt;string.h&gt;int main(void)&#123; int n,m; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%s",map[i]+1); scanf("%d",&amp;m); for(int l=1;l&lt;m;l++)&#123; memcpy(temp,map,sizeof(map)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(temp[i][j]=='.'&amp;&amp; (temp[i-1][j]=='@' ||temp[i+1][j]=='@' ||temp[i][j-1]=='@' ||temp[i][j+1]=='@' ) ) map[i][j]='@'; &#125; int sum=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(map[i][j]=='@') sum+=1; printf("%d",sum); return 0;&#125; T1192: 放苹果【题目描述】把$M$个同样的苹果放在$N$个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用$K$表示）$5,1,1$和$1,5,1$是同一种分法。 【输入】第一行是测试数据的数目$t(0 \leq t \leq 20)$。以下每行均包含二个整数$M$和$N$，以空格分开。$1 \leq M,N \leq 10$。 【输出】对输入的每组数据$M$和$N$，用一行输出相应的$K$。 【输入样例】1217 3 【输出样例】18 【答案&amp;代码】12345678910111213141516171819#include&lt;stdio.h&gt;int f[101][101];int main(void)&#123; int n,m,t; for(int i=0;i&lt;=100;i++) for(int j=0;j&lt;=100;j++) if(i==0||j==1) f[i][j]=1; else if(j&gt;i) f[i][j]=f[i][i]; else f[i][j]=f[i][j-1]+f[i-j][j]; scanf("%d",&amp;t); for(int i=0;i&lt;t;i++) scanf("%d%d",&amp;m,&amp;n), printf("%d\n",f[m][n]); return 0;&#125; T1193: 吃糖果【题目描述】名名的妈妈从外地出差回来，带了一盒好吃又精美的巧克力给名名盒内共有$N$块巧克力，$(0&lt;N&lt;20)$。妈妈告诉名名每天可以吃一块或者两块巧克力。假设名名每天都吃巧克力，问名名共有多少种不同的吃完巧克力的方案。例如：如果$N=1$，则名名第$1$天就吃掉它，共有$1$种方案；如果$N=2$，则名名可以第$1$天吃$1$块，第$2$天吃$1$块，也可以第$1$天吃$2$块，共有$2$种方案；如果$N=3$，则名名第$1$天可以吃$1$块，剩$2$块，也可以第$1$天吃$2$块剩$1$块，所以名名共有$2+1=3$种方案；如果$N=4$，则名名可以第$1$天吃$1$块，剩$3$块，也可以第$1$天吃$2$块，剩$2$块，共有$3+2=5$种方案。现在给定$N$，请你写程序求出名名吃巧克力的方案数目。 【输入】输入只有$1$行，即整数$N$。 【输出】输出只有$1$行，即名名吃巧克力的方案数。 【输入样例】14 【输出样例】15 【答案&amp;代码】12345678910111213141516#include&lt;stdio.h&gt;int f[32]=&#123;0,1,2,3,5&#125;;int fun(int n)&#123; if(f[n]!=0) return f[n]; else if(n==0) return 0; else return f[n]=fun(n-1)+fun(n-2);&#125;int main(void)&#123; int n; scanf("%d",&amp;n); printf("%d",fun(n)); return 0;&#125; T1194: 移动路线【题目描述】$X$桌子上有一个$m$行$n$列的方格矩阵，将每个方格用坐标表示，行坐标从下到上依次递增，列坐标从左至右依次递增，左下角方格的坐标为$(1,1)$，则右上角方格的坐标为$(m,n)$。 小明是个调皮的孩子，一天他捉来一只蚂蚁，不小心把蚂蚁的右脚弄伤了，于是蚂蚁只能向上或向右移动。小明把这只蚂蚁放在左下角的方格中，蚂蚁从左下角的方格中移动到右上角的方格中，每步移动一个方格。蚂蚁始终在方格矩阵内移动，请计算出不同的移动路线的数目。 对于$1$行$1$列的方格矩阵，蚂蚁原地移动，移动路线数为$1$；对于$1$行$2$列（或$2$行$1$列）的方格矩阵，蚂蚁只需一次向右（或向上）移动，移动路线数也为$1…$对于一个$2$行$3$列的方格矩阵，如下图所示： $(2,1)$ $(2,2)$ $(2,3)$ $(1,1)$ $(1,2)$ $(1,3)$ 蚂蚁共有$3$种移动路线： 路线$1$：$(1,1) → (1,2) → (1,3) → (2,3)$ 路线$2$：$(1,1) → (1,2) → (2,2) → (2,3)$ 路线$3$：$(1,1) → (2,1) → (2,2) → (2,3)$ 【输入】输入只有一行，包括两个整数$m$和$n(0&lt;m+n \leq 20)$，代表方格矩阵的行数和列数，$m,n$之间用空格隔开。 【输出】输出只有一行，为不同的移动路线的数目。 【输入样例】12 3 【输出样例】13 【答案&amp;代码】12345678910111213#include&lt;stdio.h&gt;long long map[32][32];int main(void)&#123; for(int i=1;i&lt;=21;i++) map[i][1]=map[1][i]=1; for(int i=2;i&lt;=31;i++) for(int j=2;j&lt;=21;j++) map[i][j]=map[i-1][j]+map[i][j-1]; int m,n; scanf("%d%d",&amp;m,&amp;n); printf("%lld",map[m][n]); return 0;&#125; T1195: 移动路线【题目描述】一个给定的正整数序列，在每个数之前都插入+号或-号后计算它们的和。比如序列：$1,2,4$共有$8$种可能的序列： 123456789101112131415(+1) + (+2) + (+4) = 7(+1) + (+2) + (-4) = -1(+1) + (-2) + (+4) = 3(+1) + (-2) + (-4) = -5(-1) + (+2) + (+4) = 5(-1) + (+2) + (-4) = -3(-1) + (-2) + (+4) = 1(-1) + (-2) + (-4) = -7 所有结果中至少有一个可被整数$k$整除，我们则称此正整数序列可被$k$整除。例如上述序列可以被$3,5,7$整除，而不能被$2,4,6,8,…$整除。注意：$0,-3,-6,-9,…$都可以认为是$3$的倍数。 【输入】输入的第一行包含两个数：$N(2&lt;N&lt;10000)$和$k(2&lt;k&lt;100)$，其中$N$代表一共有$N$个数，$k$代表被除数。第二行给出序列中的$N$个整数，这些整数的取值范围都$0$到$10000$之间（可能重复）。 【输出】如果此正整数序列可被$k$整除，则输出YES，否则输出NO。（注意：都是大写字母） 【输入样例】123 21 2 4 【输出样例】1NO 【答案&amp;代码】123456789101112131415161718#include&lt;stdio.h&gt;bool f[10005][205];int a[10005];int main(void)&#123; int n,k; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",a+i); f[1][(a[1]%k+k)%k]=1; for(int i=2;i&lt;=n;i++) for(int j=0;j&lt;k;j++) f[i][j]=(f[i-1][((j-a[i])%k+k)%k]||f[i-1][(j+a[i])%k]); if(f[n][0]) printf("YES"); else printf("NO"); return 0;&#125; T1196: 踩方格【题目描述】有一个方格矩阵，矩阵边界在无穷远处。我们做如下假设： 每走一步时，只能从当前方格移动一格，走到某个相邻的方格上； 走过的格子立即塌陷无法再走第二次； 只能向北、东、西三个方向走； 请问：如果允许在方格矩阵上走$n$步，共有多少种不同的方案。$2$种走法只要有一步不一样，即被认为是不同的方案。 【输入】允许在方格上行走的步数$n(n \leq 20)$。 【输出】计算出的方案数量。 【输入样例】12 【输出样例】17 【答案&amp;代码】12345678910#include&lt;stdio.h&gt;int a[21]=&#123;0,3,7&#125;;int main(void)&#123; int n; scanf("%d",&amp;n); for(int i=3;i&lt;=n;i++) a[i]=2*a[i-1]+a[i-2]; printf("%d",a[n]); return 0;&#125; T1197: 山区建小学【题目描述】政府在某山区修建了一条道路，恰好穿越总共m个村庄的每个村庄一次，没有回路或交叉，任意两个村庄只能通过这条路来往。已知任意两个相邻的村庄之间的距离为$d_i$（为正整数），其中，$0&lt;i&lt;m$。为了提高山区的文化素质，政府又决定从$m$个村中选择$n$个村建小学（设$0&lt;n \leq m&lt;500$）。请根据给定的$m,n$以及所有相邻村庄的距离，选择在哪些村庄建小学，才使得所有村到最近小学的距离总和最小，计算最小值。 【输入】第$1$行为$m$和$n$，其间用空格间隔。 第$2$行为$m−1$个整数，依次表示从一端到另一端的相邻村庄的距离，整数之间以空格间隔。 例如: 1210 32 4 6 5 2 4 3 1 3 表示在$10$个村庄建$3$所学校。第$1$个村庄与第$2$个村庄距离为$2$，第$2$个村庄与第$3$个村庄距离为$4$，第$3$个村庄与第$4$个村庄距离为$6$，$…$，第$9$个村庄到第$10$个村庄的距离为3$。 【输出】各村庄到最近学校的距离之和的最小值。 【输入样例】1210 23 1 3 1 1 1 1 1 3 【输出样例】118 【答案&amp;代码】12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;int f[510][510],dis[510][510],d[510],s[510][510];int min(int a,int b)&#123; return a&lt;b?a:b;&#125;int abs(int n)&#123; return n&gt;0?n:(-n);&#125;int dist(int i,int j)&#123; int x=0; int mid=(i+j)/2; for(int k=i;k&lt;=j;k++) x+=dis[k][mid]; return x;&#125;int main(void)&#123; int m,n; scanf("%d%d",&amp;m,&amp;n); for(int i=2,temp;i&lt;=m;i++) scanf("%d",&amp;temp), d[i]=d[i-1]+temp; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=m;j++) if(i==j) dis[i][j]=0; else dis[i][j]=dis[j][i]=abs(d[j]-d[i]); for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=m;j++) s[i][j]=dist(i,j); for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=m;j++) f[i][j]=0X3F3F3F3F; for(int i=1;i&lt;=m;i++) f[i][i]=0,f[i][1]=s[1][i]; for(int i=2;i&lt;=m;i++) for(int j=2;j&lt;=min(i,n);j++) for(int k=j-1;k&lt;=i-1;k++) if(i!=j) f[i][j]=min(f[i][j],f[k][j-1]+s[k+1][i]); printf("%d",f[m][n]); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>信息学奥赛一本通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息学奥赛一本通（C++版）第二部分 基础算法 第二章 数据排序]]></title>
    <url>%2FSolution%2FYBT%2F2.2%2F</url>
    <content type="text"><![CDATA[信息学奥赛一本通（C++版）第二部分 基础算法 第二章 数据排序 T1310 : 车厢重组 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转$180$度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。 【输入】有两行数据，第一行是车厢总数$N(N \leq 10000)$，第二行是$N$个不同的数表示初始的车厢顺序。 【输出】一个数据，是最少的旋转次数。 【输入样例】1244 3 2 1 【输出样例】16 【答案&amp;代码】显然，题意说明，我们只能将相邻的车厢位置交换，这显然是冒泡排序的实现过程，所以这道题目，应该用冒泡排序来解决，代码如下。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;void swap(int *a,int *b)&#123;/*交换a,b的值*/ int temp=*a; *a=*b; *b=temp; return;&#125;int main(void)&#123; int n; scanf("%d",&amp;n); int box[n]; for(int i=0;i&lt;n;i++) scanf("%d",&amp;box[i]); int sum=0; for(int i=1;i&lt;n;i++) for(int j=0;j&lt;i;j++) if(box[i]&lt;box[j])&#123; swap(&amp;box[i],&amp;box[j]); sum+=1;/*每交换1次，交换次数加1*/ &#125; printf("%d",sum); return 0;&#125; T1311 : 求逆序对 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】给定一个序列$a_{1},a_{2},…,a_{n}$，如果存在$i&lt;j$并且$a_{i}&gt;a_{j}$，那么我们称之为逆序对，求逆序对的数目。 【输入】第一行为$n$,表示序列长度，接下来的$n$行，第$i+1$行表示序列中的第$i$个数。 【输出】所有逆序对总数。 【输入样例】1234543232 【输出样例】13 【提示】$N \leq 10^5,A_{i} \leq 10^5$。 【答案&amp;代码】通过理性分析，我们可以得出，用所有的排序算法都可以完成本题，只需要统计每一个数所构成的逆序对个数即可，但是因为冒泡排序、插入排序等排序算法时间复杂度为$O(n^{2})$，快速排序不稳定，此题应选用归并排序，代码如下。 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;int n,a[100001],c[100001];unsigned long long ans=0;void m(int l,int r)&#123; int mid=(l+r)/2,i,j,tmp; if(l&gt;=r) return; m(l,mid); m(mid+1,r); tmp=l; for(i=l,j=mid+1;i&lt;=mid&amp;&amp;j&lt;=r;) if(a[i]&gt;a[j]) c[tmp++]=a[j++],ans+=mid-i+1; else c[tmp++]=a[i++]; if(i&lt;=mid) for(;i&lt;=mid;) c[tmp++]=a[i++]; if(j&lt;=r) for(;j&lt;=r;) c[tmp++]=a[j++]; for(i=l;i&lt;=r;i++) a[i]=c[i];&#125;int main(void)&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",a+i); m(1,n); printf("lld",ans); return 0;&#125; T1176 : 谁考了第k名 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第$k$名学生的学号和成绩。 【输入】第一行有两个整数，分别是学生的人数$n(1 \leq n \leq 100)$，和求第$k$名学生的$k(1 \leq k \leq n)$。 其后有$n$行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。 【输出】输出第$k$名学生的学号和成绩，中间用空格分隔。（注：请用%g输出成绩） 【输入样例】1234565 390788001 67.890788002 90.390788003 6190788004 68.490788005 73.9 【输出样例】190788004 68.4 【答案&amp;代码】显然，对于每$1$个已知的学号，都有且只有$1$个成绩，所以我们可以使用结构体来解决这道题，结构体进行排序（运用&lt;algorithm&gt;中的std::sort函数）需要对&lt;运算符进行重载或运用自定义的比较函数，代码如下。 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;algorithm&gt;struct st&#123; char id[16]; double gr;&#125;;bool cmp(st a,st b)&#123; return a.gr&gt;b.gr;&#125;int main(void)&#123; int n,k; scanf("%d%d",&amp;n,&amp;k); st stu[n]; for(int i=0;i&lt;n;i++) scanf("%s%lf",stu[i].id,&amp;stu[i].gr); std::sort(stu,stu+n,cmp); printf("%s %g",stu[k-1].id,stu[k-1].gr); return 0;&#125; T1177 : 奇数单增序列 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】给定一个长度为$N$（不大于$500$）的正整数序列，请将其中的所有奇数取出，并按升序输出。 【输入】第$1$行为$N$； 第$2$行为$N$个正整数，其间用空格间隔。 【输出】增序输出的奇数序列，数据之间以逗号间隔。数据保证至少有一个奇数。 【输入样例】12101 3 2 6 5 4 9 8 7 10 【输出样例】11,3,5,7,9 【答案&amp;代码】我们只需要在输入的时候使用一些小技巧，将偶数去除，再将数组排序输出即可，代码如下。 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;algorithm&gt;int main(void)&#123; int n; scanf("%d",&amp;n); int num[n]; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;num[i]); if(num[i]%2==0) i--,n--; &#125; std::sort(num,num+n); printf("%d",num[0]); for(int i=1;i&lt;n;i++) printf(",%d",num[i]); return 0;&#125; T1178 : 成绩排序 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】给出班里某门课程的成绩单，请你按成绩从高到低对成绩单排序输出，如果有相同分数则名字字典序小的在前。 【输入】第一行为$n(0&lt;n&lt;20)$，表示班里的学生数目； 接下来的$n$行，每行为每个学生的名字和他的成绩，中间用单个空格隔开。名字只包含字母且长度不超过$20$，成绩为一个不大于$100$的非负整数。 【输出】把成绩单按分数从高到低的顺序进行排序并输出，每行包含名字和分数两项，之间有一个空格。 【输入样例】123454Kitty 80Hanmeimei 90Joey 92Tim 28 【输出样例】1234Joey 92Hanmeimei 90 Kitty 80Tim 28 【答案&amp;代码】思路与T1176类似，代码如下。 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;struct st&#123; char id[16]; int gr;&#125;;bool cmp(st a,st b)&#123; if(a.gr==b.gr) return strcmp(a.id,b.id)==-1; else return a.gr&gt;b.gr;&#125;int main(void)&#123; int n; scanf("%d",&amp;n); st stu[n]; for(int i=0;i&lt;n;i++) scanf("%s%d",stu[i].id,&amp;stu[i].gr); std::sort(stu,stu+n,cmp); for(int i=0;i&lt;n;i++) printf("%s %d\n",stu[i].id,stu[i].gr); return 0;&#125; T1179 : 奖学金 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前$5$名学生发奖学金。期末，每个学生都有$3$门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。 任务：先根据输入的$3$门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名学生的学号和总分。注意，在前$5$名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分)是： 127 2795 279 这两行数据的含义是：总分最高的两个同学的学号依次是$7$号、$5$号。这两名同学的总分都是$279$(总分等于输入的语文、数学、英语三科成绩之和)，但学号为$7$的学生语文成绩更高一些。如果你的前两名的输出数据是： 125 2797 279 则按输出错误处理，不能得分。 【输入】包含$n+1$行: 第$1$行为一个正整数$n$（小于$300$），表示该校参加评选的学生人数。 第$2$到$n+1$行，每行有$3$个用空格隔开的数字，每个数字都在$0$到$100$之间。第$j$行的$3$个数字依次表示学号为$j-1$的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为$1-n$（恰好是输入数据的行号减$1$）。 【输出】共有$5$行，每行是两个用空格隔开的正整数，依次表示前$5$名学生的学号和总分。 【输入样例1】1234567690 67 8087 66 9178 89 9188 99 7767 89 6478 89 98 【输出样例1】123456 2654 2643 2582 2441 237 【输入样例2】123456789880 89 8988 98 7890 67 8087 66 9178 89 9188 99 7767 89 6478 89 98 【输出样例2】123458 2652 2646 2641 2585 258 【答案&amp;代码】代码如下。 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;struct node&#123; int id,Ch,Ma,En;&#125;;bool cmp(node a,node b)&#123; if(a.Ch+a.Ma+a.En==b.Ch+b.Ma+b.En) if(a.Ch==b.Ch) return a.id&lt;b.id; else return a.Ch&gt;b.Ch; else return a.Ch+a.Ma+a.En&gt;b.Ch+b.Ma+b.En;&#125;int main(void)&#123; int n; scanf("%d",&amp;n); node st[n]; for(int i=0;i&lt;n;i++)&#123; st[i].id=i+1; scanf("%d %d %d",&amp;st[i].Ch,&amp;st[i].Ma,&amp;st[i].En); &#125; std::sort(st,st+n,cmp); for(int i=0;i&lt;5;i++) printf("%d %d\n",st[i].id,st[i].Ch+st[i].Ma+st[i].En); return 0;&#125; T1180 : 分数线划定 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】世博会志愿者的选拔工作正在$A$市如火如荼的进行。为了选拔最合适的人才，$A$市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的$150$划定，即如果计划录取$m$名志愿者，则面试分数线为排名第$m×1.5$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。 现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。 【输入】第一行，两个整数$n,m(5 \leq n \leq 5000,3 \leq m \leq n)$，中间用一个空格隔开，其中$n$表示报名参加笔试的选手总数，$m$表示计划录取的志愿者人数。输入数据保证$m×1.5$向下取整后小于等于$n$。 第二行到第$n+1$行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号$k(1000 \leq k \leq 9999)$和该选手的笔试成绩$s(1 \leq s \leq 100)$。数据保证选手的报名号各不相同。 【输出】第一行，有两个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。 从第二行开始，每行包含两个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。 【输入样例】12345676 31000 903239 882390 957231 841005 951001 88 【输出样例】12345688 51005 952390 951000 901001 883239 88 【答案&amp;代码】代码如下。 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;struct student&#123; int ID,score;&#125;stu[5000];bool cmp(student a, student b)&#123; if (a.score!=b.score) return a.score&gt;b.score; return a.ID&lt;b.ID;&#125;int main(void)&#123; int n,m,want; scanf("%d%d",&amp;n,&amp;m); want=floor(m*1.5); for(int i=0; i&lt;n; i++) scanf("%d%d",&amp;stu[i].ID,&amp;stu[i].score); std::sort(stu,stu+n,cmp); int score=stu[want-1].score; int sum=want; for(int i=want;i&lt;n;i++) if(stu[i].score==stu[want-1].score) sum+=1; printf("%d %d\n",score,sum); for(int i=0;i&lt;sum;i++) printf("%d %d\n",stu[i].ID,stu[i].score); return 0;&#125; T1181 : 整数奇偶排序 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】给定$10$个整数的序列，要求对其重新排序。排序要求： 奇数在前，偶数在后； 奇数按从大到小排序； 偶数按从小到大排序。 【输入】输入一行，包含$10$个整数，彼此以一个空格分开，每个整数的范围是大于等于$0$，小于等于$100$。 【输出】按照要求排序后输出一行，包含排序后的$10$个整数，数与数之间以一个空格分开。 【输入样例】14 7 3 13 11 12 0 47 34 98 【输出样例】147 13 11 7 3 0 4 12 34 98 【答案&amp;代码】代码如下。 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;algorithm&gt;int main(void)&#123; int num[10]; int ji=0,ou=0; for(int i=0;i&lt;10;i++)&#123; scanf("%d",&amp;num[i]); if(num[i]%2==1) ji+=1; else ou+=1; &#125; int jin[ji],oun[ou]; int tj=0,to=0; for(int i=0;i&lt;10;i++)&#123; if(num[i]%2==1) jin[tj]=num[i],tj++; else oun[to]=num[i],to++; &#125; std::sort(jin,jin+ji); for(int i=ji-1;i&gt;=0;i--) printf("%d ",jin[i]); std::sort(oun,oun+ou); for(int i=0;i&lt;ou;i++) printf("%d ",oun[i]); return 0;&#125; T1182 : 合影效果 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】小云和朋友们去爬香山，为美丽的景色所陶醉，想合影留念。如果他们站成一排，男生全部在左（从拍照者的角度），并按照从矮到高的顺序从左到右排，女生全部在右，并按照从高到矮的顺序从左到右排，请问他们合影的效果是什么样的（所有人的身高都不同）？ 【输入】第一行是人数$n$（$2 \leq n \leq 40$，且至少有$1$个男生和$1$个女生）。 后面紧跟$n$行，每行输入一个人的性别（男male或女female）和身高（浮点数，单位米），两个数据之间以空格分隔。 【输出】$n$个浮点数，模拟站好队后，拍照者眼中从左到右每个人的身高。每个浮点数需保留到小数点后$2$位，相邻两个数之间用单个空格隔开。 【输入样例】12345676male 1.72male 1.78female 1.61male 1.65female 1.70female 1.56 【输出样例】11.65 1.72 1.78 1.70 1.61 1.56 【答案&amp;代码】代码如下。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;algorithm&gt;struct p&#123; bool MF; double height;&#125;;bool cmp(p a,p b)&#123; if(a.MF!=b.MF) return a.MF==false; else return a.MF==false?a.height&lt;b.height:a.height&gt;b.height;&#125;int main(void)&#123; int n; scanf("%d",&amp;n); p h[n]; char temp[7]; for(int i=0;i&lt;n;i++)&#123; scanf("%s",temp); if(temp[0]=='m') h[i].MF=false; else h[i].MF=true; scanf("%lf",&amp;h[i].height); &#125; std::sort(h,h+n,cmp); for(int i=0;i&lt;n;i++) printf("%.2f ",h[i].height); return 0;&#125; T1183: 病人排队 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】病人登记看病，编写一个程序，将登记的病人按照以下原则排出看病的先后顺序： 老年人（年龄$≥60$岁）比非老年人优先看病。 老年人按年龄从大到小的顺序看病，年龄相同的按登记的先后顺序排序。 非老年人按登记的先后顺序看病。 【输入】第$1$行，输入一个小于$100$的正整数，表示病人的个数； 后面按照病人登记的先后顺序，每行输入一个病人的信息，包括：一个长度小于$10$的字符串表示病人的$ID$（每个病人的$ID$各不相同且只含数字和字母），一个整数表示病人的年龄，中间用单个空格隔开。 【输出】按排好的看病顺序输出病人的$ID$，每行一个。 【输入样例】1234565021075 40004003 15010158 67021033 75102012 30 【输出样例】12345021033010158021075004003102012 【答案&amp;代码】代码如下。 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;struct p&#123; char xh[15]; int nl;&#125;;p a[110],b[110],c;int main(void)&#123; int m,f(0),s(0); scanf("%d",&amp;m); for(int i=0;i&lt;m;i++)&#123; scanf("%s%d",c.xh,&amp;c.nl); if(c.nl&gt;=60) a[f++]=c; else b[s++]=c; &#125; p t; for(int i=1;i&lt;f;i++)&#123; t=a[i]; int j; for(j=i-1;j&gt;=0;j--) if(a[j].nl&lt;t.nl) a[j+1]=a[j]; else break; a[j+1]=t; &#125; for(int i=0;i&lt;f;i++) printf("%s\n",a[i].xh); for(int i=0;i&lt;s;i++) printf("%s\n",b[i].xh); return 0;&#125; T1184: 明明的随机数 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了$N$个$1$到$1000$之间的随机整数$(N \leq 100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成去重与排序的工作。 【输入】有$2$行，第$1$行为$1$个正整数，表示所生成的随机数的个数：$N$； 第$2$行有$N$个用空格隔开的正整数，为所产生的随机数。 【输出】也是$2$行，第$1$行为$1$个正整数$M$，表示不相同的随机数的个数。第$2$行为$M$个用空格隔开的正整数，为从小到大排好序的不相同的随机数。 【输入样例】121020 40 32 67 40 20 89 300 400 15 【输出样例】12815 20 32 40 67 89 300 400 【答案&amp;代码】代码如下。 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;algorithm&gt;int main(void)&#123; int n; scanf("%d",&amp;n); int num[n]; for(int i=0;i&lt;n;i++) scanf("%d",&amp;num[i]); std::sort(num,num+n); int MAX=num[n-1],sum=0; for(int i=0;i&lt;n-1;i++) if(num[i]==num[i+1])&#123; num[i]=MAX; sum+=1; &#125; std::sort(num,num+n); printf("%d\n",n-sum); for(int i=0;i&lt;n;i++) if(num[i]!=MAX) printf("%d ",num[i]); else break; printf("%d",MAX); return 0;&#125; T1185: 单词排序 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】输入一行单词序列，相邻单词之间由$1$个或多个空格间隔，请按照字典序输出这些单词，要求重复的单词只输出一次。（区分大小写） 【输入】一行单词序列，最少$1$个单词，最多$100$个单词，每个单词长度不超过$50$，单词之间用至少$1$个空格间隔。数据不含除字母、空格外的其他字符。 【输出】按字典序输出这些单词，重复的单词只输出一次。 【输入样例】1She wants to go to Peking University to study Chinese 【输出样例】12345678ChinesePekingSheUniversitygostudytowants 【答案&amp;代码】代码如下。 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int main(void)&#123; int n=0; string str[100]; while(n&lt;=100&amp;&amp;cin&gt;&gt;str[n])&#123; n++; &#125; sort(str,str+n); for(int i=0;i&lt;n;i++)&#123; if(i!=0&amp;&amp;str[i-1]!=str[i]) cout&lt;&lt;str[i]&lt;&lt;'\n'; else if(i==0) cout&lt;&lt;str[i]&lt;&lt;'\n'; &#125; return 0;&#125; T1186: 出现次数超过一半的数 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】给出一个含有$n(0&lt;n \leq 1000)$个整数的数组，请找出其中出现次数超过一半的数。数组中的数大于$-50$且小于$50$。 【输入】第一行包含一个整数$n$，表示数组大小； 第二行包含$n$个整数，分别是数组中的每个元素，相邻两个元素之间用单个空格隔开。 【输出】如果存在这样的数，输出这个数；否则输出no。 【输入样例】1231 2 2 【输出样例】12 【答案&amp;代码】代码如下。 12345678910111213141516171819#include&lt;stdio.h&gt;int main(void)&#123; int n,a[10001]=&#123;0&#125;,i,b[10001]=&#123;0&#125;,t=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++) b[a[i]]++; for(i=1;i&lt;=n;i++)&#123; if(b[a[i]]&gt;n/2)&#123; printf("%d",a[i]); t=1; break; &#125; &#125; if(t==0) printf("no"); return 0;&#125; T1187: 统计字符数 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】给定一个由$a-z$这$26$个字符组成的字符串，统计其中哪个字符出现的次数最多。 【输入】输入包含一行，一个字符串，长度不超过$1000$。 【输出】输出一行，包括出现次数最多的字符和该字符出现的次数，中间以一个空格分开。如果有多个字符出现的次数相同且最多，那么输出ASCII码最小的那一个字符。 【输入样例】1abbccc 【输出样例】1c 3 【答案&amp;代码】代码如下。 123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char str[1001]; int cs[26]=&#123;0&#125;; scanf("%s",str); for(int i=0;i&lt;strlen(str);i++) cs[str[i]-'a']+=1; int max=-1,maxd=0; for(int i=0;i&lt;26;i++) if(cs[i]&gt;max) max=cs[i],maxd=i; printf("%c %d",maxd+'a',max); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>信息学奥赛一本通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息学奥赛一本通（C++版）第二部分 基础算法 第一章 高精度计算]]></title>
    <url>%2FSolution%2FYBT%2F2.1%2F</url>
    <content type="text"><![CDATA[信息学奥赛一本通（C++版）第二部分 基础算法 第一章 高精度计算 T1307 : 高精度乘法 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】输入两个高精度正整数$M$和$N$（$M$和$N$均小于$100$位）。求这两个高精度数的积。 【输入】输入两个高精度正整数$M$和$N$。 【输出】求这两个高精度数的积。 【输入样例】12363 【输出样例】1108 【答案&amp;代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;iostream&gt;#include&lt;string&gt;using std::string;using std::cin;using std::cout;using std::istream;using std::ostream;using std::endl;using std::max;#define MAX_LENGTH 2005struct BIG_NUMBER&#123; int len,s[MAX_LENGTH]; bool sign; BIG_NUMBER(void); BIG_NUMBER(const char*); BIG_NUMBER(int); ~BIG_NUMBER(void); void clean(void); string toStr(void)const; friend istream&amp; operator&gt;&gt;(istream&amp;,BIG_NUMBER&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;,BIG_NUMBER&amp;); BIG_NUMBER operator=(const char*); BIG_NUMBER operator=(int); BIG_NUMBER operator=(const string); bool operator&gt;(const BIG_NUMBER&amp;)const; bool operator&gt;=(const BIG_NUMBER&amp;)const; bool operator&lt;(const BIG_NUMBER&amp;)const; bool operator&lt;=(const BIG_NUMBER&amp;)const; bool operator==(const BIG_NUMBER&amp;)const; bool operator!=(const BIG_NUMBER&amp;)const; BIG_NUMBER operator+(const BIG_NUMBER&amp;)const; BIG_NUMBER operator++(void); BIG_NUMBER operator++(int); BIG_NUMBER operator+=(const BIG_NUMBER&amp;); BIG_NUMBER operator-(const BIG_NUMBER &amp;) const; BIG_NUMBER operator--(void); BIG_NUMBER operator--(int); BIG_NUMBER operator-=(const BIG_NUMBER&amp;); BIG_NUMBER operator*(const BIG_NUMBER &amp;)const; BIG_NUMBER operator*(const int num)const; BIG_NUMBER operator*=(const BIG_NUMBER&amp;); BIG_NUMBER operator/(const BIG_NUMBER&amp;)const; BIG_NUMBER operator/=(const BIG_NUMBER&amp;); BIG_NUMBER operator%(const BIG_NUMBER&amp;)const; BIG_NUMBER factorial(void)const; BIG_NUMBER sqrt(void)const; BIG_NUMBER pow(const BIG_NUMBER&amp;)const;&#125;;BIG_NUMBER::BIG_NUMBER(void)&#123; memset(s, 0, sizeof(s)); len = 1; sign = 1;&#125;BIG_NUMBER::BIG_NUMBER(const char*num)&#123; *this = num;&#125;BIG_NUMBER::BIG_NUMBER(int num)&#123; *this = num;&#125;string BIG_NUMBER::toStr(void)const&#123; string res; res = ""; for (int i = 0; i &lt; len; i++) res = (char)(s[i] + '0') + res; if (res == "") res = "0"; if (!sign&amp;&amp;res != "0") res = "-" + res; return res;&#125;istream &amp;operator&gt;&gt;(istream &amp;in,BIG_NUMBER&amp;num)&#123; string str; in&gt;&gt;str; num=str; return in;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;out,BIG_NUMBER&amp;num)&#123; out&lt;&lt;num.toStr(); return out;&#125;BIG_NUMBER BIG_NUMBER::operator=(const char*num)&#123; memset(s, 0, sizeof(s)); char a[MAX_LENGTH] = ""; if (num[0] != '-') strcpy(a, num); else for (int i = 1; i &lt; strlen(num); i++) a[i - 1] = num[i]; sign = !(num[0] == '-'); len = strlen(a); for (int i = 0; i &lt; strlen(a); i++) s[i] = a[len - i - 1] - 48; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator=(int num)&#123; char temp[MAX_LENGTH]; sprintf(temp, "%d", num); *this = temp; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator=(const string num)&#123; const char *tmp; tmp = num.c_str(); *this = tmp; return *this;&#125;bool BIG_NUMBER::operator&lt;(const BIG_NUMBER&amp;num)const&#123; if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; i--) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (!(s[i] &lt; num.s[i])); return !sign;&#125;bool BIG_NUMBER::operator&gt;(const BIG_NUMBER&amp;num)const&#123; return num &lt; *this;&#125;bool BIG_NUMBER::operator&lt;=(const BIG_NUMBER&amp;num)const&#123; return !(*this&gt;num);&#125;bool BIG_NUMBER::operator&gt;=(const BIG_NUMBER&amp;num)const&#123; return !(*this&lt;num);&#125;bool BIG_NUMBER::operator!=(const BIG_NUMBER&amp;num)const&#123; return *this &gt; num || *this &lt; num;&#125;bool BIG_NUMBER::operator==(const BIG_NUMBER&amp;num)const&#123; return !(num != *this);&#125;BIG_NUMBER BIG_NUMBER::operator+(const BIG_NUMBER &amp;num)const&#123; if (sign^num.sign) &#123; BIG_NUMBER tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; &#125; BIG_NUMBER result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) &#123; int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; &#125; result.sign = sign; return result;&#125;BIG_NUMBER BIG_NUMBER::operator++(void)&#123; *this = *this + 1; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator++(int)&#123; BIG_NUMBER old = *this; ++(*this); return old;&#125;BIG_NUMBER BIG_NUMBER::operator+=(const BIG_NUMBER &amp;num)&#123; *this = *this + num; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator-(const BIG_NUMBER &amp;num) const&#123; BIG_NUMBER b=num,a=*this; if (!num.sign &amp;&amp; !sign) &#123; b.sign=1; a.sign=1; return b-a; &#125; if (!b.sign) &#123; b.sign=1; return a+b; &#125; if (!a.sign) &#123; a.sign=1; b=BIG_NUMBER(0)-(a+b); return b; &#125; if (a&lt;b) &#123; BIG_NUMBER c=(b-a); c.sign=false; return c; &#125; BIG_NUMBER result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) &#123; int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else &#123; g = 1; x += 10; &#125; result.s[result.len++] = x; &#125; result.clean(); return result;&#125;BIG_NUMBER BIG_NUMBER::operator*(const BIG_NUMBER &amp;num)const&#123; BIG_NUMBER result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) &#123; result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; &#125; result.clean(); result.sign = !(sign^num.sign); return result;&#125;BIG_NUMBER BIG_NUMBER::operator*(const int num)const&#123; BIG_NUMBER x = num; BIG_NUMBER z = *this; return x*z;&#125;BIG_NUMBER BIG_NUMBER::operator*=(const BIG_NUMBER&amp;num)&#123; *this = *this * num; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator/(const BIG_NUMBER&amp;num)const&#123; BIG_NUMBER ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) &#123; ans.len = 1; return ans; &#125; BIG_NUMBER divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) &#123; while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_LENGTH]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + '0'; BIG_NUMBER dividend = z; if (dividend &lt; divid) &#123; k--; continue; &#125; int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; BIG_NUMBER temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; &#125; ans.clean(); ans.sign = !(sign^num.sign); return ans;&#125;BIG_NUMBER BIG_NUMBER::operator/=(const BIG_NUMBER&amp;num)&#123; *this = *this / num; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator%(const BIG_NUMBER&amp; num)const&#123; BIG_NUMBER a = *this, b = num; a.sign = b.sign = 1; BIG_NUMBER result, temp = a / b*b; result = a - temp; result.sign = sign; return result;&#125;BIG_NUMBER BIG_NUMBER::pow(const BIG_NUMBER&amp; num)const&#123; BIG_NUMBER result = 1; for (BIG_NUMBER i = 0; i &lt; num; i++) result = result*(*this); return result;&#125;BIG_NUMBER BIG_NUMBER::factorial(void)const&#123; BIG_NUMBER result = 1; for (BIG_NUMBER i = 1; i &lt;= *this; i++) result *= i; return result;&#125;void BIG_NUMBER::clean(void)&#123; if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == '\0') len--;&#125;BIG_NUMBER BIG_NUMBER::sqrt(void)const&#123; if(*this&lt;0)return -1; if(*this&lt;=1)return *this; BIG_NUMBER l=0,r=*this,mid; while(r-l&gt;1) &#123; mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; &#125; return l;&#125;BIG_NUMBER::~BIG_NUMBER(void)&#123;&#125;int main(void)&#123; BIG_NUMBER m,n,res; cin&gt;&gt;m&gt;&gt;n; res=m*n; cout&lt;&lt;res; return 0;&#125; T1308 : 高精除 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】高精除以高精，求它们的商和余数。 【输入】输入两个低于$300$位的正整数。 【输出】输出商和余数。 【输入样例】1212313123184575776878979876423245678643245678765432456714253467567868678678671231312318767141738178325678412414124141425346756786867867867 【输出样例】12999999999748590179780909068307566598992807564736854549985603543237528310337 【答案&amp;代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;iostream&gt;#include&lt;string&gt;using std::string;using std::cin;using std::cout;using std::istream;using std::ostream;using std::endl;using std::max;#define MAX_LENGTH 2005struct BIG_NUMBER&#123; int len,s[MAX_LENGTH]; bool sign; BIG_NUMBER(void); BIG_NUMBER(const char*); BIG_NUMBER(int); ~BIG_NUMBER(void); void clean(void); string toStr(void)const; friend istream&amp; operator&gt;&gt;(istream&amp;,BIG_NUMBER&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;,BIG_NUMBER&amp;); BIG_NUMBER operator=(const char*); BIG_NUMBER operator=(int); BIG_NUMBER operator=(const string); bool operator&gt;(const BIG_NUMBER&amp;)const; bool operator&gt;=(const BIG_NUMBER&amp;)const; bool operator&lt;(const BIG_NUMBER&amp;)const; bool operator&lt;=(const BIG_NUMBER&amp;)const; bool operator==(const BIG_NUMBER&amp;)const; bool operator!=(const BIG_NUMBER&amp;)const; BIG_NUMBER operator+(const BIG_NUMBER&amp;)const; BIG_NUMBER operator++(void); BIG_NUMBER operator++(int); BIG_NUMBER operator+=(const BIG_NUMBER&amp;); BIG_NUMBER operator-(const BIG_NUMBER &amp;) const; BIG_NUMBER operator--(void); BIG_NUMBER operator--(int); BIG_NUMBER operator-=(const BIG_NUMBER&amp;); BIG_NUMBER operator*(const BIG_NUMBER &amp;)const; BIG_NUMBER operator*(const int num)const; BIG_NUMBER operator*=(const BIG_NUMBER&amp;); BIG_NUMBER operator/(const BIG_NUMBER&amp;)const; BIG_NUMBER operator/=(const BIG_NUMBER&amp;); BIG_NUMBER operator%(const BIG_NUMBER&amp;)const; BIG_NUMBER factorial(void)const; BIG_NUMBER sqrt(void)const; BIG_NUMBER pow(const BIG_NUMBER&amp;)const;&#125;;BIG_NUMBER::BIG_NUMBER(void)&#123; memset(s, 0, sizeof(s)); len = 1; sign = 1;&#125;BIG_NUMBER::BIG_NUMBER(const char*num)&#123; *this = num;&#125;BIG_NUMBER::BIG_NUMBER(int num)&#123; *this = num;&#125;string BIG_NUMBER::toStr(void)const&#123; string res; res = ""; for (int i = 0; i &lt; len; i++) res = (char)(s[i] + '0') + res; if (res == "") res = "0"; if (!sign&amp;&amp;res != "0") res = "-" + res; return res;&#125;istream &amp;operator&gt;&gt;(istream &amp;in,BIG_NUMBER&amp;num)&#123; string str; in&gt;&gt;str; num=str; return in;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;out,BIG_NUMBER&amp;num)&#123; out&lt;&lt;num.toStr(); return out;&#125;BIG_NUMBER BIG_NUMBER::operator=(const char*num)&#123; memset(s, 0, sizeof(s)); char a[MAX_LENGTH] = ""; if (num[0] != '-') strcpy(a, num); else for (int i = 1; i &lt; strlen(num); i++) a[i - 1] = num[i]; sign = !(num[0] == '-'); len = strlen(a); for (int i = 0; i &lt; strlen(a); i++) s[i] = a[len - i - 1] - 48; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator=(int num)&#123; char temp[MAX_LENGTH]; sprintf(temp, "%d", num); *this = temp; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator=(const string num)&#123; const char *tmp; tmp = num.c_str(); *this = tmp; return *this;&#125;bool BIG_NUMBER::operator&lt;(const BIG_NUMBER&amp;num)const&#123; if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; i--) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (!(s[i] &lt; num.s[i])); return !sign;&#125;bool BIG_NUMBER::operator&gt;(const BIG_NUMBER&amp;num)const&#123; return num &lt; *this;&#125;bool BIG_NUMBER::operator&lt;=(const BIG_NUMBER&amp;num)const&#123; return !(*this&gt;num);&#125;bool BIG_NUMBER::operator&gt;=(const BIG_NUMBER&amp;num)const&#123; return !(*this&lt;num);&#125;bool BIG_NUMBER::operator!=(const BIG_NUMBER&amp;num)const&#123; return *this &gt; num || *this &lt; num;&#125;bool BIG_NUMBER::operator==(const BIG_NUMBER&amp;num)const&#123; return !(num != *this);&#125;BIG_NUMBER BIG_NUMBER::operator+(const BIG_NUMBER &amp;num)const&#123; if (sign^num.sign) &#123; BIG_NUMBER tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; &#125; BIG_NUMBER result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) &#123; int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; &#125; result.sign = sign; return result;&#125;BIG_NUMBER BIG_NUMBER::operator++(void)&#123; *this = *this + 1; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator++(int)&#123; BIG_NUMBER old = *this; ++(*this); return old;&#125;BIG_NUMBER BIG_NUMBER::operator+=(const BIG_NUMBER &amp;num)&#123; *this = *this + num; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator-(const BIG_NUMBER &amp;num) const&#123; BIG_NUMBER b=num,a=*this; if (!num.sign &amp;&amp; !sign) &#123; b.sign=1; a.sign=1; return b-a; &#125; if (!b.sign) &#123; b.sign=1; return a+b; &#125; if (!a.sign) &#123; a.sign=1; b=BIG_NUMBER(0)-(a+b); return b; &#125; if (a&lt;b) &#123; BIG_NUMBER c=(b-a); c.sign=false; return c; &#125; BIG_NUMBER result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) &#123; int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else &#123; g = 1; x += 10; &#125; result.s[result.len++] = x; &#125; result.clean(); return result;&#125;BIG_NUMBER BIG_NUMBER::operator*(const BIG_NUMBER &amp;num)const&#123; BIG_NUMBER result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) &#123; result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; &#125; result.clean(); result.sign = !(sign^num.sign); return result;&#125;BIG_NUMBER BIG_NUMBER::operator*(const int num)const&#123; BIG_NUMBER x = num; BIG_NUMBER z = *this; return x*z;&#125;BIG_NUMBER BIG_NUMBER::operator*=(const BIG_NUMBER&amp;num)&#123; *this = *this * num; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator/(const BIG_NUMBER&amp;num)const&#123; BIG_NUMBER ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) &#123; ans.len = 1; return ans; &#125; BIG_NUMBER divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) &#123; while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_LENGTH]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + '0'; BIG_NUMBER dividend = z; if (dividend &lt; divid) &#123; k--; continue; &#125; int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; BIG_NUMBER temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; &#125; ans.clean(); ans.sign = !(sign^num.sign); return ans;&#125;BIG_NUMBER BIG_NUMBER::operator/=(const BIG_NUMBER&amp;num)&#123; *this = *this / num; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator%(const BIG_NUMBER&amp; num)const&#123; BIG_NUMBER a = *this, b = num; a.sign = b.sign = 1; BIG_NUMBER result, temp = a / b*b; result = a - temp; result.sign = sign; return result;&#125;BIG_NUMBER BIG_NUMBER::pow(const BIG_NUMBER&amp; num)const&#123; BIG_NUMBER result = 1; for (BIG_NUMBER i = 0; i &lt; num; i++) result = result*(*this); return result;&#125;BIG_NUMBER BIG_NUMBER::factorial(void)const&#123; BIG_NUMBER result = 1; for (BIG_NUMBER i = 1; i &lt;= *this; i++) result *= i; return result;&#125;void BIG_NUMBER::clean(void)&#123; if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == '\0') len--;&#125;BIG_NUMBER BIG_NUMBER::sqrt(void)const&#123; if(*this&lt;0)return -1; if(*this&lt;=1)return *this; BIG_NUMBER l=0,r=*this,mid; while(r-l&gt;1) &#123; mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; &#125; return l;&#125;BIG_NUMBER::~BIG_NUMBER(void)&#123;&#125;int main(void)&#123; BIG_NUMBER m,n,r1,r2; cin&gt;&gt;m&gt;&gt;n; r1=m/n,r2=m%n; cout&lt;&lt;r1&lt;&lt;'\n'&lt;&lt;r2; return 0;&#125; T1309 : 回文数 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】若一个数（首位不为零）从左向右读与从右向左读都是一样，我们就将其称之为回文数。例如：给定一个$10$进制数$56$，将$56$加$65$（即把$56$从右向左读），得到$121$是一个回文数。写一个程序，给定一个$N(2 &lt; N \leq 10\text{or}N=16)$进制数$M$。求最少经过几步可以得到回文数。如果在$30$步以内（包含$30$步）不可能得到回文数，则输出Impossible。 【输入】给定一个$N(2 &lt; N \leq 10\text{or}N=16)$进制数$M$。 【输出】最少几步。如果在$30$步以内（包含$30$步）不可能得到回文数，则输出Impossible。 【输入样例】19 87 【输出样例】16 【答案&amp;代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;string.h&gt;int n,m[512],size=0;bool check(void)&#123; for(int i=0,j=size-1;i&lt;j;i++,j--) if(m[i]!=m[j]) return false; return true;&#125;void add(void)&#123; int temp[512]=&#123;0&#125;; for(int i=0,j=size-1;i&lt;size;i++,j--) temp[i]=m[i]+m[j]; for(int i=0;i&lt;size;i++) m[i]=temp[i]; for(int i=0;i&lt;511;i++) if(m[i]&gt;=n) m[i+1]+=m[i]/n,m[i]%=n; size=0; for(int i=511;i&gt;=0;i--) if(m[i]!=0)&#123; size=i+1; break; &#125; if(size==0) size=1; return;&#125;int main(void)&#123; scanf("%d\n",&amp;n); char temp[512]; scanf("%s",temp); size=strlen(temp); for(int j=strlen(temp)-1,index=0;j&gt;=0;j--,index++) if('0'&lt;=temp[j]&amp;&amp;temp[j]&lt;='9') m[index]=temp[j]-'0'; else if('a'&lt;=temp[j]&amp;&amp;temp[j]&lt;='f') m[index]=temp[j]-'a'+10; else m[index]=temp[j]-'A'+10; for(int i=0;i&lt;=30;i++)&#123; if(check()) return printf("%d",i),0; add(); &#125; printf("Impossible"); return 0;&#125; T1168 : 大整数加法 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】求两个不超过$200$位的非负整数的和。 【输入】有两行，每行是一个不超过$200$位的非负整数，可能有多余的前导$0$。 【输出】一行，即相加后的结果。结果里不能有多余的前导$0$，即如果结果是$342$，那么就不能输出为$0342$。 【输入样例】122222222222222222222233333333333333333333 【输出样例】155555555555555555555 【答案&amp;代码】1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define jz 10unsigned int a[201]=&#123;0&#125;,b[201]=&#123;0&#125;;int main(void) &#123; char str[201]; scanf("%s",str); for(int i=0,j=strlen(str)-1;j&gt;=0;i++,j--) a[i]=str[j]-'0'; scanf("%s",str); for(int i=0,j=strlen(str)-1;j&gt;=0;i++,j--) b[i]=str[j]-'0'; for(int i=0;i&lt;201;i++) a[i]+=b[i],a[i+1]+=a[i]/jz,a[i]%=jz; a[201]+=b[201],a[201]%=jz; int size=0; for(int i=201;i&gt;=0;i--) if(a[i]!=0)&#123; size=i; break; &#125; for(int i=size;i&gt;=0;i--) printf("%d",a[i]); return 0;&#125; T1169 : 大整数减法 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】求两个大的正整数相减的差。 【输入】共$2$行，第$1$行是被减数$a$，第$2$行是减数$b(a &gt; b)$。每个大整数不超过$200$位，不会有多余的前导零。 【输出】一行，即所求的差。 【输入样例】1299999999999999999999999999999999999999999999999999 【输出样例】19999999999999999999999990000000000000 【答案&amp;代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; using namespace std; const int maxn=1000;struct bign&#123; int d[maxn],len; void clean(void)&#123; while(len &gt; 1 &amp;&amp; !d[len-1]) len--;&#125; bign(void)&#123; memset(d, 0, sizeof(d)); len = 1; &#125; bign(int num) &#123; *this = num; &#125; bign(char* num) &#123; *this = num; &#125; bign operator = (const char* num)&#123; memset(d, 0, sizeof(d)); len = strlen(num); for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - '0'; clean(); return *this; &#125; bign operator = (int num)&#123; char s[20]; sprintf(s, "%d", num); *this = s; return *this; &#125; bign operator + (const bign&amp; b)&#123; bign c = *this; int i; for (i = 0; i &lt; b.len; i++)&#123; c.d[i] += b.d[i]; if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++; &#125; while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++; c.len = max(len, b.len); if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1; return c; &#125; bign operator - (const bign&amp; b)&#123; bign c = *this; int i; for (i = 0; i &lt; b.len; i++)&#123; c.d[i] -= b.d[i]; if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--; &#125; while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--; c.clean(); return c; &#125; bign operator * (const bign&amp; b)const&#123; int i, j; bign c; c.len = len + b.len; for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++) c.d[i+j] += d[i] * b.d[j]; for(i = 0; i &lt; c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10; c.clean(); return c; &#125; bign operator / (const bign&amp; b)&#123; int i, j; bign c = *this, a = 0; for (i = len - 1; i &gt;= 0; i--) &#123; a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; c.d[i] = j; a = a - b*j; &#125; c.clean(); return c; &#125; bign operator % (const bign&amp; b)&#123; int i, j; bign a = 0; for (i = len - 1; i &gt;= 0; i--) &#123; a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; a = a - b*j; &#125; return a; &#125; bign operator += (const bign&amp; b)&#123; *this = *this + b; return *this; &#125; bool operator &lt;(const bign&amp; b)&#123; if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) if(d[i] != b.d[i]) return d[i] &lt; b.d[i]; return false; &#125; void Print()&#123; char s[maxn]=&#123;0&#125;; for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+'0'; printf("%s",s); return; &#125; &#125;;int main(void)&#123; char num[201]; scanf("%s",num); bign a=num; scanf("%s",num); bign b=num; (a-b).Print(); return 0;&#125; T1170 : 计算2的N次方 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】任意给定一个正整数$N(N \leq 100)$，计算$2$的$n$次方的值。 【输入】输入一个正整数$N$。 【输出】输出$2$的$N$次方的值。 【输入样例】15 【输出样例】132 【答案&amp;代码】1234567891011121314151617181920212223#include&lt;stdio.h&gt;unsigned short num[100];int main(void)&#123; int n; scanf("%d",&amp;n); num[0]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;100;j++) num[j]*=2; for(int j=0;j&lt;99;j++) num[j+1]+=num[j]/10,num[j]%=10; num[99]%=10; &#125; int size=0; for(int i=99;i&gt;=0;i--) if(num[i]!=0)&#123; size=i; break; &#125; for(int i=size;i&gt;=0;i--) printf("%d",num[i]); return 0;&#125; T1171 : 大整数的因子 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】已知正整数$k$满足$2 \leq k \leq 9$，现给出长度最大为$30$位的十进制非负整数$c$，求所有能整除$c$的$k$。 【输入】一个非负整数$c$，$c$的位数不超过$30$。 【输出】若存在满足$c \% k = 0$的$k$，从小到大输出所有这样的$k$，相邻两个数之间用单个空格隔开；若没有这样的$k$，则输出none。 【输入样例】130 【输出样例】12 3 5 6 【答案&amp;代码】123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int a[50],b[50];char str[50];int divide(int x)&#123; int i=a[0],res=0; while(i&gt;0) res*=10, res+=a[i], res%=x, i--; return res;&#125;int main(void)&#123; int len; bool flag=false; int i; cin&gt;&gt;str; len=strlen(str); int k=1; for(i=len-1;i&gt;=0;i--) a[k]=str[i]-'0', k++; a[0]=len; for(i=2;i&lt;=9;i++) if(divide(i)==false) flag=true, cout&lt;&lt;i&lt;&lt;" "; if(flag==false) cout&lt;&lt;"none"&lt;&lt;endl; return 0;&#125; T1172 : 求10000以内n的阶乘 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】求$10000$以内$n$的阶乘。 【输入】只有一行输入，整数$n(0 \leq n \leq 10000)$。 【输出】一行，即$n!$的值。 【输入样例】14 【输出样例】124 【答案&amp;代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt; using namespace std; int c[10005]=&#123;0&#125;; void factoriala(int a[],int b)&#123; for(int i=1;i&lt;=a[0];i++)&#123; a[i]=a[i]*b; &#125; for(int i=1;i&lt;=a[0];i++)&#123; a[i+1]=a[i+1]+a[i]/10000; a[i]=a[i]%10000; &#125; while(a[a[0]+1]&gt;0)&#123; a[0]++; a[a[0]+1]=a[a[0]]/10000; a[a[0]]=a[a[0]]%10000; &#125;&#125; void printa(int a[])&#123; for(int i=1;i&lt;=a[0];i++)&#123; if(i==1) cout&lt;&lt;a[a[0]+1-i]; else cout &lt;&lt;setw(4)&lt;&lt;setfill('0')&lt;&lt;a[a[0]+1-i]; &#125;&#125; int main()&#123; int n; cin&gt;&gt;n; c[0]=1; c[1]=1; if(n==0) ; else for(int i=1;i&lt;=n;i++)&#123; factoriala(c,i); &#125; printa(c); return 0;&#125; T1173 : 阶乘和 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】用高精度计算出$S=1!+2!+3!+…+n!(n \leq 50)$,其中$!$表示阶乘，例如：$5!=5 \times 4 \times 3 \times 2 \times 1$。 输入正整数$n$，输出计算结果$S$。 【输入】一个正整数$n$。 【输出】计算结果$S$。 【输入样例】15 【输出样例】1153 【答案&amp;代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; using namespace std; const int maxn=1000;struct bign&#123; int d[maxn],len; void clean(void)&#123; while(len &gt; 1 &amp;&amp; !d[len-1]) len--;&#125; bign(void)&#123; memset(d, 0, sizeof(d)); len = 1; &#125; bign(int num) &#123; *this = num; &#125; bign(char* num) &#123; *this = num; &#125; bign operator = (const char* num)&#123; memset(d, 0, sizeof(d)); len = strlen(num); for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - '0'; clean(); return *this; &#125; bign operator = (int num)&#123; char s[20]; sprintf(s, "%d", num); *this = s; return *this; &#125; bign operator + (const bign&amp; b)&#123; bign c = *this; int i; for (i = 0; i &lt; b.len; i++)&#123; c.d[i] += b.d[i]; if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++; &#125; while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++; c.len = max(len, b.len); if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1; return c; &#125; bign operator - (const bign&amp; b)&#123; bign c = *this; int i; for (i = 0; i &lt; b.len; i++)&#123; c.d[i] -= b.d[i]; if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--; &#125; while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--; c.clean(); return c; &#125; bign operator * (const bign&amp; b)const&#123; int i, j; bign c; c.len = len + b.len; for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++) c.d[i+j] += d[i] * b.d[j]; for(i = 0; i &lt; c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10; c.clean(); return c; &#125; bign operator / (const bign&amp; b)&#123; int i, j; bign c = *this, a = 0; for (i = len - 1; i &gt;= 0; i--) &#123; a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; c.d[i] = j; a = a - b*j; &#125; c.clean(); return c; &#125; bign operator % (const bign&amp; b)&#123; int i, j; bign a = 0; for (i = len - 1; i &gt;= 0; i--) &#123; a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; a = a - b*j; &#125; return a; &#125; bign operator += (const bign&amp; b)&#123; *this = *this + b; return *this; &#125; bign operator *= (const bign&amp; b)&#123; *this = *this * b; return *this; &#125; bool operator &lt;(const bign&amp; b)&#123; if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) if(d[i] != b.d[i]) return d[i] &lt; b.d[i]; return false; &#125; /*bool operator &gt;(const bign&amp; b)&#123;return b &lt; *this;&#125; bool operator&lt;=(const bign&amp; b)&#123;return !(b &lt; *this);&#125; bool operator&gt;=(const bign&amp; b)&#123;return !(*this &lt; b);&#125; bool operator!=(const bign&amp; b)&#123;return b &lt; *this || *this &lt; b;&#125; bool operator==(const bign&amp; b)&#123;return !(b &lt; *this) &amp;&amp; !(b &gt; *this);&#125; */ void Print()&#123; char s[maxn]=&#123;0&#125;; for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+'0'; printf("%s",s); return; &#125; &#125;;int main(void)&#123; int n; scanf("%d",&amp;n); bign sum=0,temp=1; for(int i=1;i&lt;=n;i++) temp*=i,sum+=temp; sum.Print(); return 0;&#125; T1174 : 大整数乘法 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】求两个不超过$200$位的非负整数的积。 【输入】有两行，每行是一个不超过$200$位的非负整数，没有多余的前导$0$。 【输出】一行，即相乘后的结果。结果里不能有多余的前导$0$，即如果结果是$342$，那么就不能输出为$0342$。 【输入样例】121234567890098765432100 【输出样例】11219326311126352690000 【答案&amp;代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;iostream&gt;#include&lt;string&gt;using std::string;using std::cin;using std::cout;using std::istream;using std::ostream;using std::endl;using std::max;#define MAX_LENGTH 2005struct BIG_NUMBER&#123; int len,s[MAX_LENGTH]; bool sign; BIG_NUMBER(void); BIG_NUMBER(const char*); BIG_NUMBER(int); ~BIG_NUMBER(void); void clean(void); string toStr(void)const; friend istream&amp; operator&gt;&gt;(istream&amp;,BIG_NUMBER&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;,BIG_NUMBER&amp;); BIG_NUMBER operator=(const char*); BIG_NUMBER operator=(int); BIG_NUMBER operator=(const string); bool operator&gt;(const BIG_NUMBER&amp;)const; bool operator&gt;=(const BIG_NUMBER&amp;)const; bool operator&lt;(const BIG_NUMBER&amp;)const; bool operator&lt;=(const BIG_NUMBER&amp;)const; bool operator==(const BIG_NUMBER&amp;)const; bool operator!=(const BIG_NUMBER&amp;)const; BIG_NUMBER operator+(const BIG_NUMBER&amp;)const; BIG_NUMBER operator++(void); BIG_NUMBER operator++(int); BIG_NUMBER operator+=(const BIG_NUMBER&amp;); BIG_NUMBER operator-(const BIG_NUMBER &amp;) const; BIG_NUMBER operator--(void); BIG_NUMBER operator--(int); BIG_NUMBER operator-=(const BIG_NUMBER&amp;); BIG_NUMBER operator*(const BIG_NUMBER &amp;)const; BIG_NUMBER operator*(const int num)const; BIG_NUMBER operator*=(const BIG_NUMBER&amp;); BIG_NUMBER operator/(const BIG_NUMBER&amp;)const; BIG_NUMBER operator/=(const BIG_NUMBER&amp;); BIG_NUMBER operator%(const BIG_NUMBER&amp;)const; BIG_NUMBER factorial(void)const; BIG_NUMBER sqrt(void)const; BIG_NUMBER pow(const BIG_NUMBER&amp;)const;&#125;;BIG_NUMBER::BIG_NUMBER(void)&#123; memset(s, 0, sizeof(s)); len = 1; sign = 1;&#125;BIG_NUMBER::BIG_NUMBER(const char*num)&#123; *this = num;&#125;BIG_NUMBER::BIG_NUMBER(int num)&#123; *this = num;&#125;string BIG_NUMBER::toStr(void)const&#123; string res; res = ""; for (int i = 0; i &lt; len; i++) res = (char)(s[i] + '0') + res; if (res == "") res = "0"; if (!sign&amp;&amp;res != "0") res = "-" + res; return res;&#125;istream &amp;operator&gt;&gt;(istream &amp;in,BIG_NUMBER&amp;num)&#123; string str; in&gt;&gt;str; num=str; return in;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;out,BIG_NUMBER&amp;num)&#123; out&lt;&lt;num.toStr(); return out;&#125;BIG_NUMBER BIG_NUMBER::operator=(const char*num)&#123; memset(s, 0, sizeof(s)); char a[MAX_LENGTH] = ""; if (num[0] != '-') strcpy(a, num); else for (int i = 1; i &lt; strlen(num); i++) a[i - 1] = num[i]; sign = !(num[0] == '-'); len = strlen(a); for (int i = 0; i &lt; strlen(a); i++) s[i] = a[len - i - 1] - 48; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator=(int num)&#123; char temp[MAX_LENGTH]; sprintf(temp, "%d", num); *this = temp; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator=(const string num)&#123; const char *tmp; tmp = num.c_str(); *this = tmp; return *this;&#125;bool BIG_NUMBER::operator&lt;(const BIG_NUMBER&amp;num)const&#123; if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; i--) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (!(s[i] &lt; num.s[i])); return !sign;&#125;bool BIG_NUMBER::operator&gt;(const BIG_NUMBER&amp;num)const&#123; return num &lt; *this;&#125;bool BIG_NUMBER::operator&lt;=(const BIG_NUMBER&amp;num)const&#123; return !(*this&gt;num);&#125;bool BIG_NUMBER::operator&gt;=(const BIG_NUMBER&amp;num)const&#123; return !(*this&lt;num);&#125;bool BIG_NUMBER::operator!=(const BIG_NUMBER&amp;num)const&#123; return *this &gt; num || *this &lt; num;&#125;bool BIG_NUMBER::operator==(const BIG_NUMBER&amp;num)const&#123; return !(num != *this);&#125;BIG_NUMBER BIG_NUMBER::operator+(const BIG_NUMBER &amp;num)const&#123; if (sign^num.sign) &#123; BIG_NUMBER tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; &#125; BIG_NUMBER result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) &#123; int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; &#125; result.sign = sign; return result;&#125;BIG_NUMBER BIG_NUMBER::operator++(void)&#123; *this = *this + 1; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator++(int)&#123; BIG_NUMBER old = *this; ++(*this); return old;&#125;BIG_NUMBER BIG_NUMBER::operator+=(const BIG_NUMBER &amp;num)&#123; *this = *this + num; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator-(const BIG_NUMBER &amp;num) const&#123; BIG_NUMBER b=num,a=*this; if (!num.sign &amp;&amp; !sign) &#123; b.sign=1; a.sign=1; return b-a; &#125; if (!b.sign) &#123; b.sign=1; return a+b; &#125; if (!a.sign) &#123; a.sign=1; b=BIG_NUMBER(0)-(a+b); return b; &#125; if (a&lt;b) &#123; BIG_NUMBER c=(b-a); c.sign=false; return c; &#125; BIG_NUMBER result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) &#123; int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else &#123; g = 1; x += 10; &#125; result.s[result.len++] = x; &#125; result.clean(); return result;&#125;BIG_NUMBER BIG_NUMBER::operator*(const BIG_NUMBER &amp;num)const&#123; BIG_NUMBER result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) &#123; result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; &#125; result.clean(); result.sign = !(sign^num.sign); return result;&#125;BIG_NUMBER BIG_NUMBER::operator*(const int num)const&#123; BIG_NUMBER x = num; BIG_NUMBER z = *this; return x*z;&#125;BIG_NUMBER BIG_NUMBER::operator*=(const BIG_NUMBER&amp;num)&#123; *this = *this * num; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator/(const BIG_NUMBER&amp;num)const&#123; BIG_NUMBER ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) &#123; ans.len = 1; return ans; &#125; BIG_NUMBER divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) &#123; while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_LENGTH]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + '0'; BIG_NUMBER dividend = z; if (dividend &lt; divid) &#123; k--; continue; &#125; int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; BIG_NUMBER temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; &#125; ans.clean(); ans.sign = !(sign^num.sign); return ans;&#125;BIG_NUMBER BIG_NUMBER::operator/=(const BIG_NUMBER&amp;num)&#123; *this = *this / num; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator%(const BIG_NUMBER&amp; num)const&#123; BIG_NUMBER a = *this, b = num; a.sign = b.sign = 1; BIG_NUMBER result, temp = a / b*b; result = a - temp; result.sign = sign; return result;&#125;BIG_NUMBER BIG_NUMBER::pow(const BIG_NUMBER&amp; num)const&#123; BIG_NUMBER result = 1; for (BIG_NUMBER i = 0; i &lt; num; i++) result = result*(*this); return result;&#125;BIG_NUMBER BIG_NUMBER::factorial(void)const&#123; BIG_NUMBER result = 1; for (BIG_NUMBER i = 1; i &lt;= *this; i++) result *= i; return result;&#125;void BIG_NUMBER::clean(void)&#123; if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == '\0') len--;&#125;BIG_NUMBER BIG_NUMBER::sqrt(void)const&#123; if(*this&lt;0)return -1; if(*this&lt;=1)return *this; BIG_NUMBER l=0,r=*this,mid; while(r-l&gt;1) &#123; mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; &#125; return l;&#125;BIG_NUMBER::~BIG_NUMBER(void)&#123;&#125;int main(void)&#123; BIG_NUMBER m,n,res; cin&gt;&gt;m&gt;&gt;n; res=m*n; cout&lt;&lt;res; return 0;&#125; T1175 : 除以13 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$ 【题目描述】输入一个大于$0$的大整数$N$，长度不超过$100$位，要求输出其除以$13$得到的商和余数。 【输入】一个大于$0$的大整数，长度不超过$100$位。 【输出】两行，分别为整数除法得到的商和余数。 【输入样例】12132104848488485 【输出样例】121640080652683450 【答案&amp;代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;iostream&gt;#include&lt;string&gt;using std::string;using std::cin;using std::cout;using std::istream;using std::ostream;using std::endl;using std::max;#define MAX_LENGTH 2005struct BIG_NUMBER&#123; int len,s[MAX_LENGTH]; bool sign; BIG_NUMBER(void); BIG_NUMBER(const char*); BIG_NUMBER(int); ~BIG_NUMBER(void); void clean(void); string toStr(void)const; friend istream&amp; operator&gt;&gt;(istream&amp;,BIG_NUMBER&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;,BIG_NUMBER&amp;); BIG_NUMBER operator=(const char*); BIG_NUMBER operator=(int); BIG_NUMBER operator=(const string); bool operator&gt;(const BIG_NUMBER&amp;)const; bool operator&gt;=(const BIG_NUMBER&amp;)const; bool operator&lt;(const BIG_NUMBER&amp;)const; bool operator&lt;=(const BIG_NUMBER&amp;)const; bool operator==(const BIG_NUMBER&amp;)const; bool operator!=(const BIG_NUMBER&amp;)const; BIG_NUMBER operator+(const BIG_NUMBER&amp;)const; BIG_NUMBER operator++(void); BIG_NUMBER operator++(int); BIG_NUMBER operator+=(const BIG_NUMBER&amp;); BIG_NUMBER operator-(const BIG_NUMBER &amp;) const; BIG_NUMBER operator--(void); BIG_NUMBER operator--(int); BIG_NUMBER operator-=(const BIG_NUMBER&amp;); BIG_NUMBER operator*(const BIG_NUMBER &amp;)const; BIG_NUMBER operator*(const int num)const; BIG_NUMBER operator*=(const BIG_NUMBER&amp;); BIG_NUMBER operator/(const BIG_NUMBER&amp;)const; BIG_NUMBER operator/=(const BIG_NUMBER&amp;); BIG_NUMBER operator%(const BIG_NUMBER&amp;)const; BIG_NUMBER factorial(void)const; BIG_NUMBER sqrt(void)const; BIG_NUMBER pow(const BIG_NUMBER&amp;)const;&#125;;BIG_NUMBER::BIG_NUMBER(void)&#123; memset(s, 0, sizeof(s)); len = 1; sign = 1;&#125;BIG_NUMBER::BIG_NUMBER(const char*num)&#123; *this = num;&#125;BIG_NUMBER::BIG_NUMBER(int num)&#123; *this = num;&#125;string BIG_NUMBER::toStr(void)const&#123; string res; res = ""; for (int i = 0; i &lt; len; i++) res = (char)(s[i] + '0') + res; if (res == "") res = "0"; if (!sign&amp;&amp;res != "0") res = "-" + res; return res;&#125;istream &amp;operator&gt;&gt;(istream &amp;in,BIG_NUMBER&amp;num)&#123; string str; in&gt;&gt;str; num=str; return in;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;out,BIG_NUMBER&amp;num)&#123; out&lt;&lt;num.toStr(); return out;&#125;BIG_NUMBER BIG_NUMBER::operator=(const char*num)&#123; memset(s, 0, sizeof(s)); char a[MAX_LENGTH] = ""; if (num[0] != '-') strcpy(a, num); else for (int i = 1; i &lt; strlen(num); i++) a[i - 1] = num[i]; sign = !(num[0] == '-'); len = strlen(a); for (int i = 0; i &lt; strlen(a); i++) s[i] = a[len - i - 1] - 48; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator=(int num)&#123; char temp[MAX_LENGTH]; sprintf(temp, "%d", num); *this = temp; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator=(const string num)&#123; const char *tmp; tmp = num.c_str(); *this = tmp; return *this;&#125;bool BIG_NUMBER::operator&lt;(const BIG_NUMBER&amp;num)const&#123; if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; i--) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (!(s[i] &lt; num.s[i])); return !sign;&#125;bool BIG_NUMBER::operator&gt;(const BIG_NUMBER&amp;num)const&#123; return num &lt; *this;&#125;bool BIG_NUMBER::operator&lt;=(const BIG_NUMBER&amp;num)const&#123; return !(*this&gt;num);&#125;bool BIG_NUMBER::operator&gt;=(const BIG_NUMBER&amp;num)const&#123; return !(*this&lt;num);&#125;bool BIG_NUMBER::operator!=(const BIG_NUMBER&amp;num)const&#123; return *this &gt; num || *this &lt; num;&#125;bool BIG_NUMBER::operator==(const BIG_NUMBER&amp;num)const&#123; return !(num != *this);&#125;BIG_NUMBER BIG_NUMBER::operator+(const BIG_NUMBER &amp;num)const&#123; if (sign^num.sign) &#123; BIG_NUMBER tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; &#125; BIG_NUMBER result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) &#123; int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; &#125; result.sign = sign; return result;&#125;BIG_NUMBER BIG_NUMBER::operator++(void)&#123; *this = *this + 1; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator++(int)&#123; BIG_NUMBER old = *this; ++(*this); return old;&#125;BIG_NUMBER BIG_NUMBER::operator+=(const BIG_NUMBER &amp;num)&#123; *this = *this + num; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator-(const BIG_NUMBER &amp;num) const&#123; BIG_NUMBER b=num,a=*this; if (!num.sign &amp;&amp; !sign) &#123; b.sign=1; a.sign=1; return b-a; &#125; if (!b.sign) &#123; b.sign=1; return a+b; &#125; if (!a.sign) &#123; a.sign=1; b=BIG_NUMBER(0)-(a+b); return b; &#125; if (a&lt;b) &#123; BIG_NUMBER c=(b-a); c.sign=false; return c; &#125; BIG_NUMBER result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) &#123; int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else &#123; g = 1; x += 10; &#125; result.s[result.len++] = x; &#125; result.clean(); return result;&#125;BIG_NUMBER BIG_NUMBER::operator*(const BIG_NUMBER &amp;num)const&#123; BIG_NUMBER result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) &#123; result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; &#125; result.clean(); result.sign = !(sign^num.sign); return result;&#125;BIG_NUMBER BIG_NUMBER::operator*(const int num)const&#123; BIG_NUMBER x = num; BIG_NUMBER z = *this; return x*z;&#125;BIG_NUMBER BIG_NUMBER::operator*=(const BIG_NUMBER&amp;num)&#123; *this = *this * num; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator/(const BIG_NUMBER&amp;num)const&#123; BIG_NUMBER ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) &#123; ans.len = 1; return ans; &#125; BIG_NUMBER divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) &#123; while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_LENGTH]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + '0'; BIG_NUMBER dividend = z; if (dividend &lt; divid) &#123; k--; continue; &#125; int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; BIG_NUMBER temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; &#125; ans.clean(); ans.sign = !(sign^num.sign); return ans;&#125;BIG_NUMBER BIG_NUMBER::operator/=(const BIG_NUMBER&amp;num)&#123; *this = *this / num; return *this;&#125;BIG_NUMBER BIG_NUMBER::operator%(const BIG_NUMBER&amp; num)const&#123; BIG_NUMBER a = *this, b = num; a.sign = b.sign = 1; BIG_NUMBER result, temp = a / b*b; result = a - temp; result.sign = sign; return result;&#125;BIG_NUMBER BIG_NUMBER::pow(const BIG_NUMBER&amp; num)const&#123; BIG_NUMBER result = 1; for (BIG_NUMBER i = 0; i &lt; num; i++) result = result*(*this); return result;&#125;BIG_NUMBER BIG_NUMBER::factorial(void)const&#123; BIG_NUMBER result = 1; for (BIG_NUMBER i = 1; i &lt;= *this; i++) result *= i; return result;&#125;void BIG_NUMBER::clean(void)&#123; if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == '\0') len--;&#125;BIG_NUMBER BIG_NUMBER::sqrt(void)const&#123; if(*this&lt;0)return -1; if(*this&lt;=1)return *this; BIG_NUMBER l=0,r=*this,mid; while(r-l&gt;1) &#123; mid=(l+r)/2; if(mid*mid&gt;*this) r=mid; else l=mid; &#125; return l;&#125;BIG_NUMBER::~BIG_NUMBER(void)&#123;&#125;int main(void)&#123; BIG_NUMBER m,r1,r2; cin&gt;&gt;m; r1=m/13,r2=m%13; cout&lt;&lt;r1&lt;&lt;'\n'&lt;&lt;r2; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>信息学奥赛一本通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息学奥赛一本通（C++版）第一部分 C++语言 第六章 函数]]></title>
    <url>%2FSolution%2FYBT%2F1.6%2F</url>
    <content type="text"><![CDATA[信息学奥赛一本通（C++版）第一部分 C++语言 第六章 函数 第一节 函数T1150 : 求正整数2和n之间的完全数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】求正整数$2$和$n$之间的完全数（一行一个数）。 完全数的定义： 如果$$\sum^{n-1}_{i=1}i(i|n)=n$$ 那么$n$是一个完全数。 【输入】输入$n$。 【输出】一行一个数，按由小到大的顺序。 【输入样例】17 【输出样例】16 【答案&amp;代码】12345678910111213141516171819202122#include&lt;cstdio&gt;int n;int fun(int);int main(void)&#123; register int i; scanf("%d",&amp;n); for(i=2;i&lt;=n;++i) if(i==fun(i)) printf("%d\n",i); return 0;&#125;int fun(int num)&#123; register int i,sum=0; for(i=1;i&lt;num;++i) if(num%i==0) sum+=i; return sum;&#125; T1151 : 素数个数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】编程求$[2,n](n≥2)$中有多少个素数。 【输入】输入$n(2 \leq n \leq 50000)$。 【输出】素数个数。 【输入样例】110 【输出样例】14 【答案&amp;代码】123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;cmath&gt;int n;bool isPrime(int);int main(void)&#123; register int i,sum=0; scanf("%d",&amp;n); for(i=2;i&lt;=n;++i) if(isPrime(i)) ++sum; printf("%d\n",sum); return 0;&#125;bool isPrime(int num)&#123; register int i; for(i=2;i*i&lt;=num;++i) if(num%i==0) return false; return true;&#125; T1152 : 最大数max(x,y,z) 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】已知： $$m=\frac{max(a,b,c)}{max(a+b,b,c)max(a,b,b+c)}$$ 输入$a,b,c$，求$m$。把求三个数的最大数$max(x,y,z)$分别定义成函数和过程来做。 【输入】输入$a,b,c$。 【输出】求$m$，保留到小数点后三位。 【输入样例】11 2 3 【输出样例】10.200 【答案&amp;代码】123456789101112131415161718192021#include&lt;cstdio&gt;double a,b,c,m;double max(double,double,double);int main(void)&#123; scanf("%lf%lf%lf",&amp;a,&amp;b,&amp;c); m=max(a,b,c)/(max(a+b,b,c)*max(a,b,b+c)); printf("%.3f\n",m); return 0;&#125;double max(double a,double b,double c)&#123; double result=a; if(b&gt;result) result=b; if(c&gt;result) result=c; return result;&#125; T1153 : 绝对素数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】如果一个自然数是素数，且它的数字位置经过对换后仍为素数，则称为绝对素数。试求出所有二位绝对素数。 【输入】（无） 【输出】所有二位绝对素数（由小到大，一个数一行）。 【输入样例】1（无） 【输出样例】1（无） 【答案&amp;代码】12345678910111213141516171819#include&lt;cstdio&gt;bool isPrime(int);int main(void)&#123; register int i; for(i=10;i&lt;=99;++i) if(isPrime(i)&amp;&amp;isPrime(i/10+(i%10)*10)) printf("%d\n",i); return 0;&#125;bool isPrime(int num)&#123; register int i; for(i=2;i*i&lt;=num;++i) if(num%i==0) return false; return true;&#125; T1154 : 亲和数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】自然数$a$的因子是指能整除$a$的所有自然数，但不含$a$本身。若自然数$a$的因子之和为b，而且$b$的因子之和又等于$a$，则称$a,b$为一对亲和数 。求最小的一对亲和数（$a≠b$）。 【输入】（无） 【输出】$1$行，分别为$a$和$b(a &lt; b)$。 【输入样例】1（无） 【输出样例】1（无） 【答案&amp;代码】12345#include&lt;stdio.h&gt;int main(void)&#123; puts("220 284"); return 0;&#125; T1155 : 回文三位数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】如果一个数从左边读和从右边读都是同一个数，就称为回文数。求出所有的既是回文数又是素数的三位数。 【输入】（无） 【输出】所有的既是回文数又是素数的三位数。一个数一行。 【输入样例】1（无） 【输出样例】1（无） 【答案&amp;代码】123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;bool isPrime(int num)&#123; for(int i=2;i&lt;=sqrt(num);i++) if(num%i==0) return false; return true;&#125;bool huiwen(int num)&#123; char str[5]; sprintf(str,"%d",num); for(int i=0,j=strlen(str)-1;i&lt;=j;i++,j--)&#123; char temp=str[i]; str[i]=str[j]; str[j]=temp; &#125; int newnum; sscanf(str,"%d",&amp;newnum); return num==newnum;&#125;int main(void)&#123; for(int i=100;i&lt;=999;i++) if(isPrime(i)&amp;&amp;huiwen(i)) printf("%d\n",i); return 0;&#125; T1156 : 求π的值 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】根据公式： $$arctanx(x)=\sum^{\infty}_{i=1}(-1)^{i-1}\frac{x^{2i-1}}{2i-1}$$ 和 $$π=6arctanx(\frac{\sqrt{3}}{3})$$ 定义函数$arctanx(x)$，求当最后一项小于$10^{-6}$时$π$的值。 【输入】（无） 【输出】$π$的值。保留到小数点后$10$位。 【输入样例】1（无） 【输出样例】1（无） 【答案&amp;代码】123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;double calculate(double x);int main(void)&#123; double a,pi; a=1/sqrt(3); pi=6*(calculate(a)); printf("%.10lf\n",pi); return 0;&#125;double calculate(double x)&#123; double sum=0,temp=x; int i=1; while(fabs(temp/i)&gt;=1e-6)&#123; sum+=temp/i; temp=-1*x*x*temp; i+=2; &#125; return sum;&#125; T1157 : 哥德巴赫猜想 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】哥德巴赫猜想的命题之一是：大于等于$6$的偶数等于两个素数之和。编程将$6-100$所有偶数表示成两个素数之和。 【输入】（无） 【输出】分行输出，每个数只拆开一次，请保证第一个加数最小。 【输入样例】1（无） 【输出样例】1（无） 【答案&amp;代码】1234567891011121314151617181920#include&lt;stdio.h&gt;bool Prime(int i) &#123; int j; if (i &lt;= 1) return 0; if (i == 2) return 1; for (j = 2; j &lt; i; j++) &#123; if (i%j == 0)return 0; else if (i != j + 1) continue; else return 1; &#125;&#125;int main(void)&#123; for(int i=6;i&lt;=100;i+=2) for(int j=2;j&lt;=i/2;j++) if(Prime(j)&amp;&amp;Prime(i-j))&#123; printf("%d=%d+%d\n",i,j,i-j); break; &#125; return 0;&#125; T1397 : 简单算术表达式求值 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】两位正整数的简单算术运算（只考虑整数运算），算术运算为： $+$，加法运算； $-$，减法运算； $*$，乘法运算； $/$，整除运算； $\%$，取余运算。 算术表达式的格式为（运算符前后可能有空格）： 运算数 运算符 运算数 请输出相应的结果。 【输入】一行算术表达式。 【输出】整型算数运算的结果（结果值不一定为$2$位数，可能多于$2$位或少于$2$位）。 【输入样例】132+64 【输出样例】196 【答案&amp;代码】12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; int n,i; char str[256]; int f=0,l=0; gets(str); for(int i=0;i&lt;strlen(str);i++) if(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9') if(str[i+1]&gt;='0'&amp;&amp;str[i+1]&lt;='9') f=(f+str[i]-'0')*10; else&#123; f+=str[i]-'0'; break; &#125; for(int i=strlen(str)-1;i&gt;0;i--) if(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9') if(str[i-1]&gt;='0'&amp;&amp;str[i-1]&lt;='9') l+=str[i]-'0'; else&#123; l+=(str[i]-'0')*10; break; &#125; for(int i=0;i&lt;strlen(str)-1;i++)&#123; if(str[i]=='+') printf("%d",f+l); else if(str[i]=='-') printf("%d",f-l); else if(str[i]=='*') printf("%d",f*l); else if(str[i]=='/') printf("%d",f/l); else if(str[i]=='%') printf("%d",f%l); &#125; return 0;&#125; T1398 : 短信计费 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】用手机发短信，一条短信资费为$0.1$元，但限定一条短信的内容在$70$个字以内（包括$70$个字）。如果你一次所发送的短信超过了$70$个字，则会按照每$70$个字一条短信的限制把它分割成多条短信发送。假设已经知道你当月所发送的短信的字数，试统计一下你当月短信的总资费。 【输入】第一行是整数$n$，表示当月发送短信的总次数，接着$n$行每行一个整数，表示每次短信的字数。 【输出】输出一行，当月短信总资费，单位为元，精确到小数点后$1$位。 【输入样例】123456789101110394942614414742723546 【输出样例】11.3 【答案&amp;代码】1234567891011121314#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); int sum=0; for(int i=0;i&lt;n;i++)&#123; int temp; scanf("%d",&amp;temp); sum+=(int)ceil((double)temp/70); &#125; printf("%.1f",sum*0.1); return 0;&#125; T1399 : 甲流病人初筛 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】目前正是甲流盛行时期，为了更好地进行分流治疗，医院在挂号时要求对病人的体温和咳嗽情况进行检查，对于体温超过$37.5$度（含等于$37.5$度）并且咳嗽的病人初步判定为甲流病人（初筛）。现需要统计某天前来挂号就诊的病人中有多少人被初筛为甲流病人。 【输入】第一行是某天前来挂号就诊的病人数$n(n&lt;200)$。 其后有$n$行，每行是病人的信息，包括三个信息：姓名（字符串，不含空格，最多$8$个字符）、体温（float）、是否咳嗽（整数，$1$表示咳嗽，$0$表示不咳嗽）。每行三个信息之间以一个空格分开。 【输出】按输入顺序依次输出所有被筛选为甲流的病人的姓名，每个名字占一行。之后在输出一行，表示被筛选为甲流的病人数量。 【输入样例】1234565Zhang 38.3 0Li 37.5 1Wang 37.1 1Zhao 39.0 1Liu 38.2 1 【输出样例】1234LiZhaoLiu3 【答案&amp;代码】12345678910111213141516#include&lt;stdio.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); int sum=0; for(int i=0;i&lt;n;i++)&#123; char name[9]; double t; int ks; scanf("%s%lf%d",name,&amp;t,&amp;ks); if(ks&amp;&amp;t&gt;=37.5) printf("%s\n",name),sum+=1; &#125; printf("%d",sum); return 0;&#125; T1400 : 统计单词数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。 现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同。 【输入】第$1$行为一个字符串，其中只含字母，表示给定单词； 第$2$行为一个字符串，其中只可能包含字母和空格，表示给定的文章。 【输出】只有一行，如果在文章中找到给定单词则输出两个整数，两个整数之间用一个空格隔开，分别是单词在文章中出现的次数和第一次出现的位置（即在文章中第一次出现时，单词首字母在文章中的位置，位置从$0$开始）；如果单词在文章中没有出现，则直接输出一个整数$-1$。 【输入样例】12Toto be or not to be is a question 【输出样例】12 0 【答案&amp;代码】1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void)&#123; string a,b; getline(cin,a); getline(cin,b); for (int i=0;i&lt;a.length();++i)&#123; a[i]=tolower(a[i]); &#125; for (int i=0;i&lt;b.length();++i)&#123; b[i]=tolower(b[i]); &#125; a=' '+a+' '; b=' '+b+' '; if (b.find(a)==string::npos)&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125; else &#123; int alpha=b.find(a); int beta=b.find(a),s=0; while (beta!=string::npos)&#123; ++s; beta=b.find(a,beta+1); &#125; cout&lt;&lt;s&lt;&lt;" "&lt;&lt;alpha&lt;&lt;endl; &#125; return 0;&#125; T1401 : 机器翻译 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。 这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。 假设内存中有$M$个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过$M?1$，软件会将新单词存入一个未使用的内存单元；若内存中已存入$M$个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。 假设一篇英语文章的长度为$N$个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。 【输入】共$2$行。每行中两个数之间用一个空格隔开。 第一行为两个正整数$M$和$N$，代表内存容量和文章的长度。 第二行为$N$个非负整数，按照文章的顺序，每个数（大小不超过$1000$）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。 【输出】共$1$行，包含一个整数，为软件需要查词典的次数。 【输入样例】123 71 2 1 5 4 4 1 【输出样例】15 【答案&amp;代码】1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;int main(void)&#123; int m,n; scanf("%d%d",&amp;m,&amp;n); int mem[m]; for(int i=0;i&lt;m;i++) mem[i]=-1; int sum=0; for(int i=0,temp,p=0;i&lt;n;i++)&#123; scanf("%d",&amp;temp); bool flag1=true,flag2=true; int index=-1; for(int j=0;j&lt;m;j++) if(mem[j]==temp) flag1=false; else if(mem[j]==-1&amp;&amp;flag2) flag2=false,index=j; if(flag1) if(flag2) mem[p]=temp,sum+=1,p+=1,p%=m; else mem[index]=temp,sum+=1; &#125; printf("%d",sum); return 0;&#125; T1402 : Vigenère密码 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】$6$世纪法国外交家$Blaise de Vigenère$设计了一种多表密码加密算法——$Vigenère$密码。$Vigenère$密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。 在密码学中，我们称需要加密的信息为明文，用$M$表示；称加密后的信息为密文，用$C$表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为$k$。 在$Vigenère$密码中，密钥$k$是一个字母串，$k=k_{1}k_{2}…k_{n}$。当明文$M=m_{1}m_{2}…m_{n}$时，得到的密文$C=c_{1}c_{2}…c_{n}$，其中$ci=mi$$ki$，运算(R)的规则如下表所示： $Vigenère$加密在操作时需要注意： (R)运算忽略参与运算的字母的大小写，并保持字母在明文M中的大小写形式； 当明文$M$的长度大于密钥k的长度时，将密钥k重复使用。 【输入】第一行为一个字符串，表示密钥$k$，长度不超过$100$，其中仅包含大小写字母。第二行 为一个字符串，表示经加密后的密文，长度不超过$1000$，其中仅包含大小写字母。 对于$100\%$的数据，输入的密钥的长度不超过$100$，输入的密文的长度不超过$1000$，且都仅包含英文字母。 【输出】输出共$1$行，一个字符串，表示输入密钥和密文所对应的明文。 【输入样例】12CompleteVictoryYvqgpxaimmklongnzfwpvxmniytm 【输出样例】1Wherethereisawillthereisaway 【答案&amp;代码】1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;char k[2048],m[2048],res[2048];char fun(char m,char k)&#123; bool flag=('A'&lt;=m&amp;&amp;m&lt;='Z'); if(flag) m+=32; char res=m-k+'a'; if(res&lt;'a') res+=26; if(flag) return res-32; else return res;&#125;int main(void)&#123; scanf("%s",k); scanf("%s",m); for(int i=0,len=strlen(k);i&lt;len;i++) if('A'&lt;=k[i]&amp;&amp;k[i]&lt;='Z') k[i]+=32; char temp[2048]; strcpy(temp,k); for(int i=0,n=strlen(m)/strlen(k);i&lt;n;i++) strcat(k,temp); for(int i=0,len=strlen(m);i&lt;len;i++) putchar(fun(m[i],k[i])); return 0;&#125; T1403 : 素数对 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】两个相差为$2$的素数称为素数对，本题目要求找出所有两个数均不大于$n$的素数对。 【输入】一个正整数$n(1 \leq n \leq 10000)$。 【输出】所有小于等于$n$的素数对。每对素数对输出一行，中间用单个空格隔开。若没有找到任何素数对，输出empty。 【输入样例】1100 【输出样例】123456783 55 711 1317 1929 3141 4359 6171 73 【答案&amp;代码】1234567891011121314151617181920#include&lt;stdio.h&gt;bool isPrime(int x)&#123; if(x&lt;=1) return false; for(int i=2;i*i&lt;=x;i++) if(x%i==0) return false; return true;&#125;int main(void)&#123; int n; scanf("%d",&amp;n); bool flag=false; for(int i=5;i&lt;=n;i++) if(isPrime(i-2)&amp;&amp;isPrime(i)) flag=printf("%d %d\n",i-2,i)|1; if(!flag) printf("empty"); return 0;&#125; T1404 : 我家的门牌号 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】我家住在一条短胡同里，这条胡同的门牌号从$1$开始顺序编号。 若其余各家的门牌号之和减去我家门牌号的两倍，恰好等于$n$，求我家的门牌号及总共有多少家。数据保证有唯一解。 【输入】一个正整数$n(n&lt;100000)$。 【输出】一行，包含两个正整数，分别是我家的门牌号及总共有多少家，中间用单个空格隔开。 【输入样例】1100 【输出样例】112 16 【答案&amp;代码】1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n,home,x; int i; cin&gt;&gt;n; home=sqrt(6+2*n)-1; for(i=home;;i++) &#123; if((i*i+i-2*n)%6==0) &#123; x=(i*i+i-2*n)/6; if(x&lt;=0) continue; if(x&gt;0) &#123; cout&lt;&lt;x&lt;&lt;" "&lt;&lt;i; break; &#125; &#125; &#125; return 0;&#125; T1405 : 质数的和与积 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】两个质数的和是$S$，它们的积最大是多少？ 【输入】一个不大于$10000$的正整数$S$，为两个质数的和。 【输出】一个整数，为两个质数的最大乘积。数据保证有解。 【输入样例】150 【输出样例】1589 【答案&amp;代码】12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;bool isPrime(int num)&#123; for(int i=2;i&lt;=sqrt(num);i++) if(num%i==0) return false; return true;&#125;int main(void)&#123; int s; scanf("%d",&amp;s); int max=0; for(int i=2;i&lt;=s/2;i++) if(isPrime(i)&amp;&amp;isPrime(s-i)&amp;&amp;i*(s-i)&gt;max) max=i*(s-i); printf("%d",max); return 0;&#125; T1406 : 单词替换 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入一个字符串（$L \leq 200$），以回车结束。该字符串由若干个单词组成，单词之间用一个空格隔开，所有单词区分大小写。现需要将其中的某个单词替换成另一个单词，并输出替换之后的字符串。 【输入】第$1$行是包含多个单词的字符串$s$； 第$2$行是待替换的单词$a(L_{a} \leq 100)$； 第$3$行是$a$将被替换的单词$b(L_{b} \leq 100)$。 $s,a,b$最前面和最后面都没有空格。 【输出】输出只有$1$行，将$s$中所有单词$a$替换成$b$之后的字符串。 【输入样例】123You want someone to help youYouI 【输出样例】1I want someone to help you 【答案&amp;代码】12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;vector&gt;using std::vector;#include&lt;string&gt;using std::string;#include&lt;iostream&gt;using std::cin;using std::cout;vector&lt;string&gt; S;string str;int main(void)&#123; while(cin&gt;&gt;str) S.push_back(str); int size=S.size(); string s1=S[size-2],s2=S[size-1]; for(int i=0;i&lt;size-2;i++,putchar(' ')) if(S[i]==s1) cout&lt;&lt;s2; else cout&lt;&lt;S[i]; return 0;&#125; T1407 : 笨小猴 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！ 这种方法的具体描述如下：假设$max_{n}$是单词中出现次数最多的字母的出现次数，$min_{n}$是单词中出现次数最少的字母的出现次数，如果$max_{n}-min_{n}$是一个质数，那么笨小猴就认为这是个Lucky Word，这样的单词很可能就是正确的答案。 【输入】只有一行，是一个单词，其中只可能出现小写字母，并且长度小于$100$。 【输出】共两行，第一行是一个字符串，假设输入的的单词是Lucky Word，那么输出Lucky Word，否则输出No Answer； 第二行是一个整数，如果输入单词是Lucky Word，输出$max_{n}-min_{n}$的值，否则输出$0$。 【输入样例】1error 【输出样例】12Lucky Word2 【答案&amp;代码】12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;bool isprime(int num)&#123; for(int i=2;i&lt;=sqrt(num);i++) if(num%i==0) return false; return true;&#125;int main(void)&#123; char str[100]; scanf("%s",str); int word[26]=&#123;0&#125;; for(int i=0;i&lt;strlen(str);i++) word[str[i]-'a']+=1; int max=-1,min=101; for(int i=0;i&lt;26;i++)&#123; if(word[i]&lt;min&amp;&amp;word[i]!=0) min=word[i]; if(word[i]&gt;max) max=word[i]; &#125; if(isprime(max-min)&amp;&amp;(max-min)!=0&amp;&amp;(max-min)!=1) printf("Lucky Word\n%d",max-min); else printf("No Answer\n0"); return 0;&#125; T1408 : 素数回文数的个数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】求$11$到$n$之间（包括$n$），既是素数又是回文数的整数有多少个。 【输入】一个大于$11$小于$1000$的整数$n$。 【输出】$11$到$n$之间的素数回文数个数。 【输入样例】123 【输出样例】11 【答案&amp;代码】12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;bool isPrime(int num)&#123; for(int i=2;i&lt;=sqrt(num);i++) if(num%i==0) return false; return true;&#125;bool huiwen(int num)&#123; char str[5]; sprintf(str,"%d",num); for(int i=0,j=strlen(str)-1;i&lt;=j;i++,j--)&#123; char temp=str[i]; str[i]=str[j]; str[j]=temp; &#125; int newnum; sscanf(str,"%d",&amp;newnum); return num==newnum;&#125;int main(void)&#123; int n; scanf("%d",&amp;n); int sum=0; for(int i=11;i&lt;=n;i++) if(isPrime(i)&amp;&amp;huiwen(i)) sum+=1; printf("%d",sum); return 0;&#125; T1409 : 判决素数个数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入两个整数$X$和$Y$，输出两者之间的素数个数（包括$X$和$Y$）。 【输入】两个整数$X$和$Y(1 \leq X,Y \leq 10^{5})$。 【输出】输出一个整数，表示$X,Y$之间的素数个数（包括$X$和$Y$）。 【输入样例】11 100 【输出样例】125 【答案&amp;代码】123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;bool isprime(int num)&#123; if(num==0||num==1) return false; for(int i=2;i&lt;=sqrt(num);i++) if(num%i==0) return false; return true;&#125;int main(void)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); int sum=0; for(;x&lt;=y;x++) if(isprime(x)) sum+=1; printf("%d",sum); return 0;&#125; T1410 : 最大质因子序列 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】任意输入两个正整数$m,n(1 &lt; m &lt; n \leq 5000)$，依次输出$m$到$n$之间每个数的最大质因子（包括$m$和$n$，如果某个数本身是质数，则输出这个数自身）。 【输入】一行，包含两个正整数$m$和$n$，其间以单个空格间隔。 【输出】一行，每个整数的最大质因子，以逗号间隔。 【输入样例】15 10 【输出样例】15,3,7,2,3,5 【答案&amp;代码】1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;math.h&gt;int fun(int num)&#123; int temp=1; for(int i=2;i&lt;=num;i++) if(num%i==0)&#123; temp=i; num/=i; i=1; &#125; return temp==1?num:temp;&#125;int main(void)&#123; int m,n; scanf("%d%d",&amp;m,&amp;n); printf("%d",fun(m)); for(int i=m+1;i&lt;=n;i++) printf(",%d",fun(i)); return 0;&#125; T1411 : 区间内的真素数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】找出正整数$M$和$N$之间（$N$不小于$M$）的所有真素数。 真素数的定义：如果一个正整数$P$为素数，且其反序也为素数，那么$P$就为真素数。 【输入】输入两个数$M$和$N$，空格间隔，$1 \leq M \leq N \leq 100000$。 【输出】按从小到大输出$M$和$N$之间（包括$M$和$N$）的真素数，逗号间隔。如果之间没有真素数，则输出No。 【输入样例】110 35 【输出样例】111,13,17,31 【答案&amp;代码】123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;int numfz(int num)&#123; char str[8]; sprintf(str,"%d",num); for(int i=0,j=strlen(str)-1;i&lt;=j;i++,j--)&#123; char temp=str[i]; str[i]=str[j]; str[j]=temp; &#125; int newn; sscanf(str,"%d",&amp;newn); return newn;&#125;bool isprime(int num)&#123; if(num&lt;2) return false; for(int i=2;i&lt;=sqrt(num);i++) if(num%i==0) return false; return true;&#125;int main(void)&#123; int m,n; scanf("%d%d",&amp;m,&amp;n); int sum=0; bool flag=true; for(;m&lt;=n;m++) if(flag&amp;&amp;isprime(m)&amp;&amp;isprime(numfz(m)))&#123; flag=false; printf("%d",m); &#125; else if(isprime(m)&amp;&amp;isprime(numfz(m))) printf(",%d",m); if(flag) printf("No"); return 0;&#125; T1412 : 二进制分类 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】若将一个正整数化为二进制数，在此二进制数中，我们将数字$1$的个数多于数字$0$的个数的这类二进制数称为$A$类数，否则就称其为$B$类数。 程序要求：求出$1-1000$之中（包括$1$与$1000$），全部$A,B$两类数的个数。 【输入】（无） 【输出】一行，包含两个整数，分别是$A$类数和$B$类数的个数，中间用单个空格隔开。 【输入样例】1（无） 【输出样例】1（无） 【答案&amp;代码】1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;void change_to_2(int num,int result[16])&#123; for(int i=0;i&lt;16;i++) result[i]=0; result[0]=num; for(int i=0;i&lt;16;i++) if(result[i]&gt;=2) result[i+1]+=result[i]/2,result[i]%=2; return;&#125;bool A_or_B(int num[16])&#123; int sum0=0,sum1=0; int top=0; for(int i=15;i&gt;=0;i--) if(num[i]!=0)&#123; top=i; break; &#125; for(int i=top;i&gt;=0;i--)&#123; if(num[i]==0) sum0++; else sum1++; &#125; return sum1&gt;sum0;&#125;int main(void)&#123; int suma=0,sumb=0; for(int i=1,result[16]=&#123;0&#125;;i&lt;=1000;i++)&#123; change_to_2(i,result); if(A_or_B(result)) suma++; else sumb++; &#125; printf("%d %d",suma,sumb); return 0;&#125; T1413 : 确定进制 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】你的任务是写一段程序，读入三个整数$p,q,r$，然后确定一个进制$B(2 \leq B \leq 40)$使得$p×q=r$。如果$B$有很多选择，输出最小的一个。 【输入】一行，包含三个整数$p,q,r$。$p,q,r$的所有位都是数字，并且$1 \leq p,q,r \leq 1,000,000$。 【输出】一个整数：即使得$p×q=r$成立的最小的$B$。如果没有合适的$B$，则输出$0$。 【输入样例】16 9 42 【输出样例】113 【答案&amp;代码】1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int judge(int x,int B);int main()&#123; int a,b,c; int i; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(i=2;i&lt;=40;i++) if(judge(a,i)*judge(b,i)==judge(c,i)) &#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; cout&lt;&lt;0&lt;&lt;endl; return 0;&#125;int judge(int x,int B)&#123; int value=1,num=0; while(x)&#123; num+=((x%10)*value); value*=B; x/=10; &#125; return num;&#125; 第二节 递归算法T1158 : 求1+2+3+… 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】用递归的方法求$1+2+3+…+N$的值。 【输入】输入$N$。 【输出】输出和。 【输入样例】15 【输出样例】115 【答案&amp;代码】12345678910111213#include&lt;stdio.h&gt;int fun(int num)&#123; if(num==1) return 1; else return num+fun(num-1);&#125;int main(void)&#123; int n; scanf("%d",&amp;n); printf("%d",fun(n)); return 0;&#125; T1159 : 斐波那契数列 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】用递归函数输出斐波那契数列第$n-1$项。 【输入】一个正整数$n$。 【输出】第$n-1$项是多少。 【输入样例】13 【输出样例】11 【答案&amp;代码】123456789101112131415#include&lt;stdio.h&gt;int fun(int num)&#123; if(num==1) return 0; else if(num==2||num==3) return 1; else return fun(num-2)+fun(num-1);&#125;int main(void)&#123; int n; scanf("%d",&amp;n); printf("%d",fun(n)); return 0;&#125; T1160 : 倒序数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入一个非负整数，输出这个数的倒序数。 【输入】输入一个非负整数（保证个位不为零）。 【输出】输出倒序的数。 【输入样例】1123 【输出样例】1321 【答案&amp;代码】123456789#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char num[512]; scanf("%s",num); for(int i=strlen(num)-1;i&gt;=0;i--) printf("%c",num[i]); return 0;&#125; T1161 : 转进制 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】用递归算法将一个十进制数$X$转换成任意进制数$M(M \leq 16)$。 【输入】一行两个数，第一个十进制数$X$，第二个为进制$M$。 【输出】输出结果。 【输入样例】131 16 【输出样例】11F 【答案&amp;代码】1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;void change_to_n(int num,int result[32],int n)&#123; for(int i=0;i&lt;32;i++) result[i]=0; result[0]=num; for(int i=0;i&lt;32;i++) if(result[i]&gt;=n) result[i+1]+=result[i]/n,result[i]%=n; return; &#125; void Print(int num[32])&#123; int top=0; for(int i=31;i&gt;=0;i--) if(num[i]!=0)&#123; top=i; break; &#125; for(int i=top;i&gt;=0;i--) if(num[i]&lt;10) printf("%d",num[i]); else printf("%c",num[i]-10+'A'); return;&#125;int main(void)&#123; int x,m; scanf("%d%d",&amp;x,&amp;m); int num[32]=&#123;0&#125;; change_to_n(x,num,m); Print(num); return 0;&#125; T1162 : 字符串逆序 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入一串以!结束的字符，按逆序输出。 【输入】如题述。 【输出】如题述。 【输入样例】1abc! 【输出样例】1cba 【答案&amp;代码】1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; int m,n; char str[512]; char temp; int i=0; do&#123; scanf("%c",&amp;temp); str[i]=temp; i++; &#125;while(temp!='!'); str[i-1]='\0'; for(i=strlen(str)-1;i&gt;=0;i--) printf("%c",str[i]); return 0;&#125; T1163 : 阿克曼（Ackmann）函数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】Ackmann函数$A(m,n)(m \leq 3,n \leq 10)$中，函数值定义为： $$akm(m,n)=\begin{cases}n+1 (m=0)\\akm(m-1,1) (m&gt;0,n=0)\\akm(m-1,akm(m,n-1)) (m,n&gt;0)\end{cases}$$ 【输入】输入$m$和$n$。 【输出】函数值。 【输入样例】12 3 【输出样例】19 【答案&amp;代码】123456789101112131415#include&lt;stdio.h&gt;int A(int m,int n)&#123; if(m==0) return n+1; else if(m&gt;0&amp;&amp;n==0) return A(m-1,1); else return A(m-1,A(m,n-1));&#125;int main(void)&#123; int m,n; scanf("%d%d",&amp;m,&amp;n); printf("%d",A(m,n)); return 0;&#125; T1164 : digit函数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】在程序中定义一函数$digit(n,k)$，它能分离出整数$n$从右边数第$k$个数字。 【输入】正整数$n$和$k$。 【输出】一个数字。 【输入样例】131859 3 【输出样例】18 【答案&amp;代码】1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt;void digit(int n,int k)&#123; char str[16]; sprintf(str,"%d",n); if(k&gt;strlen(str)) printf("0"); else printf("%c",str[strlen(str)-k]); return;&#125;int main(void)&#123; int n,k; scanf("%d%d",&amp;n,&amp;k); digit(n,k); return 0;&#125; T1165 : Hermite多项式 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】用递归的方法求Hermite多项式的值 $$h_{n}(x)=\begin{cases}1 (n=0)\\2x (n=1)\\2xh_{n-1}(x)-2(n-1)h_{n-2}(x) (n&gt;1)\end{cases}$$ 对给定的$x$和正整数$n$，求多项式的值。 【输入】给定的$n$和正整数$x$。 【输出】多项式的值。 【输入样例】11 2 【输出样例】14.00 【答案&amp;代码】123456789101112131415#include&lt;stdio.h&gt;double h(double n,double x)&#123; if(n==0) return 1; else if(n==1) return 2*x; else return 2*x*h(n-1,x)-2*(n-1)*h(n-2,x);&#125;int main(void)&#123; double n,x; scanf("%lf%lf",&amp;n,&amp;x); printf("%.2f",h(n,x)); return 0;&#125; T1166 : 求f(x,n) 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】已知 $$f(x,n)=\sqrt{n+\sqrt{n-1+\sqrt{…+2+\sqrt{1+x}}}}$$ 【输入】输入$x$和$n$。 【输出】函数值，保留两位小数。 【输入样例】14.2 10 【输出样例】13.68 【答案&amp;代码】1234567891011121314151617181920212223#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; using namespace std; double calculate(double x,double n); int main() &#123; double n,x; double result; cin&gt;&gt;x&gt;&gt;n; result=calculate(x,n); printf("%.2lf\n",result); return 0; &#125; double calculate(double x,double n) &#123; if(n==1)//判断是否到达递归边界n=1 return sqrt(1+x); else//否则继续递归 return sqrt(n+calculate(x,n-1)); &#125; T1167 : 再求f(x,n) 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】已知 $$f(x,n)=\frac{x}{n+\frac{x}{n-1+\frac{x}{…+\frac{x}{1+x}}}}$$ 用递归函数求解。 【输入】第一数是$x$的值，第二个数是$n$的值。 【输出】函数值。 【输入样例】11 2 【输出样例】10.40 【答案&amp;代码】123456789101112#include&lt;stdio.h&gt;double f(double x,double n)&#123; if(n==1) return x/(n+x); return x/(n+f(x,n-1));&#125;int main(void)&#123; double x,n; scanf("%lf%lf",&amp;x,&amp;n); printf("%.2f",f(x,n)); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>信息学奥赛一本通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息学奥赛一本通（C++版）第一部分 C++语言 第五章 数组]]></title>
    <url>%2FSolution%2FYBT%2F1.5%2F</url>
    <content type="text"><![CDATA[信息学奥赛一本通（C++版）第一部分 C++语言 第五章 数组 第一节 一维数组T1102 : 与指定数字相同的数的个数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输出一个整数序列中与指定数字相同的数的个数。 【输入】输入包含三行： 第一行为$N(N \leq 100)$，表示整数序列的长度； 第二行为$N$个整数，整数之间以一个空格分开； 第三行包含一个整数，为指定的数字$m$。 【输出】输出为$N$个数中与$m$相同的数的个数。 【输入样例】12332 3 22 【输出样例】12 【答案&amp;代码】12345678910111213141516#include&lt;cstdio&gt;int n,num[101],m;int main(void)&#123; register int i,sum=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;++i) scanf("%d",&amp;num[i]); scanf("%d",&amp;m); for(i=1;i&lt;=n;++i) if(num[i]==m) ++sum; printf("%d\n",sum); return 0;&#125; T1103 : 陶陶摘苹果 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】陶陶家的院子里有一棵苹果树，每到秋天树上就会结出$10$个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个$30$厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。 现在已知$10$个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。 【输入】包括两行数据。第一行包含$10$个$100$到$200$之间（包括$100$和$200$）的整数（单位：厘米）分别表示$10$个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个$100$到$120$之间（包括$100$和$120$）的整数（单位：厘米），表示陶陶把手伸直的时候能够达到的最大高度。 【输出】包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。 【输入样例】12100 200 150 140 129 134 167 198 200 111110 【输出样例】15 【答案&amp;代码】123456789101112131415#include&lt;cstdio&gt;int n,tall[11];int main(void)&#123; register int i,sum=0; for(i=1;i&lt;=10;++i) scanf("%d",&amp;tall[i]); scanf("%d",&amp;n); for(i=1;i&lt;=10;++i) if(tall[i]&lt;=n+30) ++sum; printf("%d\n",sum); return 0;&#125; T1104 : 计算书费 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】下面是一个图书的单价表： 计算概论$28.9$元/本 数据结构与算法$32.7$元/本 数字逻辑$45.6$元/本 C++程序设计教程$78$元/本 人工智能$35$元/本 计算机体系结构$86.2$元/本 编译原理$27.8$元/本 操作系统$43$元/本 计算机网络$56$元/本 JAVA程序设计$65$元/本 给定每种图书购买的数量，编程计算应付的总费用。 【输入】输入一行，包含$10$个整数，分别表示购买的《计算概论》、《数据结构与算法》、《数字逻辑》、《C++程序设计教程》、《人工智能》、《计算机体系结构》、《编译原理》、《操作系统》、《计算机网络》、《JAVA程序设计》的数量（以本为单位）。每两个整数用一个空格分开。 【输出】输出一行，包含一个浮点数$f$，表示应付的总费用。精确到小数点后一位。 【输入样例】11 5 8 10 5 1 1 2 3 4 【输出样例】12140.2 【答案&amp;代码】123456789101112#include&lt;cstdio&gt;int b[10];int main(void)&#123; register int i; for(i=0;i&lt;10;++i) scanf("%d",&amp;b[i]); float s=(b[0]*28.9)+(b[1]*32.7)+(b[2]*45.6)+(b[3]*78)+(b[4]*35)+(b[5]*86.2)+(b[6]*27.8)+(b[7]*43)+(b[8]*56)+(b[9]*65); printf("%.1f\n",s); return 0;&#125; T1105 : 数组逆序重存放 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】将一个数组中的值按逆序重新存放。例如，原来的顺序为$8,6,5,4,1$。要求改为$1,4,5,6,8$。 【输入】输入为两行：第一行数组中元素的个数$n(1 &lt; n &lt; 100)$，第二行是$n$个整数，每两个整数之间用空格分隔。 【输出】输出为一行：输出逆序后数组的整数，每两个整数之间用空格分隔。 【输入样例】1258 6 5 4 1 【输出样例】11 4 5 6 8 【答案&amp;代码】123456789101112131415#include&lt;cstdio&gt;#include&lt;cmath&gt;int n,num[101];int main(void)&#123; register int i; scanf("%d",&amp;n); for(i=1;i&lt;=n;++i) scanf("%d",&amp;num[i]); for(i=n;i&gt;=1;--i) printf("%d ",num[i]); putchar('\n'); return 0;&#125; T1106 : 年龄与疾病 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】某医院想统计一下某项疾病的获得与否与年龄是否有关，需要对以前的诊断记录进行整理，按照$0-18,19-35,36-60,61$以上（含$61$）四个年龄段统计的患病人数占总患病人数的比例。 【输入】共$2$行，第一行为过往病人的数目$n(0 &lt; n \leq 100)$，第二行为每个病人患病时的年龄。 【输出】按照$0-18,19-35,36-60,61$以上（含$61$）四个年龄段输出该段患病人数占总患病人数的比例，以百分比的形式输出，精确到小数点后两位。每个年龄段占一行，共四行。 【输入样例】12101 11 21 31 41 51 61 71 81 91 【输出样例】123420.00%20.00%20.00%40.00% 【答案&amp;代码】12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;cmath&gt;int n,sum[4],temp;int main(void)&#123; register int i; scanf("%d",&amp;n); for(i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;temp); if(temp&lt;=18) ++sum[0]; else if(temp&lt;=35) ++sum[1]; else if(temp&lt;=60) ++sum[2]; else ++sum[3]; &#125; printf("%.2f%%\n%.2f%%\n%.2f%%\n%.2f%%\n",sum[0]*100.0/n,sum[1]*100.0/n,sum[2]*100.0/n,sum[3]*100.0/n); return 0;&#125; T1107 : 校门外的树 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】某校大门外长度为$L$的马路上有一排树，每两棵相邻的树之间的间隔都是$1$米。我们可以把马路看成一个数轴，马路的一端在数轴$0$的位置，另一端在$L$的位置；数轴上的每个整数点，即$0,1,2,…,L$都种有一棵树。 由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。 【输入】第一行有两个整数$L(1 \leq L \leq 10000),M(1 \leq M \leq 100)$，$L$代表马路的长度，$M$代表区域的数目，$L$和$M$之间用一个空格隔开。接下来的$M$行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。 对于$20\%$的数据，区域之间没有重合的部分；对于其它的数据，区域之间有重合的情况。 【输出】包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。 【输入样例】1234500 3150 300100 200470 471 【输出样例】1298 【答案&amp;代码】1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;cmath&gt;bool tr[10001];int l,m,t1,t2;int main(void)&#123; register int i,j,sum=0; scanf("%d%d",&amp;l,&amp;m); for(i=1;i&lt;=m;++i)&#123; scanf("%d%d",&amp;t1,&amp;t2); for(j=t1;j&lt;=t2;++j) tr[j]=true; &#125; for(i=0;i&lt;=l;++i) if(!tr[i]) ++sum; printf("%d\n",sum); return 0;&#125; T1108 : 向量点积计算 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】在线性代数、计算几何中，向量点积是一种十分重要的运算。给定两个$n$维向量$a=(a_1,a_2,…,a_n),b=(b_1,b_2,…,b_n)$，求点积$a \cdot b=a_1b_1+a_2b_2+…+a_nb_n$。 【输入】第一行是一个整数$n(1 \leq n \leq 1000)$； 第二行包含$n$个整数$a_1,a_2,…,a_n$； 第三行包含$n$个整数$b_1,b_2,…,b_n$； 相邻整数之间用单个空格隔开。每个整数的绝对值都不超过$1000$。 【输出】一个整数，即两个向量的点积结果。 【输入样例】12331 4 62 1 5 【输出样例】136 【答案&amp;代码】1234567891011121314151617#include&lt;cstdio&gt;#include&lt;cmath&gt;int n,a[1001],b[1001];int main(void)&#123; register int i,sum=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;++i) scanf("%d",&amp;b[i]); for(i=1;i&lt;=n;++i) sum+=a[i]*b[i]; printf("%d\n",sum); return 0;&#125; T1109 : 开关灯 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】假设有$N(N \leq 5000)$盏灯，从$1$到$N$按顺序依次编号，初始时全部处于开启状态；有$M$个人（$M$为不大于$N$的正整数）也从$1$到$M$依次编号。 第一个人将灯全部关闭，第二个人将编号为$2$的倍数的灯打开，第三个人将编号为$3$的倍数的灯做相反处理（即将打开的灯关闭，将关闭的灯打开）。依照编号递增顺序，以后的人都和$3$号一样，将凡是自己编号倍数的灯做相反处理。 请问：当第$M$个人操作之后，哪几盏灯是关闭的，按从小到大输出其编号，其间用逗号间隔。 【输入】输入正整数$N$和$M$，以单个空格隔开。 【输出】顺次输出关闭的灯的编号，其间用逗号间隔。 【输入样例】110 10 【输出样例】11,4,9 【答案&amp;代码】1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;cstring&gt;bool l[5001]int n,m;int main(void)&#123; register bool flag=true; register int i; memset(l,true,sizeof(l)); scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=m;++i) for(j=1;j&lt;=n;++j) if(j%i==0) l[j]=!l[j]; for(i=1;i&lt;=n;++i) if(flag&amp;&amp;!l[i]) printf("%d",i),flag=false; else if(!l[i]) printf(",%d",i); putchar('\n'); return 0;&#125; T1110 : 查找特定的值 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】在一个序列（下标从$1$开始）中查找一个给定的值，输出第一次出现的位置。 【输入】第一行包含一个正整数$n(1 \leq n \leq 10000)$，表示序列中元素个数。 第二行包含$n$个整数，依次给出序列的每个元素，相邻两个整数之间用单个空格隔开。元素的绝对值不超过$10000$。 第三行包含一个整数$x$，为需要查找的特定值。$x$的绝对值不超过$10000$。 【输出】若序列中存在$x$，输出$x$第一次出现的下标；否则输出$-1$。 【输入样例】12352 3 6 7 33 【输出样例】12 【答案&amp;代码】12345678910111213141516#include&lt;cstdio&gt;int n,num[10001],x;int main(void)&#123; register int i; scanf("%d",&amp;n); for(i=1;i&lt;=n;++i) scanf("%d",&amp;num[i]); scanf("%d",&amp;x); for(i=1;i&lt;=n;++i) if(num[i]==x) return printf("%d\n",i+1),0; puts("-1"); return 0;&#125; T1111 : 不高兴的津津 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。 【输入】包括七行数据，分别表示周一到周日的日程安排。每行包括两个小于$10$的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。 【输出】包括一行，这一行只包含一个数字。如果不会不高兴则输出$0$，如果会则输出最不高兴的是周几（用$1,2,3,4,5,6,7$分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。 【输入样例】12345675 36 27 25 35 40 40 6 【输出样例】13 【答案&amp;代码】12345678910111213141516#include&lt;cstdio&gt;int num[7][2],s[7];int main(void)&#123; register int i,MAX=0; for(i=0;i&lt;7;++i)&#123; scanf("%d%d",&amp;num[i][0],&amp;num[i][1]); s[i]=num[i][0]+num[i][1]; &#125; for(i=0;i&lt;7;++i) if(s[i]&gt;s[MAX]) MAX=i; printf("%d\n",MAX+1); return 0;&#125; T1112 : 最大值和最小值的差 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输出一个整数序列中最大的数和最小的数的差。 【输入】第一行为$M$，表示整数个数，整数个数不会大于$10000$； 第二行为$M$个整数，以空格隔开，每个整数的绝对值不会大于$10000$。 【输出】输出$M$个数中最大值和最小值的差。 【输入样例】1252 5 7 4 2 【输出样例】15 【答案&amp;代码】12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int m,a[10001]; int max=0,min=99999; int difference; int i; cin&gt;&gt;m; for(i=1;i&lt;=m;i++)&#123; cin&gt;&gt;a[i]; if(a[i]&gt;max) max=a[i]; if(a[i]&lt;min) min=a[i]; &#125; difference=max-min; cout&lt;&lt;difference&lt;&lt;endl; return 0;&#125; T1113 : 不与最大数相同的数字之和 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输出一个整数数列中不与最大数相同的数字之和。 【输入】输入分为两行： 第一行为$N$（$N$为接下来数的个数，$N \leq 100$）； 第二行$N$个整数，数与数之间以一个空格分开，每个整数的范围是$-1000,000$到$1000,000$。 【输出】输出为$N$个数中除去最大数其余数字之和。 【输入样例】1231 2 3 【输出样例】13 【答案&amp;代码】12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int a[10001];int main()&#123; int n; cin&gt;&gt;n; int max=-1; long long int tot=0; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(a[i]&gt;max) max=a[i]; &#125; for(int i=1;i&lt;=n;i++) if(a[i]!=max) tot=tot+a[i]; cout&lt;&lt;tot; return 0;&#125; T1114 : 白细胞计数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】医院采样了某临床病例治疗期间的白细胞数量样本$n$份，用于分析某种新抗生素对该病例的治疗效果。为了降低分析误差，要先从这$n$份样本中去除一个数值最大的样本和一个数值最小的样本，然后将剩余$n-2$个有效样本的平均值作为分析指标。同时，为了观察该抗生素的疗效是否稳定，还要给出该平均值的误差，即所有有效样本（即不包括已扣除的两个样本）与该平均值之差的绝对值的最大值。 现在请你编写程序，根据提供的$n$个样本值，计算出该病例的平均白细胞数量和对应的误差。 【输入】输入的第一行是一个正整数$n(2 &lt; n \leq 300)$，表明共有$n$个样本。 以下共有$n$行，每行为一个浮点数，为对应的白细胞数量，其单位为$10^{9}/L$。数与数之间以一个空格分开。 【输出】输出为两个浮点数，中间以一个空格分开。分别为平均白细胞数量和对应的误差，单位也是$10^{9}/L$。计算结果需保留到小数点后$2$位。 【输入样例】123456512.013.011.09.010.0 【输出样例】111.00 1.00 【答案&amp;代码】123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main(void)&#123; double n; int flag_max,flag_min; int i; double max=-99999,min=99999; double a[3001],b[3001],sum=0; double average,ave_max=-99999; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(a[i]&gt;max)&#123; max=a[i]; flag_max=i; &#125; if(a[i]&lt;min)&#123; min=a[i]; flag_min=i; &#125; sum+=a[i]; &#125; average=1.0*(sum-max-min)/(n-2); for(i=1;i&lt;=n;i++)&#123; if(i!=flag_max&amp;&amp;i!=flag_min)&#123; b[i]=a[i]-average; if(b[i]&lt;0) b[i]=-b[i]; &#125; else b[i]=-99999; &#125; for(i=1;i&lt;=n;i++) if(b[i]&gt;ave_max) ave_max=b[i]; printf("%.2lf %.2lf\n",average,ave_max); return 0;&#125; T1115 : 直方图 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个非负整数数组，统计里面每一个数的出现次数。我们只统计到数组里最大的数。 假设$F_{max}(F_{max}&lt;10000)$是数组里最大的数，那么我们只统计${0,1,2,…,F_{max}}$里每个数出现的次数。 【输入】第一行$n(1 \leq n \leq 10000)$是数组的大小。 紧接着一行是数组的$n$个元素。 【输出】按顺序输出每个数的出现次数，一行一个数。如果没有出现过，则输出$0$。 【输入样例】1251 1 2 3 1 【输出样例】12340311 【答案&amp;代码】123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;algorithm&gt;int main(void)&#123; int n; scanf("%d",&amp;n); int num[n]; for(int i=0;i&lt;n;i++) scanf("%d",num+i); std::sort(num,num+n); for(int i=0;i&lt;=num[n-1];i++)&#123; int sum=0; for(int j=0;j&lt;n;j++) if(num[j]==i) sum+=1; printf("%d\n",sum); &#125; return 0;&#125; T1116 : 最长平台 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】已知一个已经从小到大排序的数组，这个数组的一个平台（$Plateau$）就是连续的一串值相同的元素，并且这一串元素不能再延伸。 【输入】第一行有一个整数$n$，为数组元素的个数。第二行有$n$个整数，整数之间以一个空格分开。 【输出】输出最长平台的长度。 【输入样例】12101 2 2 3 3 3 4 5 5 6 【输出样例】13 【答案&amp;代码】12345678910111213141516171819202122#include&lt;stdio.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); int num[n]; for(int i=0;i&lt;n;i++) scanf("%d",&amp;num[i]); int MAX=1; if(n==0) MAX=0; int sum=1; for(int i=0;i&lt;n-1;i++)&#123; if(num[i]==num[i+1]) sum++; else sum=1; if(sum&gt;MAX) MAX=sum; &#125; printf("%d",MAX); return 0;&#125; T1117 : 整数去重 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定含有$n$个整数的序列，要求对这个序列进行去重操作。所谓去重，是指对这个序列中每个重复出现的数，只保留该数第一次出现的位置，删除其余位置。 【输入】输入包含两行： 第一行包含一个正整数$n(1 \leq n \leq 20000)$，表示第二行序列中数字的个数； 第二行包含$n$个整数，整数之间以一个空格分开。每个整数大于等于$10$、小于等于$5000$。 【输出】输出只有一行，按照输入的顺序输出其中不重复的数字，整数之间用一个空格分开。 【输入样例】12510 12 93 12 75 【输出样例】110 12 93 75 【答案&amp;代码】123456789101112131415161718#include&lt;stdio.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); int num[n]; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;num[i]); for(int j=0;j&lt;i;j++) if(num[j]==num[i])&#123; i--; n--; &#125; &#125; for(int i=0;i&lt;n;i++) printf("%d ",num[i]); return 0;&#125; T1118 : 铺地毯 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有$n$张地毯，编号从$1$到$n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 【输入】第一行，一个整数$n$，表示总共有$n$张地毯。 接下来的$n$行中，第$i+1$行表示编号$i$的地毯的信息，包含四个正整数$a,b,g,k$，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标$(a,b)$以及地毯在$x$轴和$y$轴方向的长度。 第$n+2$行包含两个正整数$x$和$y$，表示所求的地面的点的坐标$(x,y)$。 【输出】输出共$1$行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出$-1$。 【输入样例】1234531 0 2 30 2 3 32 1 3 32 2 【输出样例】13 【答案&amp;代码】1234567891011121314151617#include&lt;stdio.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); int a[n],b[n],g[n],k[n]; for(int i=0;i&lt;n;i++) scanf("%d%d%d%d",&amp;a[i],&amp;b[i],&amp;g[i],&amp;k[i]); int x,y; scanf("%d%d",&amp;x,&amp;y); for(int i=n-1;i&gt;=0;i--) if(a[i]&lt;=x&amp;&amp;x&lt;=a[i]+g[i]&amp;&amp;b[i]&lt;=y&amp;&amp;y&lt;=b[i]+k[i])&#123; printf("%d",i+1); return 0; &#125; printf("-1"); return 0;&#125; 第二节 二维数组T1119 : 矩阵交换行 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个$5×5$的矩阵(数学上，一个$r×c$的矩阵是一个由$r$行$c$元素排列成的矩形阵列)，将第$n$行和第$m$行交换，输出交换后的结果。 【输入】输入共$6$行，前$5$行为矩阵的每一行元素，元素与元素之间以一个空格分开。 第$6$行包含两个整数$m,n(1 \leq m,n \leq 5)$，以一个空格分开。 【输出】输出交换之后的矩阵，矩阵的每一行元素占一行，元素之间以一个空格分开。 【输入样例】1234561 2 2 1 25 6 7 8 39 3 0 5 37 2 1 4 63 0 8 2 41 5 【输出样例】123453 0 8 2 45 6 7 8 39 3 0 5 37 2 1 4 61 2 2 1 2 【答案&amp;代码】12345678910111213141516171819202122#include&lt;stdio.h&gt;int main(void)&#123; int a[5][5]; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;5;j++) scanf("%d",&amp;a[i][j]); int m,n; scanf("%d%d",&amp;m,&amp;n); m--; n--; for(int i=0;i&lt;5;i++)&#123; int temp=a[m][i]; a[m][i]=a[n][i]; a[n][i]=temp; &#125; for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;5;j++) printf("%d ",a[i][j]); printf("\n"); &#125; return 0;&#125; T1120 : 同行列对角线的格 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入三个自然数$N,i,j(1 \leq i \leq n,1 \leq j \leq n)$，输出在一个$N×N$格的棋盘中（行列均从$1$开始编号），与格子$(i,j)$同行、同列、同一对角线的所有格子的位置。 【输入】一行，三个自然数$N(1 \leq N \leq 10),i,j$，相邻两个数之间用单个空格隔开。 【输出】第一行：从左到右输出同一行格子位置； 第二行：从上到下输出同一列格子位置； 第三行：从左上到右下输出同一对角线格子位置； 第四行：从左下到右上输出同一对角线格子位置。 其中每个格子位置用如下格式输出：$(x,y)$，$x$为行号，$y$为列号，采用英文标点，中间无空格。相邻两个格子位置之间用单个空格隔开。 【输入样例】14 2 3 【输出样例】1234(2,1) (2,2) (2,3) (2,4)(1,3) (2,3) (3,3) (4,3)(1,2) (2,3) (3,4)(4,1) (3,2) (2,3) (1,4) 【答案&amp;代码】1234567891011121314151617181920#include&lt;stdio.h&gt;int main(void)&#123; int n,i,j; scanf("%d%d%d",&amp;n,&amp;i,&amp;j); for(int k=1;k&lt;=n;k++) printf("(%d,%d) ",i,k); putchar('\n'); for(int k=1;k&lt;=n;k++) printf("(%d,%d) ",k,j); putchar('\n'); for(int k=1;k&lt;=n;k++) if(k+j-i&gt;0&amp;&amp;k+j-i&lt;=n) printf("(%d,%d) ",k,k+j-i); putchar('\n'); for(int k=n;k&gt;=1;k--) if(i+j-k&gt;0&amp;&amp;i+j-k&lt;=n) printf("(%d,%d) ",k,i+j-k); putchar('\n'); return 0;&#125; T1121 : 计算矩阵边缘元素之和 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入一个整数矩阵，计算位于矩阵边缘的元素之和。所谓矩阵边缘的元素，就是第一行和最后一行的元素以及第一列和最后一列的元素。 【输入】第一行分别为矩阵的行数$m$和列数$n(m&lt;100,n&lt;100)$，两者之间以一个空格分开。 接下来输入的$m$行数据中，每行包含$n$个整数，整数之间以一个空格分开。 【输出】输出对应矩阵的边缘元素和。 【输入样例】12343 33 4 13 7 12 0 1 【输出样例】115 【答案&amp;代码】123456789101112131415#include&lt;stdio.h&gt;int main(void)&#123; int m,n,sum=0; scanf("%d%d",&amp;m,&amp;n); int a[m][n]; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) scanf("%d",&amp;a[i][j]); for(int i=0;i&lt;n;i++) sum=sum+a[0][i]+a[m-1][i]; for(int j=1;j&lt;m-1;j++) sum=sum+a[j][0]+a[j][n-1]; printf("%d",sum); return 0;&#125; T1122 : 计算鞍点 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个$5×5$的矩阵，每行只有一个最大值，每列只有一个最小值，寻找这个矩阵的鞍点。鞍点指的是矩阵中的一个元素，它是所在行的最大值，并且是所在列的最小值。 【输入】输入包含一个$5$行$5$列的矩阵。 【输出】如果存在鞍点，输出鞍点所在的行、列及其值，如果不存在，输出not found。 【输入样例】1234511 3 5 6 912 4 7 8 1010 5 6 9 118 6 4 7 215 10 11 20 25 【输出样例】14 1 8 【答案&amp;代码】123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#define N 5int a[N][N];int main(void)&#123; bool flag=false; int Max,Min,Ni,Nj; for(int i=0;i&lt;N;i++) for(int j=0;j&lt;N;j++) scanf("%d",&amp;a[i][j]); for(int i=0;i&lt;N;i++)&#123; Max=a[i][0]; for(int j=0;j&lt;N;j++) if(a[i][j]&gt;=Max) Ni=i, Nj=j, Max=a[i][j]; Min=Max; for(int k=0;k&lt;N;k++) if(a[k][Nj]&lt;Min) Min=a[k][Nj]; if(Max==Min)&#123; flag=true; printf("%d %d %d",Ni+1,Nj+1,Max); break; &#125; &#125; if(!flag) printf("not found"); return 0;&#125; T1123 : 图像相似度 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给出两幅相同大小的黑白图像（用$01$矩阵表示），求它们的相似度。说明：若两幅图像在相同位置上的像素点颜色相同，则称它们在该位置具有相同的像素点。两幅图像的相似度定义为相同像素点数占总像素点数的百分比。 【输入】第一行包含两个整数$m$和$n$，表示图像的行数和列数，中间用单个空格隔开。$1 \leq m \leq 100,1 \leq n \leq 100$。 之后$m$行，每行$n$个整数$0$或$1$，表示第一幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。 之后$m$行，每行$n$个整数$0$或$1$，表示第二幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。 【输出】一个实数，表示相似度（以百分比的形式给出），精确到小数点后两位。 【输入样例】12345673 31 0 10 0 11 1 01 1 00 0 10 0 1 【输出样例】144.44 【答案&amp;代码】1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; int m,n; scanf("%d%d",&amp;m,&amp;n); short a[m][n],b[m][n]; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) scanf("%d",&amp;a[i][j]); for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) scanf("%d",&amp;b[i][j]); int sum=0; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) if(a[i][j]==b[i][j]) sum+=1; printf("%.2f",(double)sum/m/n*100); return 0;&#125; T1124 : 矩阵加法 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入两个$n$行$m$列的矩阵$A$和$B$，输出它们的和$A+B$。 【输入】第一行包含两个整数$n$和$m$，表示矩阵的行数和列数$(1 \leq n \leq 100,1 \leq m \leq 100)$。 接下来$n$行，每行$m$个整数，表示矩阵$A$的元素。 接下来$n$行，每行$m$个整数，表示矩阵$B$的元素。 相邻两个整数之间用单个空格隔开，每个元素均在$1-1000$之间。 【输出】$n$行，每行$m$个整数，表示矩阵加法的结果。相邻两个整数之间用单个空格隔开。 【输入样例】12345673 31 2 31 2 31 2 31 2 34 5 67 8 9 【输出样例】1232 4 65 7 98 10 12 【答案&amp;代码】123456789101112131415161718192021#include&lt;stdio.h&gt;int main(void)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int a[n][m]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf("%d",&amp;a[i][j]); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; int temp; scanf("%d",&amp;temp); a[i][j]+=temp; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++) printf("%d ",a[i][j]); printf("\n"); &#125; return 0;&#125; T1125 : 矩阵乘法 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】计算两个矩阵的乘法。$n×m$阶的矩阵$A$乘以$m×k$阶的矩阵$B$得到的矩阵$C$是$n×k$阶的，且 $$C[i][j]=\sum^{m}_{k=1}A[i][k]×B[k][j]$$ $C[i][j]$表示矩阵$C$中第$i$行第$j$列元素。 【输入】第一行为$n,m,k$，表示矩阵$A$是$n$行$m$列，矩阵$B$是$m$行$k$列，$n,m,k$均小于$100$。 然后先后输入$A$和$B$两个矩阵，矩阵$A$是$n$行$m$列，矩阵$B$是$m$行$k$列，矩阵中每个元素的绝对值不会大于$1000$。 【输出】输出矩阵$C$，一共$n$行，每行$k$个整数，整数之间以一个空格分开。 【输入样例】1234563 2 31 11 11 11 1 11 1 1 【输出样例】1232 2 22 2 22 2 2 【答案&amp;代码】1234567891011121314151617181920#include&lt;stdio.h&gt;int main(void)&#123; int n,m,k; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); int A[n][m],B[m][k]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf("%d",&amp;A[i][j]); for(int i=0;i&lt;m;i++) for(int j=0;j&lt;k;j++) scanf("%d",&amp;B[i][j]); for(int i=0;i&lt;n;i++,putchar('\n')) for(int j=0;j&lt;k;j++)&#123; int sum=0; for(int l=0;l&lt;m;l++) sum+=A[i][l]*B[l][j]; printf("%d ",sum); &#125; return 0;&#125; T1126 : 矩阵转置 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入一个$n$行$m$列的矩阵$A$，输出它的转置$A^T$。 【输入】第一行包含两个整数$n$和$m$，表示矩阵$A$的行数和列数$(1 \leq n \leq 100,1 \leq m \leq 100)$。 接下来$n$行，每行$m$个整数，表示矩阵$A$的元素。相邻两个整数之间用单个空格隔开，每个元素均在$1-1000$之间。 【输出】$m$行，每行$n$个整数，为矩阵$A$的转置。相邻两个整数之间用单个空格隔开。 【输入样例】12343 31 2 34 5 67 8 9 【输出样例】1231 4 72 5 83 6 9 【答案&amp;代码】12345678910111213141516#include&lt;stdio.h&gt;int main(void)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int a[m][n]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf("%d",&amp;a[j][i]); for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++) printf("%d ",a[i][j]); printf("\n"); &#125; return 0;&#125; T1127 : 图像旋转 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入一个$n$行$m$列的黑白图像，将它顺时针旋转$90$度后输出。 【输入】第一行包含两个整数$n$和$m$，表示图像包含像素点的行数和列数。$(1 \leq n \leq 100,1 \leq m \leq 100)$。 接下来$n$行，每行$m$个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在$0-255$之间。 【输出】$m$行，每行$n$个整数，为顺时针旋转$90$度后的图像。相邻两个整数之间用单个空格隔开。 【输入样例】12343 31 2 34 5 67 8 9 【输出样例】1237 4 18 5 29 6 3 【答案&amp;代码】123456789101112131415#include&lt;stdio.h&gt;int main(void)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int a[m][n]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf("%d",&amp;a[j][i]); for(int i=0;i&lt;m;i++)&#123; for(int j=n-1;j&gt;=0;j--) printf("%d ",a[i][j]); printf("\n"); &#125; return 0;&#125; T1128 : 图像模糊处理 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定$n$行$m$列的图像各像素点的灰度值，要求用如下方法对其进行模糊化处理： 四周最外侧的像素点灰度值不变； 中间各像素点新灰度值为该像素点及其上下左右相邻四个像素点原灰度值的平均（舍入到最接近的整数）。 【输入】第一行包含两个整数$n$和$m$，表示图像包含像素点的行数和列数。$(1 \leq n \leq 100,1 \leq m \leq 100)$。 接下来$n$行，每行$m$个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在$0-255$之间。 【输出】$m$行，每行$n$个整数，为模糊处理后的图像。相邻两个整数之间用单个空格隔开。 【输入样例】123454 5100 0 100 0 5050 100 200 0 050 50 100 100 200100 100 50 50 100 【输出样例】1234100 0 100 0 5050 80 100 60 050 80 100 90 200100 100 50 50 100 【答案&amp;代码】1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int num[n][m],ans[n][m]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf("%d",&amp;num[i][j]),ans[i][j]=num[i][j]; for(int i=1;i&lt;n-1;i++) for(int j=1;j&lt;m-1;j++) ans[i][j]=round((num[i][j]+num[i-1][j]+num[i][j-1]+num[i+1][j]+num[i][j+1])/5.0); for(int i=0;i&lt;n;i++,putchar('\n')) for(int j=0;j&lt;m;j++) printf("%d ",ans[i][j]); return 0;&#125; 第三节 字符类型和字符数组T1129 : 统计数字字符个数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入一行字符，统计出其中数字字符的个数。 【输入】一行字符串，总长度不超过$255$。 【输出】输出为$1$行，输出字符串里面数字字符的个数。 【输入样例】1Peking University is set up at 1898. 【输出样例】14 【答案&amp;代码】123456789101112#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char str[256]; gets(str); int sum=0; for(int i=0;i&lt;strlen(str);i++) if('0'&lt;=str[i]&amp;&amp;str[i]&lt;='9') sum+=1; printf("%d",sum); return 0;&#125; T1130 : 找第一个只出现一次的字符 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个只包含小写字母的字符串，请你找到第一个仅出现一次的字符。如果没有，输出no。 【输入】一个字符串，长度小于$100000$。 【输出】输出第一个仅出现一次的字符，若没有则输出no。 【输入样例】1abcabd 【输出样例】1c 【答案&amp;代码】123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main(void)&#123; char a[100000]; int b; for(b=0;b&lt;100000;b++)&#123; scanf("%c",&amp;a[b]); if(a[b]==10)&#123; break; &#125; &#125; int flag=0,c,d; for(c=0;c&lt;b;c+=1)&#123; flag=0; for(d=0;d&lt;b;d++)&#123; if(a[c]==a[d]&amp;&amp;c!=d)&#123; flag=1; break; &#125; &#125; if(flag==0)&#123; printf("%c",a[c]); return 0; &#125; &#125; printf("no"); return 0;&#125; T1131 : 基因相关性 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】为了获知基因序列在功能和结构上的相似性，经常需要将几条不同序列的$DNA$进行比对，以判断该比对的$DNA$是否具有相关性。 现比对两条长度相同的$DNA$序列。定义两条$DNA$序列相同位置的碱基为一个碱基对，如果一个碱基对中的两个碱基相同的话，则称为相同碱基对。接着计算相同碱基对占总碱基对数量的比例，如果该比例大于等于给定阈值时则判定该两条$DNA$序列是相关的，否则不相关。 【输入】有三行，第一行是用来判定出两条$DNA$序列是否相关的阈值，随后$2$行是两条$DNA$序列（长度不大于$500$）。 【输出】若两条$DNA$序列相关，则输出yes，否则输出no。 【输入样例】1230.85ATCGCCGTAAGTAACGGTTTTAAATAGGCCATCGCCGGAAGTAACGGTCTTAAATAGGCC 【输出样例】1yes 【答案&amp;代码】123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; double f; char dna1[512],dna2[512]; scanf("%lf",&amp;f); scanf("%s",dna1); scanf("%s",dna2); int sum=0; for(int i=0;i&lt;strlen(dna1);i++) if(dna1[i]==dna2[i]) sum+=1; if((double)sum/strlen(dna1)&gt;=f) printf("yes"); else printf("no"); return 0;&#125; T1132 : 石头剪子布 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】石头剪子布，是一种猜拳游戏。起源于中国，然后传到日本、朝鲜等地，随着亚欧贸易的不断发展它传到了欧洲，到了近现代逐渐风靡世界。简单明了的规则，使得石头剪子布没有任何规则漏洞可钻，单次玩法比拼运气，多回合玩法比拼心理博弈，使得石头剪子布这个古老的游戏同时用于“意外”与“技术”两种特性，深受世界人民喜爱。 游戏规则：石头打剪刀，布包石头，剪刀剪布。 现在，需要你写一个程序来判断石头剪子布游戏的结果。 【输入】第一行是一个整数$N$，表示一共进行了$N$次游戏$(1 \leq N \leq 100)$。 接下来$N$行的每一行包括两个字符串，表示游戏参与者Player1，Player2的选择（石头、剪子或者是布）。 字符串之间以空格隔开。 【输出】输出包括$N$行，每一行对应一个胜利者（Player1或者Player2），或者游戏出现平局，则输出Tie。 【输入样例】12343Rock ScissorsPaper PaperRock Paper 【输出样例】123Player1TiePlayer2 【答案&amp;代码】12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;int main(void)&#123; int n; char word_1[16],word_2[16]; scanf("%d",&amp;n); while(n--)&#123; scanf("%s%s",word_1,word_2); if(word_1[0]=='R') if(word_2[0]=='R') printf("Tie\n"); else if(word_2[0]=='P') printf("Player2\n"); else printf("Player1\n"); else if(word_1[0]=='S') if(word_2[0]=='S') printf("Tie\n"); else if(word_2[0]=='R') printf("Player2\n"); else printf("Player1\n"); else if(word_2[0]=='P') printf("Tie\n"); else if(word_2[0]=='S') printf("Player2\n"); else printf("Player1\n"); &#125; return 0;&#125; T1133 : 输出亲朋字符串 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】编写程序，求给定字符串$s$的亲朋字符串$s_1$。 亲朋字符串$s_1$定义如下：给定字符串$s$的第一个字符的ASCII值加第二个字符的ASCII值，得到第一个亲朋字符； 给定字符串$s$的第二个字符的ASCII值加第三个字符的ASCII值，得到第二个亲朋字符；依此类推，直到给定字符串$s$的倒数第二个字符。亲朋字符串的最后一个字符由给定字符串$s$的最后一个字符ASCII值加$s$的第一个字符的ASCII值。 【输入】输入一行，一个长度大于等于$2$，小于等于$100$的字符串。字符串中每个字符的ASCII值不大于$63$。 【输出】输出一行，为变换后的亲朋字符串。输入保证变换后的字符串只有一行。 【输入样例】11234 【输出样例】1cege 【答案&amp;代码】123456789101112#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char str[101]; gets(str); char ch=str[0]; for(int i=0;i&lt;strlen(str)-1;i++) str[i]+=str[i+1]; str[strlen(str)-1]+=ch; printf("%s",str); return 0;&#125; T1134 : 合法C标识符查 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个不包含空白符的字符串，请判断是否是C语言合法的标识符号（注：题目保证这些字符串一定不是C语言的保留字）。 C语言标识符要求： 非保留字； 只包含字母、数字及下划线（_）； 不以数字开头。 【输入】一行，包含一个字符串，字符串中不包含任何空白字符，且长度不大于$20$。 【输出】一行，如果它是C语言的合法标识符，则输出yes，否则输出no。 【输入样例】1RKPEGX9R;TWyYcp 【输出样例】1no 【答案&amp;代码】1234567891011121314#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char str[256]; gets(str); for(int i=0;i&lt;strlen(str);i++) if(('0'&lt;=str[i]&amp;&amp;str[i]&lt;='9'&amp;&amp;i!=0)||('A'&lt;=str[i]&amp;&amp;str[i]&lt;='Z')||('a'&lt;=str[i]&amp;&amp;str[i]&lt;='z')||str[i]=='_'); else&#123; printf("no"); return 0; &#125; printf("yes"); return 0;&#125; T1135 : 配对碱基链 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】脱氧核糖核酸由两条互补的碱基链以双螺旋的方式结合而成。而构成$DNA$的碱基共有$4$种，分别为腺瞟呤、鸟嘌呤、胸腺嘧啶和胞嘧啶。我们知道，在两条互补碱基链的对应位置上，腺瞟呤总是和胸腺嘧啶配对，鸟嘌呤总是和胞嘧啶配对。你的任务就是根据一条单链上的碱基序列，给出对应的互补链上的碱基序列。 【输入】一个字符串，表示一条碱基链。这个字符串只含有大写字母$A,T,G,C$，分别表示腺瞟呤、胸腺嘧啶、鸟嘌呤和胞嘧啶。字符串长度不超过$255$。 【输出】一个只含有大写字母$A,T,G,C$的字符串，为与输入的碱基链互补的碱基链。 【输入样例】1ATATGGATGGTGTTTGGCTCTG 【输出样例】1TATACCTACCACAAACCGAGAC 【答案&amp;代码】123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char str[256]; scanf("%s",str); for(int i=0;i&lt;strlen(str);i++) switch(str[i])&#123; case 'A': str[i]='T';break; case 'T': str[i]='A';break; case 'C': str[i]='G';break; case 'G': str[i]='C';break; &#125; printf("%s",str); return 0;&#125; T1136 : 密码翻译 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】在情报传递过程中，为了防止情报被截获，往往需要对情报用一定的方式加密，简单的加密算法虽然不足以完全避免情报被破译，但仍然能防止情报被轻易的识别。我们给出一种最简的的加密方法，对给定的一个字符串，把其中从$a-y,A-Y$的字母用其后继字母替代，把$z,Z$用$a,A$替代，其他非字母字符不变，则可得到一个简单的加密字符串。 【输入】输入一行，包含一个字符串，长度小于$80$个字符。 【输出】输出每行字符串的加密字符串。 【输入样例】1Hello! How are you! 【输出样例】1Ifmmp! Ipx bsf zpv! 【答案&amp;代码】12345678910111213#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char str[80]; gets(str); for(int i=0;i&lt;strlen(str);i++) if('a'&lt;=str[i]&amp;&amp;str[i]&lt;='y'||'A'&lt;=str[i]&amp;&amp;str[i]&lt;='Y') str[i]+=1; else if(str[i]=='z'||str[i]=='Z') str[i]-=25; printf("%s",str); return 0;&#125; T1137 : 加密的病历单 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】小英是药学专业大三的学生，暑假期间获得了去医院药房实习的机会。 在药房实习期间，小英扎实的专业基础获得了医生的一致好评，得知小英在计算概论中取得过好成绩后，主任又额外交给她一项任务，解密抗战时期被加密过的一些伤员的名单。 经过研究，小英发现了如下加密规律（括号中是一个“原文$\to$密文”的例子） 原文中所有的字符都在字母表中被循环左移了三个位置（${dec}\to{abz}$）； 逆序存储（${abcd}\to{dcba}$ ）； 大小写反转（${abXY}\to{ABxy}$）。 【输入】一个加密的字符串（长度小于$50$且只包含大小写字母）。 【输出】输出解密后的字符串。 【输入样例】1GSOOWFASOq 【输出样例】1Trvdizrrvj 【答案&amp;代码】1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char a[100001]; char ans[1001]; gets(a); for(int i=0;i&lt;strlen(a);i++)&#123; if(a[i]&gt;='A'&amp;&amp;a[i]&lt;='Z') a[i]=a[i]+32; else a[i]=a[i]-32; &#125; for(int i=strlen(a)-1,now=0;i&gt;=0;i--)&#123; ans[now]=a[i]; now++; &#125; for(int i=0;i&lt;strlen(a);i++)&#123; if((ans[i]&gt;=65&amp;&amp;ans[i]&lt;=87)||(ans[i]&gt;=97&amp;&amp;ans[i]&lt;=119)) ans[i]=ans[i]+3; else&#123; ans[i]=ans[i]-23; &#125; &#125; puts(ans); return 0;&#125; T1138 : 将字符串中的小写字母转换成大写字母 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个字符串，将其中所有的小写字母转换成大写字母。 【输入】输入一行，包含一个字符串（长度不超过$100$，可能包含空格）。 【输出】输出转换后的字符串。 【输入样例】1helloworld123Ha 【输出样例】1HELLOWORLD123HA 【答案&amp;代码】1234567891011#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char str[101]; gets(str); for(int i=0;i&lt;strlen(str);i++) if('a'&lt;=str[i]&amp;&amp;str[i]&lt;='z') str[i]-=32; printf("%s",str); return 0;&#125; T1139 : 整理药名 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】医生在书写药品名的时候经常不注意大小写，格式比较混乱。现要求你写一个程序将医生书写混乱的药品名整理成统一规范的格式，即药品名的第一个字符如果是字母要大写，其他字母小写。如将ASPIRIN、aspirin整理成Aspirin。 【输入】第一行一个数字$n$，表示有$n$个药品名要整理，$n$不超过$100$。 接下来$n$行，每行一个单词，长度不超过$20$，表示医生手书的药品名。药品名由字母、数字和-组成。 【输出】$n$行，每行一个单词，对应输入的药品名的规范写法。 【输入样例】123454AspiRincisapride2-PENICILLINCefradine-6 【输出样例】1234AspirinCisapride2-penicillinCefradine-6 【答案&amp;代码】123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;void strlwr_(char *str)&#123; for(int i=0;i&lt;strlen(str);i++) if('A'&lt;=str[i]&amp;&amp;str[i]&lt;='Z') str[i]+=32; return;&#125;int main(void)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; char str[21]; scanf("%s",str); strlwr_(str); if('a'&lt;=str[0]&amp;&amp;str[0]&lt;='z') str[0]-=32; printf("%s\n",str); &#125; return 0;&#125; T1140 : 验证子串 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入两个字符串，验证其中一个串是否为另一个串的子串。 【输入】输入两个字符串， 每个字符串占一行，长度不超过$200$且不含空格。 【输出】若第一个串$s_1$是第二个串$s_2$的子串，则输出(s1) is substring of (s2)； 否则，若第二个串$s_2$是第一个串$s_1$的子串，输出(s2) is substring of (s1)； 否则，输出No substring。 【输入样例】12abcdddncabca 【输出样例】1abc is substring of dddncabca 【答案&amp;代码】12345678910111213#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char s1[201],s2[201]; scanf("%s%s",s1,s2); if(strstr(s2,s1)!=NULL) printf("%s is substring of %s",s1,s2); else if(strstr(s1,s2)!=NULL) printf("%s is substring of %s",s2,s1); else printf("No substring"); return 0;&#125; T1141 : 删除单词后缀 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个单词，如果该单词以er、ly或者ing后缀结尾， 则删除该后缀（题目保证删除后缀后的单词长度不为$0$）， 否则不进行任何操作。 【输入】输入一行，包含一个单词（单词中间没有空格，每个单词最大长度为$32$）。 【输出】输出按照题目要求处理后的单词。 【输入样例】1referer 【输出样例】1refer 【答案&amp;代码】12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char a[32]; char *p; gets(a); p=a; if(strlen(a)&lt;4) printf("%s",a); else&#123; if(strcmp(p+strlen(a)-3,"ing")==0) a[strlen(a)-3]='\0'; p=a; if(strcmp(p+strlen(a)-2,"er")==0) a[strlen(a)-2]='\0'; p=a; if(strcmp(p+strlen(a)-2,"ly")==0) a[strlen(a)-2]='\0'; printf("%s",a); &#125; return 0;&#125; T1142 : 单词的长度 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入一行单词序列，相邻单词之间由$1$个或多个空格间隔，请对应地计算各个单词的长度。 注意:如果有标点符号（如连字符，逗号），标点符号算作与之相连的词的一部分。没有被空格间开的符号串，都算作单词。 【输入】一行单词序列，最少$1$个单词，最多$300$个单词，单词之间用至少$1$个空格间隔。单词序列总长度不超过$1000$。 【输出】依次输出对应单词的长度，之间以逗号间隔。 【输入样例】1She was born in 1990-01-02 and from Beijing city. 【输出样例】13,3,4,2,10,3,4,7,5 【答案&amp;代码】12345678910111213#include&lt;iostream&gt;#include&lt;string.h&gt;int main(void)&#123; char str[128]; bool flag=true; while(std::cin&gt;&gt;str)&#123; if(flag) std::cout&lt;&lt;strlen(str),flag=false; else std::cout&lt;&lt;','&lt;&lt;strlen(str); &#125; return 0;&#125; T1143 : 最长最短单词 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入$1$行句子（不多于$200$个单词，每个单词长度不超过$100$），只包含字母、空格和逗号。单词由至少一个连续的字母构成，空格和逗号都是单词间的间隔。 试输出第$1$个最长的单词和第$1$个最短单词。 【输入】一行句子。 【输出】第$1$行，第一个最长的单词。 第$2$行，第一个最短的单词。 【输入样例】1I am studying Programming language C in Peking University 【输出样例】12ProgrammingI 【答案&amp;代码】1234567891011121314151617181920212223242526272829303132333435363738394041#include "iostream"#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include "cstring"using namespace std;int main() &#123; char s[10000]; cin.getline(s, 10000); int len = 0; int Max = 0; char s1[201]; char result[201]; char ans[201]; int Min = 1 &lt;&lt; 30; for (int i = 0; s[i]; i++) &#123; if ((s[i] != ' ') &amp;&amp; (s[i] != ',')) &#123; int k = i; int j = 0; len = 0; for (; ((s[k] != ' ') &amp;&amp; (s[k] != ',') &amp;&amp; s[k]); k++, j++) &#123; s1[j] = s[k]; len++; i = k; &#125; if (len &gt; Max) &#123; s1[j] = '\0'; strcpy(result, s1); Max = len; &#125; if (len &lt; Min) &#123; s1[j] = '\0'; strcpy(ans, s1); Min = len; &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; T1144 : 单词翻转 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入一个句子（一行），将句子中的每一个单词翻转后输出。 【输入】只有一行，为一个字符串，不超过$500$个字符。单词之间以空格隔开。 【输出】翻转每一个单词后的字符串，单词之间的空格需与原文一致。 【输入样例】1hello world 【输出样例】1olleh dlrow 【答案&amp;代码】12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; char s[1000]; int len,position; int sum=0; int i,j; gets(s);//获取字符串s len=strlen(s);//求字符串长度 s[len]=' ';//末尾加一空格方便计算 for(i=0;i&lt;=len;i++) &#123; if(s[i]!=' ') sum++;//计算单词长度 else &#123; position=i;//记录单词末位置 for(j=1;j&lt;=sum;j++)//倒序输出 cout&lt;&lt;s[--position]; sum=0;//计数器归零 if(i!=len)//若不是自己加上的空格就输出空格 cout&lt;&lt;" "; &#125; &#125; cout&lt;&lt;endl; return 0;&#125; T1145 : 字符串p型编码 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个完全由数字字符（$0,1,…,9$）构成的字符串$str$，请写出$str$的$p$型编码串。例如：字符串122344111可被描述为1个1、2个2、1个3、2个4、3个1，因此我们说122344111的$p$型编码串为1122132431。 【输入】输入仅一行，包含字符串$str$。每一行字符串最多包含$1000$个数字字符。 【输出】输出该字符串对应的$p$型编码串。 【输入样例】1122344111 【输出样例】11122132431 【答案&amp;代码】12345678910111213141516#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char str[1001]; scanf("%s",str); int len=1; for (int i=0;i&lt;strlen(str)-1;i++) if (str[i]==str[i+1]) len+=1; else&#123; printf("%d%c",len,str[i]); len=1; &#125; printf("%d%c",len,str[strlen(str)-1]); return 0;&#125; T1146 : 判断字符串是否为回文 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入一个字符串，输出该字符串是否回文。回文是指顺读和倒读都一样的字符串。 【输入】输入为一行字符串（字符串中没有空白字符，字符串长度不超过$100$）。 【输出】如果字符串是回文，输出yes；否则，输出no。 【输入样例】1abcdedcba 【输出样例】1yes 【答案&amp;代码】12345678910111213#include&lt;cstdio&gt;#include&lt;cstring&gt;char str[256];int main(void)&#123; gets(str); for(int i=0,j=strlen(str)-1;i&lt;=j;i++,j--) if(str[i]!=str[j]) return puts("no"),0; puts("yes"); return 0;&#125; T1147 : 最高分数的学生姓名 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入学生的人数，然后再输入每位学生的分数和姓名，求获得最高分数的学生的姓名。 【输入】第一行输入一个正整数$N(N \leq 100)$，表示学生人数。接着输入$N$行，每行格式如下： 分数 姓名 分数是一个非负整数，且小于等于$100$； 姓名为一个连续的字符串，中间没有空格，长度不超过$20$。 数据保证最高分只有一位同学。 【输出】获得最高分数同学的姓名。 【输入样例】123456587 lilei99 hanmeimei97 lily96 lucy77 jim 【输出样例】1hanmeimei 【答案&amp;代码】123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;algorithm&gt;struct stu&#123; int fs; char name[21];&#125;;bool cmp(stu a,stu b)&#123; return a.fs&lt;b.fs;&#125;int main(void)&#123; int n; scanf("%d",&amp;n); stu st[n]; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;st[i].fs); scanf("%s",st[i].name); &#125; std::sort(st,st+n,cmp); printf("%s",st[n-1].name); return 0;&#125; T1148 : 连续出现的字符 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个字符串，在字符串中找到第一个连续出现至少$k$次的字符。 【输入】第一行包含一个正整数$k(1 \leq k \leq 1000)$，表示至少需要连续出现的次数。 第二行包含需要查找的字符串。字符串长度在$1$到$2500$之间，且不包含任何空白符。 【输出】若存在连续出现至少$k$次的字符，输出该字符；否则输出No。 【输入样例】123abcccaaab 【输出样例】1c 【答案&amp;代码】12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;int main(void)&#123; int k; scanf("%d",&amp;k); char str[2501]; std::cin&gt;&gt;str; if(k==1&amp;&amp;strlen(str)!=0)&#123; printf("%c",str[0]); return 0; &#125; for(int i=1,sum=1;i&lt;strlen(str);i++)&#123; if(str[i-1]==str[i]) sum+=1; else sum=1; if(sum&gt;=k)&#123; printf("%c",str[i]); return 0; &#125; &#125; printf("No"); return 0;&#125; T1149 : 最长单词2 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】一个以.结尾的简单英文句子，单词之间用空格分隔，没有缩写形式和其它特殊形式。 【输入】一个以.结尾的简单英文句子（长度不超过$500$），单词之间用空格分隔，没有缩写形式和其它特殊形式。 【输出】该句子中最长的单词。如果多于一个，则输出第一个。 【输入样例】1I am a student of Peking University. 【输出样例】1University 【答案&amp;代码】1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 500char s[N],maxword[N];int main(void)&#123; int len,maxlen=0; while(~scanf("%s",s))&#123; len=strlen(s); if(s[len-1]=='.') s[--len]='\0'; if(len&gt;maxlen) maxlen=len, strcpy(maxword,s); &#125; printf("%s",maxword); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>信息学奥赛一本通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息学奥赛一本通（C++版）第一部分 C++语言 第四章 循环结构的程序设计]]></title>
    <url>%2FSolution%2FYBT%2F1.4%2F</url>
    <content type="text"><![CDATA[信息学奥赛一本通（C++版）第一部分 C++语言 第四章 循环结构的程序设计 第一节 for语句T1059 : 求平均年龄 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】班上有学生若干名，给出每名学生的年龄（整数），求班上所有学生的平均年龄，保留到小数点后两位。 【输入】第一行有一个整数$n(1 \leq n \leq 100)$，表示学生的人数。其后$n$行每行有$1$个整数，表示每个学生的年龄，取值为$15$到$25$。 【输出】输出一行，该行包含一个浮点数，为要求的平均年龄，保留到小数点后两位。 【输入样例】12321817 【输出样例】117.5 【答案&amp;代码】12345678910111213141516#include&lt;cstdio&gt;//以上为头文件int n,temp;//以上为全局变量int main(void)&#123; register int i,sum=0; //以上为寄存器变量 scanf("%d",&amp;n); for(i=1;i&lt;=n;++i) scanf("%d",&amp;temp), sum+=temp; printf("%.2f\n",(double)sum/n); return 0;&#125; T1060 : 均值 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给出一组样本数据，包含$n$个浮点数，计算其均值，精确到小数点后$4$位。 【输入】输入有两行，第一行包含一个整数$n$（$n$小于$100$），代表样本容量；第二行包含$n$个绝对值不超过$1000$的浮点数，代表各个样本数据。 【输出】输出一行，包含一个浮点数，表示均值，精确到小数点后$4$位。 【输入样例】1221.0 3.0 【输出样例】12.0000 【答案&amp;代码】123456789101112131415161718#include&lt;cstdio&gt;//以上为头文件int n;double temp;//以上为全局变量int main(void)&#123; register int i; register double sum=0; //以上为寄存器变量 scanf("%d",&amp;n); for(i=1;i&lt;=n;++i) scanf("%lf",&amp;temp), sum+=temp; printf("%.4f\n",sum/n); return 0;&#125; T1061 : 求整数的和与均值 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】读入$n(1 \leq n \leq 10000)$个整数，求它们的和与均值。 【输入】输入第一行是一个整数$n$，表示有$n$个整数。 第$2-n+1$行每行包含$1$个整数。每个整数的绝对值均不超过$10000$。 【输出】输出一行，先输出和，再输出平均值(保留到小数点后$5$位)，两个数间用单个空格分隔。 【输入样例】123454344222343222 【输出样例】11131 282.75000 【答案&amp;代码】12345678910111213141516#include&lt;cstdio&gt;//以上为头文件int n,temp;//以上为全局变量int main(void)&#123; register int i,sum=0; //以上为寄存器变量 scanf("%d",&amp;n); for(i=1;i&lt;=n;++i) scanf("%d",&amp;temp), sum+=temp; printf("%d %.5f\n",sum,(double)sum/n); return 0;&#125; T1062 : 最高的分数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】孙老师讲授的《计算概论》这门课期中考试刚刚结束，他想知道考试中取得的最高分数。因为人数比较多，他觉得这件事情交给计算机来做比较方便。你能帮孙老师解决这个问题吗？ 【输入】输入两行，第一行为整数$n(1 \leq n&lt;100)$，表示参加这次考试的人数.第二行是这$n$个学生的成绩，相邻两个数之间用单个空格隔开。所有成绩均为$0$到$100$之间的整数。 【输出】输出一个整数，即最高的成绩。 【输入样例】12585 78 90 99 60 【输出样例】199 【答案&amp;代码】123456789101112131415161718#include&lt;cstdio&gt;//以上为头文件int n,temp;//以上为全局变量int main(void)&#123; register int i,MAX=-1; //以上为寄存器变量 scanf("%d",&amp;n); for(i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;temp); if(temp&gt;MAX) MAX=temp; &#125; printf("%d\n",MAX); return 0;&#125; T1063 : 最大跨度值 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个长度为$n$的非负整数序列，请计算序列的最大跨度值（最大跨度值$=$最大值减去最小值）。 【输入】一共$2$行，第一行为序列的个数$n(1 \leq n \leq 1000)$，第二行为序列的$n$个不超过$1000$的非负整数，整数之间以一个空格分隔。 【输出】输出一行，表示序列的最大跨度值。 【输入样例】1263 0 8 7 5 9 【输出样例】19 【答案&amp;代码】1234567891011121314151617181920#include&lt;cstdio&gt;//以上为头文件int n,temp;//以上为全局变量int main(void)&#123; register int i,MAX=-1,MIN=1001; //以上为寄存器变量 scanf("%d",&amp;n); for(i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;temp); if(temp&gt;MAX) MAX=temp; if(temp&lt;MIN) MIN=temp; &#125; printf("%d\n",MAX-MIN); return 0;&#125; T1064 : 奥运奖牌计数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】$2008$年北京奥运会，$A$国的运动员参与了$n$天的决赛项目$(1 \leq n \leq 17)$。现在要统计一下$A$国所获得的金、银、铜牌数目及总奖牌数。输入第$1$行是$A$国参与决赛项目的天数$n$，其后$n$行，每一行是该国某一天获得的金、银、铜牌数目。输出$4$个整数，为$A$国所获得的金、银、铜牌总数及总奖牌数。 【输入】输入$n+1$行，第$1$行是$A$国参与决赛项目的天数$n$，其后$n$行，每一行是该国某一天获得的金、银、铜牌数目，以一个空格分开。 【输出】输出$1$行，包括$4$个整数，为$A$国所获得的金、银、铜牌总数及总奖牌数，以一个空格分开。 【输入样例】123431 0 33 1 00 3 0 【输出样例】14 4 3 11 【答案&amp;代码】12345678910111213141516171819#include&lt;cstdio&gt;//以上为头文件int n,sum[4],temp[4];//以上为全局变量int main(void)&#123; register int i,j; //以上为寄存器变量 scanf("%d",&amp;n); for(i=1;i&lt;=n;++i) for(j=1;j&lt;=3;++j) scanf("%d",&amp;temp[j]), sum[j]+=temp[j]; for(i=1;i&lt;=3;++i) printf("%d ",sum[i]); printf("%d\n",sum[1]+sum[2]+sum[3]); return 0;&#125; T1065 : 奇数求和 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】计算非负整数$m$到$n$（包括$m$和$n$）之间的所有奇数的和，其中，$m$不大于$n$，且$n$不大于$300$。例如$m=3,n=12$，其和则为：$3+5+7+9+11=35$。 【输入】两个数$m$和$n$，两个数以一个空格分开，其中$0 \leq m \leq n \leq 300$。 【输出】输出一行，包含一个整数，表示$m$到$n$（包括$m$和$n$）之间的所有奇数的和。 【输入样例】17 15 【输出样例】155 【答案&amp;代码】12345678910111213141516#include&lt;cstdio&gt;//以上为头文件int m,n;//以上为全局变量int main(void)&#123; register int sum=0; //以上为寄存器变量 scanf("%d%d",&amp;m,&amp;n); for(;m&lt;=n;++m) if(m&amp;1) sum+=m; printf("%d\n",sum); return 0;&#125; T1066 : 满足条件的数累加 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】将正整数$m$和$n$之间（包括$m$和$n$）能被$17$整除的数累加，其中$0 &lt; m &lt; n &lt; 1000$。 【输入】一行，包含两个整数$m$和$n$，其间，以一个空格间隔。 【输出】输出一行，包行一个整数，表示累加的结果。 【输入样例】150 85 【输出样例】1204 【答案&amp;代码】12345678910111213141516#include&lt;cstdio&gt;//以上为头文件int m,n;//以上为全局变量int main(void)&#123; register int sum=0; //以上为寄存器变量 scanf("%d%d",&amp;m,&amp;n); for(;m&lt;=n;++m) if(m%17==0) sum+=m; printf("%d\n",sum); return 0;&#125; T1067 : 整数的个数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定$k(1 &lt; k 100)$个正整数，其中每个数都是大于等于$1$，小于等于$10$的数。写程序计算给定的$k$个正整数中，$1,5,10$出现的次数。 【输入】输入有两行：第一行包含一个正整数$k$，第二行包含$k$个正整数，每两个正整数用一个空格分开。 【输出】输出有三行，第一行为$1$出现的次数，，第二行为$5$出现的次数，第三行为$10$出现的次数。 【输入样例】1251 5 8 10 5 【输出样例】123121 【答案&amp;代码】123456789101112131415161718#include&lt;stdio.h&gt;int main(void)&#123; int k; scanf("%d",&amp;k); int sum[3]=&#123;0&#125;; for(int i=0;i&lt;k;i++)&#123; int temp; scanf("%d",&amp;temp); if(temp==1) sum[0]+=1; else if(temp==5) sum[1]+=1; else if(temp==10) sum[2]+=1; &#125; printf("%d\n%d\n%d\n",sum[0],sum[1],sum[2]); return 0;&#125; T1068 : 与指定数字相同的数的个数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输出一个整数序列中与指定数字相同的数的个数。输入包含$2$行：第$1$行为$N$和$m$，表示整数序列的长度$(N \leq 100)$和指定的数字；第$2$行为$N$个整数，整数之间以一个空格分开。输出为$N$个数中与$m$相同的数的个数。 【输入】第$1$行为$N$和$m$，表示整数序列的长度$(N \leq 100)$和指定的数字， 中间用一个空格分开； 第$2$行为$N$个整数，整数之间以一个空格分开。 【输出】输出为$N$个数中与$m$相同的数的个数。 【输入样例】123 22 3 2 【输出样例】12 【答案&amp;代码】1234567891011121314#include&lt;cstdio&gt;int main(void)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int sum=0; for(int i=0;i&lt;n;i++)&#123; int temp; scanf("%d",&amp;temp); if(temp==m) sum+=1; &#125; printf("%d\n",sum); return 0;&#125; T1069 : 乘方计算 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给出一个整数$a$和一个正整数$n(-1000000 \leq a \leq 1000000,1 \leq n \leq 10000)$，求乘方$a^{n}$，即乘方结果。最终结果的绝对值不超过$1000000$。 【输入】一行，包含两个整数$a$和$n$。$-1000000 \leq a \leq 1000000,1 \leq n \leq 10000$。 【输出】一个整数，即乘方结果。题目保证最终结果的绝对值不超过$1000000$。 【输入样例】12 3 【输出样例】18 【答案&amp;代码】12345678#include&lt;cstdio&gt;#include&lt;cmath&gt;int main(void)&#123; int a,n; scanf("%d%d",&amp;a,&amp;n); printf("%d\n",(int)pow(a,n)); return 0;&#125; T1070 : 人口增长 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】我国现有$x$亿人口，按照每年$0.1\%$的增长速度，$n$年后将有多少人？保留小数点后四位。 【输入】一行，包含两个整数$x$和$n$，分别是人口基数和年数，以单个空格分隔。 【输出】输出最后的人口数，以亿为单位，保留到小数点后四位。$1 \leq x \leq 100,1 \leq n \leq 100$。 【输入样例】113 10 【输出样例】113.1306 【答案&amp;代码】12345678#include&lt;cstdio&gt;#include&lt;cmath&gt;int main(void)&#123; int a,n; scanf("%d%d",&amp;a,&amp;n); printf("%.4f\n",pow(1.001,n)*a); return 0;&#125; T1071 : 菲波那契数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】菲波那契数列是指这样的数列：数列的第一个和第二个数都为$1$，接下来每个数都等于前面$2$个数之和。给出一个正整数$k$，要求菲波那契数列中第$k$个数是多少。 【输入】输入一行，包含一个正整数$k(1 \leq k \leq 46)$。 【输出】输出一行，包含一个正整数，表示菲波那契数列中第$k$个数的大小。 【输入样例】119 【输出样例】14181 【答案&amp;代码】1234567891011#include&lt;cstdio&gt;int main(void)&#123; int k; scanf("%d",&amp;k); int num[k]; num[0]=num[1]=1; for(int i=2;i&lt;k;i++) num[i]=num[i-1]+num[i-2]; printf("%d\n",num[k-1]); return 0;&#125; T1072 : 鸡尾酒疗法 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】鸡尾酒疗法，指高效抗逆转录病毒治疗。人们在鸡尾酒疗法的基础上又提出了很多种改进的疗法。为了验证这些治疗方法是否在疗效上比鸡尾酒疗法更好，可用通过临床对照实验的方式进行。假设鸡尾酒疗法的有效率为$x$，新疗法的有效率为$y$，如果$y-x$大于$5\%$，则效果更好，如果$x-y$大于$5\%$，则效果更差，否则称为效果差不多。下面给出$n$组临床对照实验，其中第一组采用鸡尾酒疗法，其他$n-1$组为各种不同的改进疗法。请写程序判定各种改进疗法效果如何。 【输入】第一行为整数$n(1 &lt; n \leq 20)$；其余$n$行每行两个整数，第一个整数是临床实验的总病例数（小于等于$10000$），第二个疗效有效的病例数。这$n$行数据中，第一行为鸡尾酒疗法的数据，其余各行为各种改进疗法的数据。 【输出】有$n-1$行输出，分别表示对应改进疗法的效果：如果效果更好，输出better；如果效果更差，输出worse；否则输出same。 【输入样例】1234565125 99 112 89145 9999 97123 98 【输出样例】1234sameworsebettersame 【答案&amp;代码】1234567891011121314151617181920#include&lt;stdio.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); int jw1,jw2; scanf("%d%d",&amp;jw1,&amp;jw2); double x=(double)jw2/jw1; for(int i=0;i&lt;n-1;i++)&#123; int temp1,temp2; scanf("%d%d",&amp;temp1,&amp;temp2); double y=(double)temp2/temp1; if(y-x&gt;0.05) printf("better\n"); else if(x-y&gt;0.05) printf("worse\n"); else printf("same\n"); &#125; return 0;&#125; T1073 : 救援 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】救生船从大本营出发，营救若干屋顶上的人回到大本营，屋顶数目以及每个屋顶的坐标和人数都将由输入决定，求出所有人都到达大本营并登陆所用的时间。 在直角坐标系的原点是大本营，救生船每次从大本营出发，救了人之后将人送回大本营。坐标系中的点代表屋顶，每个屋顶由其位置坐标和其上的人数表示。救生船每次从大本营出发，以速度$50m/min$驶向下一个屋顶，达到一个屋顶后，救下其上的所有人，每人上船$1$分钟，船原路返回，达到大本营，每人下船$0.5$分钟。假设原点与任意一个屋顶的连线不穿过其它屋顶。 【输入】第一行，一个整数，表示屋顶数$n$。接下来依次有$n$行输入，每一行上包含两个表示屋顶相对于大本营的平面坐标位置的实数（单位是$m$）、一个表示人数的整数。 【输出】救援需要的总时间，精确到分钟（向上取整）。 【输入样例】12130 40 3 【输出样例】17 【答案&amp;代码】1234567891011121314#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); double sum=0; for(int i=0;i&lt;n;i++)&#123; double x,y,k; scanf("%lf%lf%lf",&amp;x,&amp;y,&amp;k); sum+=sqrt(x*x+y*y)*2/50+k*1.5; &#125; printf("%.0f",ceil(sum)); return 0;&#125; T1074 : 津津的储蓄计划 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】津津的零花钱一直都是自己管理。每个月的月初妈妈给津津$300$元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。 为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上$20\%$还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于$100$元或恰好$100$元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。 例如$11$月初津津手中还有$83$元，妈妈给了津津$300$元。津津预计$11$月的花销是$180$元，那么她就会在妈妈那里存$200$元，自己留下$183$元。到了$11$月月末，津津手中会剩下$3$元钱。 现在请你根据$2004$年$1$月到$12$月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到$2004$年年末，妈妈将津津平常存的钱加上$20\%$还给津津之后，津津手中会有多少钱。 【输入】包括$12$行数据，每行包含一个小于$350$的非负整数，分别表示$1$月到$12$月津津的预算。 【输出】只包含一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出$-X$，$X$表示出现这种情况的第一个月；否则输出到$2004$年年末津津手中会有多少钱。 【输入样例】12345678910111229023028020030017034050 90 80 20060 【输出样例】1-7 【答案&amp;代码】12345678910111213141516171819#include&lt;stdio.h&gt;int main(void)&#123; int leave=0,need,sum=0; for(int i=1;i&lt;=12;i++)&#123; leave+=300; scanf("%d",&amp;need); leave-=need; if(leave&gt;=0)&#123; sum+=leave/100; leave-=(int)(leave/100)*100; &#125; else&#123; printf("-%d",i); return 0; &#125; &#125; printf("%d",sum*120+leave); return 0; &#125; T1075 : 药房管理 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】随着信息技术的蓬勃发展，医疗信息化已经成为医院建设中必不可少的一部分。计算机可以很好地辅助医院管理医生信息、病人信息、药品信息等海量数据，使工作人员能够从这些机械的工作中解放出来，将更多精力投入真正的医疗过程中，从而极大地提高了医院整体的工作效率。 对药品的管理是其中的一项重要内容。现在药房的管理员希望使用计算机来帮助他管理。假设对于任意一种药品，每天开始工作时的库存总量已知，并且一天之内不会通过进货的方式增加。每天会有很多病人前来取药，每个病人希望取走不同数量的药品。如果病人需要的数量超过了当时的库存量，药房会拒绝该病人的请求。管理员希望知道每天会有多少病人没有取上药。 【输入】共$3$行,第一行是每天开始时的药品总量$m$。 第二行是这一天取药的人数$n(0 &lt; n \leq 100)$。 第三行共有$n$个数，分别记录了每个病人希望取走的药品数量（按照时间先后的顺序）。 【输出】只有$1$行，为这一天没有取上药品的人数。 【输入样例】12330610 5 20 6 7 8 【输出样例】12 【答案&amp;代码】12345678910111213141516#include&lt;stdio.h&gt;int main(void)&#123; int m,n; scanf("%d%d",&amp;m,&amp;n); int sum=0; for(int i=0;i&lt;n;i++)&#123; int temp; scanf("%d",&amp;temp); if(temp&gt;m) sum+=1; else m-=temp; &#125; printf("%d",sum); return 0; &#125; T1076 : 正常血压 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】监护室每小时测量一次病人的血压，若收缩压在$90-140$之间并且舒张压在$60-90$之间（包含端点值）则称之为正常，现给出某病人若干次测量的血压值，计算病人保持正常血压的最长小时数。 【输入】第一行为一个正整数$n(n&lt;100)$，其后有$n$行，每行$2$个正整数，分别为一次测量的收缩压和舒张压。 【输出】输出仅一行，血压连续正常的最长小时数。 【输入样例】123454100 8090 50120 60140 90 【输出样例】12 【答案&amp;代码】123456789101112131415161718#include&lt;stdio.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); int max=-1; for(int i=0,sum=0;i&lt;n;i++)&#123; int ss,sz; scanf("%d%d",&amp;ss,&amp;sz); if(90&lt;=ss&amp;&amp;ss&lt;=140&amp;&amp;60&lt;=sz&amp;&amp;sz&lt;=90) sum+=1; else sum=0; if(sum&gt;max) max=sum; &#125; printf("%d",max); return 0; &#125; T1077 : 统计满足条件的4位数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定若干个四位数，求出其中满足以下条件的数的个数：个位数上的数字减去千位数上的数字，再减去百位数上的数字，再减去十位数上的数字的结果大于零。 【输入】输入为两行，第一行为四位数的个数$n$，第二行为$n(n \leq 100)$个的四位数。 【输出】输出为一行，包含一个整数，表示满足条件的四位数的个数。 【输入样例】1251234 1349 6119 2123 5017 【输出样例】13 【答案&amp;代码】123456789101112131415#include&lt;stdio.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); int sum=0; for(int i=0;i&lt;n;i++)&#123; int temp; scanf("%d",&amp;temp); int qw=temp/1000,bw=(temp/100)%10,sw=(temp/10)%10,gw=temp%10; if((gw-qw-bw-sw)&gt;0) sum+=1; &#125; printf("%d",sum); return 0; &#125; T1078 : 求分数序列和 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】有一个分数序列$\frac{q_1}{p_1},\frac{q_2}{p_2},\frac{q_3}{p_3},\frac{q_4}{p_4},\frac{q_5}{p_5},…$，其中$q_{i+1}=q_i+p_i,p_{i+1}=q_i,p_1=1,q_1=2$。求这个分数序列的前$n$项之和。 【输入】输入有一行，包含一个正整数$n(n \leq 30)$。 【输出】输出有一行，包含一个浮点数，表示分数序列前$n$项的和，精确到小数点后$4$位。 【输入样例】12 【输出样例】13.5000 【答案&amp;代码】12345678910111213141516#include&lt;stdio.h&gt;int f(int n)&#123; if(n==1||n==0) return 1; else return f(n-1)+f(n-2);&#125;int main(void)&#123; int n; scanf("%d",&amp;n); double sum=0; for(int i=1;i&lt;=n;i++) sum+=(double)f(i+1)/f(i); printf("%.4f",sum); return 0; &#125; T1079 : 求分数序列和 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】编写程序，输入$n$的值，求$$\sum^n_{i=1}(-1)^{i-1}\frac{1}{i}$$的值。 【输入】输入一个正整数$n(1 \leq n \leq 1000)$。 【输出】输出一个实数，为表达式的值，保留到小数点后四位。 【输入样例】12 【输出样例】10.5000 【答案&amp;代码】1234567891011#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); double sum=0; for(int i=1;i&lt;=n;i++) sum+=pow(-1,i-1)*1.0/i; printf("%.4f",sum); return 0; &#125; T1080 : 余数相同问题 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】已知三个正整数$a,b,c$。现有一个大于$1$的整数$x$，将其作为除数分别除$a,b,c$，得到的余数相同。 请问满足上述条件的$x$的最小值是多少？数据保证$x$有解。 【输入】一行，三个不大于1000000的正整数$a,b,c$，两个整数之间用一个空格隔开。 【输出】一个整数，即满足条件的$x$的最小值。 【输入样例】1300 262 205 【输出样例】119 【答案&amp;代码】1234567891011#include&lt;stdio.h&gt;int main(void)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); for(int i=2;;i++) if(a%i==b%i&amp;&amp;b%i==c%i)&#123; printf("%d",i); return 0; &#125; return 0; &#125; T1081 : 分苹果 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】把一堆苹果分给$n$个小朋友，要使每个人都能拿到苹果，而且每个人拿到的苹果数都不同的话，这堆苹果至少应该有多少个？ 【输入】一个不大于$1000$的正整数$n$，代表小朋友人数。 【输出】一个整数，表示满足条件的最少苹果个数。 【输入样例】18 【输出样例】136 【答案&amp;代码】1234567#include&lt;stdio.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); printf("%d",(n*n+n)/2); return 0; &#125; T1082 : 求小数的某一位 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】分数$\frac{a}{b}$化为小数后，小数点后第$n$位的数字是多少？ 【输入】三个正整数$a,b,n$，相邻两个数之间用单个空格隔开。$0 &lt; a &lt; b &lt; 100,1 \leq n \leq 10000$。 【输出】一个数字。 【输入样例】11 2 1 【输出样例】15 【答案&amp;代码】123456789101112#include&lt;stdio.h&gt;int main(void)&#123; int a,b,n; scanf("%d%d%d",&amp;a,&amp;b,&amp;n); if(a&gt;b) a%=b; int ans=0; for(int i=1;i&lt;=n;i++) ans=10*a/b,a=10*a-b*ans; printf("%d",ans); return 0;&#125; T1083 : 计算星期几 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】假设今天是星期日，那么过$a^b$天之后是星期几？ 【输入】两个正整数$a,b$，中间用单个空格隔开。$0 &lt; a \leq 100,0 &lt; b \leq 10000$。 【输出】一个字符串，代表过$a^b$天之后是星期几。 其中，Monday是星期一，Tuesday是星期二，Wednesday是星期三，Thursday是星期四，Friday是星期五，Saturday是星期六，Sunday是星期日。 【输入样例】13 2000 【输出样例】1Tuesday 【答案&amp;代码】12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); int c=1; for(int i=1;i&lt;=b;i++) c*=a,c%=7; switch(c)&#123; case 0:printf("Sunday");break; case 1:printf("Monday");break; case 2:printf("Tuesday");break; case 3:printf("Wednesday");break; case 4:printf("Thursday");break; case 5:printf("Friday");break; case 6:printf("Saturday");break; &#125; return 0; &#125; T1084 : 幂的末尾 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】幂$a^b$的末$3$位数是多少？ 【输入】两个正整数$a,b$。$1 \leq a \leq 100,1 \leq b \leq 10000$。 【输出】从高位到低位输出幂的末三位数字，中间无分隔符。若幂本身不足三位，在前面补零。 【输入样例】17 2011 【输出样例】1743 【答案&amp;代码】1234567891011#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); int c=1; for(int i=1;i&lt;=b;i++) c*=a,c%=1000; printf("%.3d",c); return 0; &#125; 第二节 while语句T1085 : 球弹跳高度的计算 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】一球从某一高度$h$落下（单位：米），每次落地后反跳回原来高度的一半，再落下。编程计算气球在第$10$次落地时，共经过多少米? 第$10$次反弹多高？ 输出包含两行，第$1$行：到球第$10$次落地时，一共经过的米数。第$2$行：第$10$次弹跳的高度。 【输入】输入一个整数$h$，表示球的初始高度。 【输出】第$1$行：到球第$10$次落地时，一共经过的米数。 第$2$行：第$10$次弹跳的高度。 注意：结果可能是实数，结果用double类型保存。 提示：输出时不需要对精度特殊控制，用cout &lt;&lt; ANSWER，或者printf(&quot;%g&quot;, ANSWER)即可。 【输入样例】120 【输出样例】1259.92190.0195312 【答案&amp;代码】12345678910111213141516171819#include&lt;stdio.h&gt;double fun1(int n,double h)&#123; if(n==1)&#123; return h; &#125; return h+fun1(n-1,h/2);&#125;double fun2(int n,double h)&#123; if(n==1) return h/2; else return fun2(n-1,h/2);&#125;int main(void)&#123; double h; scanf("%lf",&amp;h); printf("%g\n%g",fun1(10,h)*2-h,fun2(10,h)); return 0;&#125; T1086 : 角谷猜想 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】谓角谷猜想，是指对于任意一个正整数，如果是奇数，则乘$3$加$1$，如果是偶数，则除以$2$，得到的结果再按照上述规则重复处理，最终总能够得到$1$。如，假定初始整数为$5$，计算过程分别为$16,8,4,2,1$。程序要求输入一个整数，将经过处理得到$1$的过程输出来。 【输入】一个正整数$N(N \leq 2,000,000)$。 【输出】从输入整数到$1$的步骤，每一步为一行，每一部中描述计算过程。最后一行输出End。如果输入为$1$，直接输出End。 【输入样例】15 【输出样例】1234565*3+1=1616/2=88/2=44/2=22/2=1End 【答案&amp;代码】1234567891011121314#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); for(;n!=1;)&#123; if(n%2==1) printf("%d*3+1=%d\n",n,n*3+1),n=3*n+1; else printf("%d/2=%d\n",n,n/2),n/=2; &#125; printf("End"); return 0; &#125; T1087 : 级数求和 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】已知： $$S_n=\sum^n_{i=1}\frac{1}{i}$$ 显然对于任意一个整数$k$，当$n$足够大的时候，$S_n$大于$k$。现给出一个整数$k(1 \leq k \leq 15)$，要求计算出一个最小的$n$，使得$S_n&gt;k$。 【输入】一个整数$k$。 【输出】一个整数$n$。 【输入样例】11 【输出样例】12 【答案&amp;代码】1234567891011121314#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int k; scanf("%d",&amp;k); double S=0; for(int i=1;;i++)&#123; S+=1.0/i; if(S&gt;k)&#123; printf("%d",i);return 0; &#125; &#125; return 0; &#125; T1088 : 分离整数的各个数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个整数$n(1 \leq n \leq 100000000)$，要求从个位开始分离出它的每一位数字。从个位开始按照从低位到高位的顺序依次输出每一位数字。 【输入】输入一个整数，整数在$1$到$100000000$之间。 【输出】从个位开始按照从低位到高位的顺序依次输出每一位数字。数字之间以一个空格分开。 【输入样例】1123 【输出样例】13 2 1 【答案&amp;代码】1234567891011#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; int num; scanf("%d",&amp;num); char str[10]; sprintf(str,"%d",num); for(int i=strlen(str)-1;i&gt;=0;i--) printf("%c ",str[i]); return 0; &#125; T1089 : 数字反转 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个整数，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零，例如输入$-380$，反转后得到的新数为$-83$。 【输入】输入共$1$行，一个整数$N$。 $-1,000,000,000 \leq N \leq 1,000,000,000$。 【输出】从个位开始按照从低位到高位的顺序依次输出每一位数字。数字之间以一个空格分开。 【输入样例】1123 【输出样例】1321 【答案&amp;代码】12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; int num; scanf("%d",&amp;num); char str[16]; sprintf(str,"%d",num); for(int i=0;i&lt;strlen(str)/2;i++)&#123; char temp=str[i]; str[i]=str[strlen(str)-i-1]; str[strlen(str)-i-1]=temp; &#125; if(num&lt;0) printf("-"); sscanf(str,"%d",&amp;num); printf("%d",num); return 0;&#125; T1090 : 含k个3的数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入两个正整数$m$和$k$，其中$1 &lt; m &lt; 100000 , 1 &lt; k &lt; 5$ ，判断$m$能否被$19$整除，且恰好含有$k$个$3$，如果满足条件，则输出YES，否则，输出NO。 例如，输入：43833 3，满足条件，输出YES。如果输入：39331 3，尽管有$3$个$3$，但不能被$19$整除，也不满足条件，应输出NO。 【输入】$m$和$k$的值，中间用单个空格间隔。 【输出】满足条件时输出YES，不满足时输出NO。 【输入样例】143833 3 【输出样例】1YES 【答案&amp;代码】1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; int num,k; scanf("%d%d",&amp;num,&amp;k); char str[16]; sprintf(str,"%d",num); int sum=0; for(int i=0;i&lt;strlen(str);i++) if(str[i]=='3') sum+=1; if(sum==k&amp;&amp;num%19==0) printf("YES"); else printf("NO"); return 0;&#125; 第三节 do-while语句T1085 : 球弹跳高度的计算 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】一球从某一高度$h$落下（单位：米），每次落地后反跳回原来高度的一半，再落下。编程计算气球在第$10$次落地时，共经过多少米? 第$10$次反弹多高？ 输出包含两行，第$1$行：到球第$10$次落地时，一共经过的米数。第$2$行：第$10$次弹跳的高度。 【输入】输入一个整数$h$，表示球的初始高度。 【输出】第$1$行：到球第$10$次落地时，一共经过的米数。 第$2$行：第$10$次弹跳的高度。 注意：结果可能是实数，结果用double类型保存。 提示：输出时不需要对精度特殊控制，用cout &lt;&lt; ANSWER，或者printf(&quot;%g&quot;, ANSWER)即可。 【输入样例】120 【输出样例】1259.92190.0195312 【答案&amp;代码】123456789101112131415161718#include&lt;stdio.h&gt;double fun1(int n,double h)&#123; if(n==1) return h; return h+fun1(n-1,h/2);&#125;double fun2(int n,double h)&#123; if(n==1) return h/2; else return fun2(n-1,h/2);&#125;int main(void)&#123; double h; scanf("%lf",&amp;h); printf("%g\n%g",fun1(10,h)*2-h,fun2(10,h)); return 0;&#125; T1086 : 角谷猜想 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】谓角谷猜想，是指对于任意一个正整数，如果是奇数，则乘$3$加$1$，如果是偶数，则除以$2$，得到的结果再按照上述规则重复处理，最终总能够得到$1$。如，假定初始整数为$5$，计算过程分别为$16,8,4,2,1$。程序要求输入一个整数，将经过处理得到$1$的过程输出来。 【输入】一个正整数$N(N \leq 2,000,000)$。 【输出】从输入整数到$1$的步骤，每一步为一行，每一部中描述计算过程。最后一行输出End。如果输入为$1$，直接输出End。 【输入样例】15 【输出样例】1234565*3+1=1616/2=88/2=44/2=22/2=1End 【答案&amp;代码】1234567891011121314#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); for(;n!=1;)&#123; if(n%2==1) printf("%d*3+1=%d\n",n,n*3+1),n=3*n+1; else printf("%d/2=%d\n",n,n/2),n/=2; &#125; printf("End"); return 0; &#125; T1087 : 级数求和 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】已知： $$S_n=\sum^n_{i=1}\frac{1}{i}$$ 显然对于任意一个整数$k$，当$n$足够大的时候，$S_n$大于$k$。现给出一个整数$k(1 \leq k \leq 15)$，要求计算出一个最小的$n$，使得$S_n&gt;k$。 【输入】一个整数$k$。 【输出】一个整数$n$。 【输入样例】11 【输出样例】12 【答案&amp;代码】1234567891011121314#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int k; scanf("%d",&amp;k); double S=0; for(int i=1;;i++)&#123; S+=1.0/i; if(S&gt;k)&#123; printf("%d",i);return 0; &#125; &#125; return 0; &#125; T1088 : 分离整数的各个数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个整数$n(1 \leq n \leq 100000000)$，要求从个位开始分离出它的每一位数字。从个位开始按照从低位到高位的顺序依次输出每一位数字。 【输入】输入一个整数，整数在$1$到$100000000$之间。 【输出】从个位开始按照从低位到高位的顺序依次输出每一位数字。数字之间以一个空格分开。 【输入样例】1123 【输出样例】13 2 1 【答案&amp;代码】1234567891011#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; int num; scanf("%d",&amp;num); char str[10]; sprintf(str,"%d",num); for(int i=strlen(str)-1;i&gt;=0;i--) printf("%c ",str[i]); return 0; &#125; T1089 : 数字反转 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个整数，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零，例如输入$-380$，反转后得到的新数为$-83$。 【输入】输入共$1$行，一个整数$N$。 $-1,000,000,000 \leq N \leq 1,000,000,000$。 【输出】从个位开始按照从低位到高位的顺序依次输出每一位数字。数字之间以一个空格分开。 【输入样例】1123 【输出样例】1321 【答案&amp;代码】12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; int num; scanf("%d",&amp;num); char str[16]; sprintf(str,"%d",num); for(int i=0;i&lt;strlen(str)/2;i++)&#123; char temp=str[i]; str[i]=str[strlen(str)-i-1]; str[strlen(str)-i-1]=temp; &#125; if(num&lt;0) printf("-"); sscanf(str,"%d",&amp;num); printf("%d",num); return 0;&#125; T1090 : 含k个3的数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入两个正整数$m$和$k$，其中$1 &lt; m &lt; 100000 , 1 &lt; k &lt; 5$ ，判断$m$能否被$19$整除，且恰好含有$k$个$3$，如果满足条件，则输出YES，否则，输出NO。 例如，输入：43833 3，满足条件，输出YES。如果输入：39331 3，尽管有$3$个$3$，但不能被$19$整除，也不满足条件，应输出NO。 【输入】$m$和$k$的值，中间用单个空格间隔。 【输出】满足条件时输出YES，不满足时输出NO。 【输入样例】143833 3 【输出样例】1YES 【答案&amp;代码】1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; int num,k; scanf("%d%d",&amp;num,&amp;k); char str[16]; sprintf(str,"%d",num); int sum=0; for(int i=0;i&lt;strlen(str);i++) if(str[i]=='3') sum+=1; if(sum==k&amp;&amp;num%19==0) printf("YES"); else printf("NO"); return 0;&#125; 第四节 循环嵌套T1091 : 求阶乘的和 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定正整数$n$，求不大于$n$的正整数的阶乘的和，即 $$\sum^{n}_{i=1}\prod^{i}_{j=1}j$$ 输出阶乘的和。 【输入】输入有一行，包含一个正整数$n(1 &lt; n &lt; 12)$。 【输出】输出有一行：阶乘的和。 【输入样例】15 【输出样例】1153 【答案&amp;代码】123456789101112#include&lt;stdio.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); int sum=0; for(int i=1,temp=1;i&lt;=n;i++)&#123; sum+=temp*i; temp*=i; &#125; printf("%d",sum); return 0;&#125; T1092 : 求出e的值 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】利用公式$$e=\sum^{\infty}_{i=0}\frac{1}{i!}$$ 求$e$的值，要求保留小数点后$10$位。 【输入】输入只有一行，该行包含一个整数$n(2 \leq n \leq 15)$，表示计算$e$时累加到$\frac{1}{n!}$。 【输出】输出只有一行，该行包含计算出来的$e$的值，要求打印小数点后$10$位。 【输入样例】110 【输出样例】12.7182818011 【答案&amp;代码】1234567891011121314151617#include&lt;stdio.h&gt;unsigned long long f(int n)&#123; unsigned long long result=1; for(int i=1;i&lt;=n;i++) result*=i; return result;&#125;int main(void)&#123; int n; scanf("%d",&amp;n); double e=1; for(int i=1;i&lt;=n;i++)&#123; e+=1.0/f(i); &#125; printf("%.10f",e); return 0;&#125; T1093 : 计算多项式的值 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】假定多项式的形式为 $$\sum^{n}_{i=0}{x^{i}}=x^{n}+x^{n-1}+…+x+1$$ 请计算给定单精度浮点数$x$和正整数$n$值的情况下这个多项式的值。$x$在float范围内，$n \leq 1000000$。多项式的值精确到小数点后两位，保证最终结果在float范围内。 【输入】输入仅一行，包括$x$和$n$，用单个空格隔开。$x$在float范围内，$n \leq 1000000$。 【输出】输出一个实数，即多项式的值，精确到小数点后两位。保证最终结果在float范围内。 【输入样例】12.0 4 【输出样例】131.00 【答案&amp;代码】123456789101112#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int n; double x; scanf("%lf%d",&amp;x,&amp;n); double sum=1; for(int i=1;i&lt;=n;i++) sum+=pow(x,i); printf("%.2f",sum); return 0;&#125; T1094 : 与7无关的数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】一个正整数，如果它能被$7$整除，或者它的十进制表示法中某一位上的数字为$7$，则称其为与$7$相关的数。现求所有小于等于$n(n&lt;100)$与$7$无关的正整数的平方和。 【输入】输入为一行,正整数$n(n&lt;100)$。 【输出】输出一行，包含一个整数，即小于等于$n$的所有与$7$无关的正整数的平方和。 【输入样例】121 【输出样例】12336 【答案&amp;代码】1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;bool f(int n)&#123; if(n%7==0) return false; char str[16]; sprintf(str,"%d",n); for(int i=0;i&lt;strlen(str);i++) if(str[i]=='7') return false; return true; &#125;int main(void)&#123; int n; scanf("%d",&amp;n); int sum=0; for(int i=1;i&lt;=n;i++) if(f(i)) sum+=i*i; printf("%d",sum); return 0;&#125; T1095 : 数1的个数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定一个十进制正整数$n(1 \leq n \leq 10000)$，写下从$1$到$n$的所有整数，然后数一下其中出现的数字$1$的个数。 例如当$n=2$时，写下$1,2$。这样只出现了$1$个$1$；当$n=12$时，写下$1,2,3,4,5,6,7,8,9,10,11,12$。这样出现了$5$个$1$。 【输入】正整数$n(1 \leq n \leq 10000)$。 【输出】一个正整数，即$1$的个数。 【输入样例】112 【输出样例】15 【答案&amp;代码】123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;int f(int n)&#123; char str[16]; int sum=0; sprintf(str,"%d",n); for(int i=0;i&lt;strlen(str);i++) if(str[i]=='1') sum+=1; return sum; &#125;int main(void)&#123; int n; scanf("%d",&amp;n); int sum=0; for(int i=1;i&lt;=n;i++) sum+=f(i); printf("%d",sum); return 0;&#125; T1096 : 数字统计 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】请统计某个给定范围$[L,R]$的所有整数中，数字$2$出现的次数。 比如给定范围$[2,22]$，数字$2$在数$2$中出现了$1$次，在数$12$中出现$1$次，在数$20$中出现$1$次，在数$21$中出现$1$次，在数$22$中出现$2$次，所以数字$2$在该范围内一共出现了$6$次。 【输入】输入共$1$行，为两个正整数$L$和$R$，之间用一个空格隔开。 【输出】输出共$1$行，表示数字$2$出现的次数。 【输入样例】12 22 【输出样例】16 【答案&amp;代码】123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;int f(int n)&#123; char str[16]; int sum=0; sprintf(str,"%d",n); for(int i=0;i&lt;strlen(str);i++) if(str[i]=='2') sum+=1; return sum; &#125;int main(void)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int sum=0; for(int i=l;i&lt;=r;i++) sum+=f(i); printf("%d",sum); return 0;&#125; T1097 : 画矩形 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】根据参数，画出矩形。输入四个参数：前两个参数为整数，依次代表矩形的高和宽（高不少于$3$行不多于$10$行，宽不少于$5$列不多于$10$列）；第三个参数是一个字符，表示用来画图的矩形符号；第四个参数为$1$或$0$，$0$代表空心，$1$代表实心。 【输入】输入一行，包括四个参数：前两个参数为整数，依次代表矩形的高和宽（高不少于$3$行不多于$10$行，宽不少于$5$列不多于$10$列）；第三个参数是一个字符，表示用来画图的矩形符号；第四个参数为$1$或$0$，$0$代表空心，$1$代表实心。 【输出】输出画出的图形。 【输入样例】17 7 @ 0 【输出样例】1234567@@@@@@@@ @@ @@ @@ @@ @@@@@@@@ 【答案&amp;代码】12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(void)&#123; int h,d,x,i,j; char a; scanf("%d %d %c %d",&amp;h,&amp;d,&amp;a,&amp;x); if(x==1) for(int i=1;i&lt;=h;i++,putchar('\n')) for(int j=1;j&lt;=d;j++) printf("%c",a); if(x==0) for(int i=1;i&lt;=h;i++,putchar('\n')) if(i==1||i==h) for(int j=1;j&lt;=d;j++) printf("%c",a); else for(int j=1;j&lt;=d;j++) if(j==1||j==d) printf("%c",a); else putchar(' '); return 0;&#125; T1098 : 质因数分解 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】已知正整数$n$是两个不同的质数的乘积，试求出较大的那个质数。 【输入】输入只有一行，包含一个正整数$n$。 对于$60\%$的数据，$6 \leq n \leq 1000$。 对于$100\%$的数据，$6 \leq n \leq 2×10^{9}$。 【输出】输出只有一行，包含一个正整数$p$，即较大的那个质数。 【输入样例】121 【输出样例】17 【答案&amp;代码】12345678910111213#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int p; scanf("%d",&amp;p); for(int i=2;i&lt;=sqrt(p);i++) if(p%i==0)&#123; p/=i; break; &#125; printf("%d",p); return 0;&#125; T1099 : 第n小的质数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】输入一个正整数$n$，求第$n$小的质数。 【输入】一个不超过$10000$的正整数$n$。 【输出】第$n$小的质数。 【输入样例】110 【输出样例】129 【答案&amp;代码】123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;math.h&gt;bool prime(int num)&#123; if(num==2) return true; for(int i=2;i&lt;=sqrt(num);i++) if(num%i==0) return false; return true;&#125;int main(void)&#123; int n; scanf("%d",&amp;n); int sum=0,i; for(i=2;i&lt;=1000000000;i++)&#123; if(prime(i)) sum+=1; if(sum==n)&#123; printf("%d",i); return 0; &#125; &#125; return 0;&#125; T1100 : 金币 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】国王将金币作为工资，发放给忠诚的骑士。第$1$天，骑士收到一枚金币；之后两天（第$2$天和第$3$天）里，每天收到两枚金币；之后三天（第$4,5,6$天）里，每天收到三枚金币；之后四天(第$7,8,9,10$天)里，每天收到四枚金币……这种工资发放模式会一直这样延续下去：当连续$n$天每天收到$n$枚金币后，骑士会在之后的连续$n+1$天里，每天收到$n+1$枚金币（$n\in\N^{*}$）。 你需要编写一个程序，确定从第一天开始的给定天数内，骑士一共获得了多少金币。 【输入】一个整数（范围$1$到$10000$），表示天数。 【输出】骑士获得的金币数。 【输入样例】16 【输出样例】114 【答案&amp;代码】12345678910111213141516171819#include&lt;stdio.h&gt;int main(void)&#123; int K; scanf("%d",&amp;K); int sum=0; for(int i=1,count=0;;i+=1)&#123; int j; for(j=1;j&lt;=i;j++)&#123; if(count+j&gt;K) break; sum+=i; &#125; if(count+j&gt;K) break; count+=i; &#125; printf("%d",sum); return 0;&#125; T1101 : 不定方程求解 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】给定正整数$a,b,c$。求不定方程$ax+by=c$关于未知数$x$和$y$的所有非负整数解组数。 【输入】一行，包含三个正整数$a,b,c$，两个整数之间用单个空格隔开。每个数均不大于$1000$。 【输出】一个整数，即不定方程的非负整数解组数。 【输入样例】12 3 18 【输出样例】14 【答案&amp;代码】123456789101112#include&lt;stdio.h&gt;int main(void)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); int MAXa=c/a,MAXb=c/b,sum=0; for(int i=0;i&lt;=MAXa;i++) for(int j=0;j&lt;=MAXb;j++) if(a*i+b*j==c) sum++; printf("%d",sum); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>信息学奥赛一本通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息学奥赛一本通（C++版）第一部分 C++语言 第三章 程序的控制结构]]></title>
    <url>%2FSolution%2FYBT%2F1.3%2F</url>
    <content type="text"><![CDATA[信息学奥赛一本通（C++版）第一部分 C++语言 第三章 程序的控制结构 第一节 if选择结构T1039 : 判断数正负【题目描述】给定一个整数$N$，判断其正负。如果$N&gt;0$，输出positive；如果$N=0$，输出zero；如果$N&lt;0$，输出negative。 【输入】一个整数$N(−10^{9}≤N≤10^{9})$。 【输出】如果$N&gt;0$，输出positive; 如果$N=0$，输出zero; 如果$N&lt;0$，输出negative。 【输入样例】11 【输出样例】1positive 【答案&amp;代码】12345678910111213#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); if(n&gt;0) printf("positive"); else if(n==0) printf("zero"); else printf("negative"); return 0;&#125; T1040 : 输出绝对值【题目描述】输入一个浮点数，输出这个浮点数的绝对值，保留到小数点后两位。 【输入】输入一个浮点数，其绝对值不超过$10000$。 【输出】输出这个浮点数的绝对值，保留到小数点后两位。 【输入样例】1-3.14 【输出样例】13.14 【答案&amp;代码】12345678910#include&lt;stdio.h&gt;int main(void)&#123; double n; scanf("%lf",&amp;n); if(n&gt;=0) printf("%.2f",n); else printf("%.2f",-1*n); return 0;&#125; T1041 : 奇偶数判断【题目描述】给定一个整数，判断该数是奇数还是偶数。如果$n$是奇数，输出odd；如果$n$是偶数，输出even。 【输入】输入仅一行，一个大于零的正整数$n$。 【输出】输出仅一行，如果$n$是奇数，输出odd；如果$n$是偶数，输出even。 【输入样例】15 【输出样例】1odd 【答案&amp;代码】12345678910#include&lt;stdio.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); if(n%2==0) printf("even"); else printf("odd"); return 0;&#125; T1042 : 奇偶ASCII值判断【题目描述】任意输入一个字符，判断其ASCII是否是奇数，若是，输出YES，否则，输出NO。例如，字符A的ASCII值是65，则输出YES，若输入字符B(ASCII值是66)，则输出NO。 【输入】输入一个字符。 【输出】如果其ASCII值为奇数，则输出YES，否则，输出NO。 【输入样例】1A 【输出样例】1YES 【答案&amp;代码】12345678910#include&lt;stdio.h&gt;int main(void)&#123; char ch; scanf("%c",&amp;ch); if(ch%2==0) printf("NO"); else printf("YES"); return 0;&#125; T1043 : 整数大小比较【题目描述】输入两个整数，比较它们的大小。若$x&gt;y$，输出&gt;；若$x=y$，输出=；若$x &lt; y$，输出&lt;。 【输入】一行，包含两个整数$x$和$y$，中间用单个空格隔开。$0≤x&lt;2^{32},−2^{31}≤y&lt;2^{31}$。 【输出】一个字符。若$x&gt;y$，输出&gt;；若$x=y$，输出=；若$x &lt; y$，输出&lt;。 【输入样例】11000 100 【输出样例】1&gt; 【答案&amp;代码】123456789101112#include&lt;stdio.h&gt;int main(void)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); if(x&gt;y) printf("&gt;"); else if(x==y) printf("="); else printf("&lt;"); return 0;&#125; T1044 : 判断是否为两位数【题目描述】判断一个正整数是否是两位数(即大于等于$10$且小于等于$99$)。若该正整数是两位数，输出$1$，否则输出$0$。 【输入】一个正整数，不超过$1000$。 【输出】一行。若该正整数是两位数，输出$1$，否则输出$0$。 【输入样例】154 【输出样例】11 【答案&amp;代码】123456789101112#include&lt;stdio.h&gt;int main(void)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); if(x&gt;y) printf("&gt;"); else if(x==y) printf("="); else printf("&lt;"); return 0;&#125; T1045 : 收集瓶盖赢大奖【题目描述】某饮料公司最近推出了一个“收集瓶盖赢大奖”的活动：如果你拥有$10$个印有“幸运”、或$20$个印有“鼓励”的瓶盖，就可以兑换一个神秘大奖。现分别给出你拥有的印有“幸运”和“鼓励”的瓶盖数，判断是否可以去兑换大奖。若可以兑换大奖，输出$1$，否则输出$0$。 【输入】一行，包含两个整数，分别是印有“幸运”和“鼓励”的瓶盖数，用一个空格隔开。 【输出】一行。若可以兑换大奖，输出$1$，否则输出$0$。 【输入样例】111 19 【输出样例】11 【答案&amp;代码】12345678910#include&lt;stdio.h&gt;int main(void)&#123; int xy,gl; scanf("%d%d",&amp;xy,&amp;gl); if(xy&gt;=10||gl&gt;=20) printf("1"); else printf("0"); return 0;&#125; T1046 : 判断一个数能否同时被3和5整除【题目描述】判断一个数$n$能否同时被$3$和$5$整除，如果能同时被$3$和$5$整除输出YES，否则输出NO。 【输入】输入一行，包含一个整数$n$。$(-1,000,000 &lt; n &lt; 1,000,000)$ 【输出】输出一行，如果能同时被$3$和$5$整除输出YES，否则输出NO。 【输入样例】115 【输出样例】1YES 【答案&amp;代码】12345678910#include&lt;stdio.h&gt;int main(void)&#123; int num; scanf("%d",&amp;num); if(num%3==0&amp;&amp;num%5==0) printf("YES"); else printf("NO"); return 0;&#125; T1047 : 判断能否被3，5，7整除【题目描述】给定一个整数，判断它能否被$3,5,7$整除，并输出以下信息： 能同时被$3,5,7$整除（直接输出$3 5 7$，每个数中间一个空格）； 只能被其中两个数整除（输出两个数，小的在前，大的在后。例如：$3 5$或者$3 7$或者$5 7$，中间用空格分隔）； 只能被其中一个数整除（输出这个除数）； 不能被任何数整除，输出小写字符n，不包括单引号。 【输入】输入一行，包括一个整数。 【输出】输出一行，按照描述要求给出整数被$3,5,7$整除的情况。 【输入样例】1105 【输出样例】13 5 7 【答案&amp;代码】123456789101112131415161718#include&lt;stdio.h&gt;int main(void)&#123; int num; scanf("%d",&amp;num); if(num%105==0) printf("3 5 7"); else if(num%3==0||num%5==0||num%7==0)&#123; if(num%3==0) printf("3 "); if(num%5==0) printf("5 "); if(num%7==0) printf("7 "); &#125; else printf("n"); return 0;&#125; T1048 : 有一门课不及格的学生【题目描述】给出一名学生的语文和数学成绩，判断他是否恰好有一门课不及格(成绩小于$60$分)。若该生恰好有一门课不及格，输出$1$；否则输出$0$。 【输入】一行，包含两个在$0$到$100$之间的整数，分别是该生的语文成绩和数学成绩。 【输出】若该生恰好有一门课不及格，输出$1$；否则输出$0$。 【输入样例】150 80 【输出样例】11 【答案&amp;代码】123456789101112#include&lt;stdio.h&gt;int main(void)&#123; int ch,ma; scanf("%d%d",&amp;ch,&amp;ma); if(ch&lt;60&amp;&amp;ma&gt;=60) printf("1"); else if(ch&gt;=60&amp;&amp;ma&lt;60) printf("1"); else printf("0"); return 0;&#125; 第二节 switch语句T1049 : 晶晶赴约会【题目描述】晶晶的朋友贝贝约晶晶下周一起去看展览，但晶晶每周的$1,3,5$有课必须上课，请帮晶晶判断她能否接受贝贝的邀请，如果能输出YES；如果不能则输出NO。注意YES和NO都是大写字母！ 【输入】输入有一行，贝贝邀请晶晶去看展览的日期，用数字$1$到$7$表示从星期一到星期日。 【输出】输出有一行，如果晶晶可以接受贝贝的邀请，输出YES，否则，输出NO。注意YES和NO都是大写字母！ 【输入样例】12 【输出样例】1YES 【答案&amp;代码】1234567891011121314#include&lt;stdio.h&gt;int main(void)&#123; int d; scanf("%d",&amp;d); switch(d)&#123; case 1: case 3: case 5: printf("NO");break; default: printf("YES");break; &#125; return 0;&#125; T1050 : 骑车与走路【题目描述】在清华校园里，没有自行车，上课办事会很不方便。但实际上。并非去办任何事情都是骑车快,因为骑车总要找车、开锁、停车、锁车等,这要耽误一些时间。假设找到自行车，开锁并车上自行车的时间为$27$秒；停车锁车的时间为$23$秒；步行每秒行走$1.2$米，骑车每秒行走$3.0$米。请判断走不同的距离去办事,是骑车快还是走路快。如果骑车快，输出一行Bike；如果走路快，输出一行Walk；如果一样快，输出一行All。 【输入】输入一行，包含一个整数，表示一次办事要行走的距离,单位为米。 【输出】输出一行,如果骑车快,输出一行Bike;如果走路快,输出一行Walk;如果一样快,输出一行All。 【输入样例】1120 【输出样例】1Bike 【答案&amp;代码】123456789101112#include&lt;stdio.h&gt;int main(void)&#123; int len; scanf("%d",&amp;len); if(50+(double)len/3.0&gt;(double)len/1.2) printf("Walk"); else if(50+(double)len/3.0==(double)len/1.2) printf("All"); else printf("Bike"); return 0;&#125; T1051 : 分段函数【题目描述】编写程序，计算下列分段函数$y=f(x)$的值。结果保留到小数点后三位。 123y=−x+2.5; (0 ≤x&lt; 5)y=2−1.5(x−3)(x−3) (5 ≤x&lt; 10)y=x2−1.5 (10 ≤x&lt; 20) 【输入】一个浮点数$N(0≤N&lt;20)$。 【输出】输出N对应的分段函数值：$f(N)$。结果保留到小数点后三位。 【输入样例】11.0 【输出样例】11.500 【答案&amp;代码】12345678910111213#include&lt;stdio.h&gt;int main(void)&#123; double x,y; scanf("%lf",&amp;x); if(0&lt;=x&amp;&amp;x&lt;5) y=-x+2.5; else if(5&lt;=x&amp;&amp;x&lt;10) y=2-1.5*(x-3)*(x-3); else if(10&lt;=x&amp;&amp;x&lt;20) y=x/2-1.5; printf("%.3f",y); return 0;&#125; T1052 : 计算邮资【题目描述】根据邮件的重量和用户是否选择加急计算邮费。计算规则：重量在$1000$克以内（包括$1000$克）,基本费$8$元。超过$1000$克的部分，每$500$克加收超重费$4$元，不足$500$克部分按$500$克计算；如果用户选择加急，多收$5$元。 【输入】输入一行，包含整数和一个字符，以一个空格分开，分别表示重量（单位为克）和是否加急。如果字符是y，说明选择加急；如果字符是n，说明不加急。 【输出】输出一行，包含一个整数，表示邮费。 【输入样例】11200 y 【输出样例】117 【答案&amp;代码】12345678910111213141516#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int x; char ch; scanf("%d %c",&amp;x,&amp;ch); int sum; if(x&lt;=1000) sum=8; else sum=8+ceil((double)(x-1000)/500)*4; if(ch=='y') sum+=5; printf("%d",sum); return 0;&#125; T1053 : 最大数输出【题目描述】输入三个整数，数与数之间以一个空格分开。 输出一个整数，即最大的整数。 【输入】输入为一行，包含三个整数，数与数之间以一个空格分开。 【输出】输出一行，包含一个整数，即最大的整数。 【输入样例】110 20 56 【输出样例】156 【答案&amp;代码】12345678910#include&lt;stdio.h&gt;#include&lt;algorithm&gt;int main(void)&#123; int num[3]; for(int i=0;i&lt;3;i++) scanf("%d",num+i); std::sort(num,num+3); printf("%d",num[2]); return 0;&#125; T1054 : 三角形判断【题目描述】给定三个正整数，分别表示三条线段的长度，判断这三条线段能否构成一个三角形。如果能构成三角形，则输出yes，否则输出no。 【输入】输入共一行，包含三个正整数，分别表示三条线段的长度，数与数之间以一个空格分开。 【输出】如果能构成三角形，则输出yes，否则输出no。 【输入样例】13 4 5 【输出样例】1yes 【答案&amp;代码】12345678910111213#include&lt;stdio.h&gt;#include&lt;algorithm&gt;int main(void)&#123; int num[3]; for(int i=0;i&lt;3;i++) scanf("%d",num+i); std::sort(num,num+3); if(num[0]+num[1]&gt;num[2]) printf("yes"); else printf("no"); return 0;&#125; T1055 : 判断闰年【题目描述】判断某年是否是闰年。如果公元$a$年是闰年输出Y，否则输出N。 【输入】输入只有一行，包含一个整数$a(0 &lt; a &lt; 3000)$。 【输出】一行，如果公元$a$年是闰年输出Y，否则输出N。 【输入样例】12006 【输出样例】1N 【答案&amp;代码】123456789101112#include&lt;stdio.h&gt;int main(void)&#123; int y; scanf("%d",&amp;y); if(y%400==0) printf("Y"); else if(y%4==0&amp;&amp;y%100!=0) printf("Y"); else printf("N"); return 0;&#125; T1056 : 点和正方形的关系【题目描述】有一个正方形，四个角的坐标$(x,y)$分别是$(1,-1),(1,1),(-1,-1),(-1,1)$，$x$是横轴，$y$是纵轴。写一个程序，判断一个给定的点是否在这个正方形内(包括正方形边界)。如果点在正方形内，则输出yes，否则输出no。 【输入】输入一行，包括两个整数$x,y$，以一个空格分开，表示坐标$(x,y)$。 【输出】输出一行，如果点在正方形内，则输出yes，否则输出no。 【输入样例】11 1 【输出样例】1yes 【答案&amp;代码】12345678910#include&lt;stdio.h&gt;int main(void)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); if(-1&lt;=x&amp;&amp;x&lt;=1&amp;&amp;-1&lt;=y&amp;&amp;y&lt;=1) printf("yes"); else printf("no"); return 0;&#125; T1057 : 简单计算器【题目描述】一个最简单的计算器，支持$+,-,*,/$四种运算。仅需考虑输入输出为整数的情况，数据和运算结果不会超过int表示的范围。然而： 如果出现除数为$0$的情况，则输出：Divided by zero! 如果出现无效的操作符(即不为$+,-,*,/$之一），则输出：Invalid operator! 【输入】输入只有一行，共有三个参数，其中第$1,2$个参数为整数，第$3$个参数为操作符（$+,-,*,/$）。 【输出】输出只有一行，一个整数，为运算结果。然而： 如果出现除数为$0$的情况，则输出：Divided by zero! 如果出现无效的操作符(即不为$+,-,*,/$之一），则输出：Invalid operator! 【输入样例】11 2 + 【输出样例】13 【答案&amp;代码】123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int main(void)&#123; int a,b; char op; scanf("%d %d %c",&amp;a,&amp;b,&amp;op); int result; switch(op)&#123; case '+': result=a+b; printf("%d",result); break; case '-': result=a-b; printf("%d",result); break; case '*': result=a*b; printf("%d",result); break; case '/': if(b==0)&#123; printf("Divided by zero!"); break; &#125; result=a/b; printf("%d",result); break; default: printf("Invalid operator!"); break; &#125; return 0;&#125; T1058 : 求一元二次方程【题目描述】求一元二次方程$ax^{2}+bx+c=0$的根，其中$a$不等于$0$。结果要求精确到小数点后$5$位。 【输入】输入一行，包含三个浮点数$a,b,c$（它们之间以一个空格分开），分别表示方程$ax^{2}+bx+c=0$的系数。 【输出】输出一行，表示方程的解。 若两个实根相等，则输出形式为：“$x1=x2=…$”； 若两个实根不等，在满足根小者在前的原则，则输出形式为：“$x1=…;x2=…$”； 若无实根输出No answer!。 所有输出部分要求精确到小数点后$5$位，数字、符号之间没有空格。 【输入样例】1-15.97 19.69 12.02 【输出样例】1x1=-0.44781;x2=1.68075 【答案&amp;代码】1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define precision_1 1e-12#define precision_2 1e-6int main(void)&#123; double a,b,c,x1,x2,delta; scanf("%lf%lf%lf",&amp;a,&amp;b,&amp;c); delta=b*b-4*a*c; if(delta&lt;0&amp;&amp;fabs(delta)&gt;precision_1) printf("No answer!\n"); else if(fabs(delta)&lt;precision_1)&#123; x1=-b/(2*a); if(fabs(x1)&lt;precision_2) printf("x1=x2=%.5lf\n",0); else printf("x1=x2=%.5lf\n",x1); &#125; else&#123; x1=(-b+sqrt(delta))/(2*a); x2=(-b-sqrt(delta))/(2*a); if(fabs(x1)&lt;precision_2) x1=fabs(x1); if(fabs(x2)&lt;precision_2) x2=fabs(x2); if(x1&lt;x2) printf("x1=%.5lf;x2=%.5lf",x1,x2); else printf("x1=%.5lf;x2=%.5lf",x2,x1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>信息学奥赛一本通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息学奥赛一本通（C++版）第一部分 C++语言 第二章 顺序结构程序设计]]></title>
    <url>%2FSolution%2FYBT%2F1.2%2F</url>
    <content type="text"><![CDATA[信息学奥赛一本通（C++版）第一部分 C++语言 第二章 顺序结构程序设计 第一节 运算符和表达式T1006 : A+B问题【题目描述】大部分的在线题库，都会将$A+B$问题作为第一题，以帮助新手熟悉平台的使用方法。 $A+B$问题的题目描述如下：给定两个整数$A$和$B$，输出$A+B$的值。保证$A,B$及结果均在整型范围内。现在请你解决这一问题。 【输入】一行，包含两个整数$A,B$，中间用单个空格隔开。$A$和$B$均在整型范围内。 【输出】一个整数，即$A+B$的值。保证结果在整型范围内。 【输入样例】11 2 【输出样例】13 【答案&amp;代码】123456789#include&lt;cstdio&gt;int a,b;int main(void)&#123; scanf("%d%d",&amp;a,&amp;b); printf("%d\n",a+b); return 0;&#125; T1007 : 计算(a+b)×c的值【题目描述】给定$3$个整数$a,b,c$，计算表达式$(a+b)×c$的值。 【输入】输入仅一行，包括三个整数$a,b,c$, 数与数之间以一个空格分开。$(-10^{4} &lt; a,b,c &lt; 10^{4})$ 【输出】输出一行，即表达式的值。 【输入样例】12 3 5 【输出样例】125 【答案&amp;代码】123456789#include&lt;cstdio&gt;int a,b,c;int main(void)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); printf("%d\n",(a+b)*c); return 0;&#125; T1008 : 计算(a+b)/c的值【题目描述】给定$3$个整数$a,b,c$，计算表达式$(a+b)÷c$的值。 【输入】输入仅一行，包括三个整数$a,b,c$, 数与数之间以一个空格分开。$(-10^{4} &lt; a,b,c &lt; 10^{4} , c \neq 0)$ 【输出】输出一行，即表达式的值。 【输入样例】11 1 3 【输出样例】10 【答案&amp;代码】123456789#include&lt;cstdio&gt;int a,b,c;int main(void)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); printf("%d\n",(a+b)/c); return 0;&#125; T1009 : 带余除法【题目描述】给定被除数和除数，求整数商及余数。此题中请使用默认的整除和取余运算，无需对结果进行任何特殊处理。 【输入】一行，包含两个整数，依次为被除数和除数（除数非零），中间用一个空格隔开。 【输出】一行，包含两个整数，依次为整数商和余数，中间用一个空格隔开。 【输入样例】110 3 【输出样例】13 1 【答案&amp;代码】1234567#include&lt;cstdio&gt;int main(void)&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); printf("%d %d",a/b,a%b); return 0;&#125; T1010 : 计算分数的浮点数值【题目描述】两个整数$a$和$b$分别作为分子和分母，既分数$\frac{a}{b}$，求它的浮点数值(双精度浮点数，保留小数点后$9$位)。 【输入】输入仅一行，包括两个整数$a$和$b$。 【输出】输出也仅一行，分数$\frac{a}{b}$的浮点数值（双精度浮点数，保留小数点后$9$位）。 【输入样例】15 7 【输出样例】10.714285714 【答案&amp;代码】1234567#include&lt;stdio.h&gt;int main(void)&#123; double a,b; scanf("%lf%lf",&amp;a,&amp;b); printf("%.9f",a/b); return 0;&#125; 第二节 常量和变量T1011 : 甲流疫情死亡率【题目描述】甲流并不可怕，在中国，它的死亡率并不是很高。请根据截止$2009$年$12$月$22$日各省报告的甲流确诊数和死亡数，计算甲流在各省的死亡率。 【输入】输入仅一行，有两个整数，第一个为确诊数，第二个为死亡数。 【输出】输出仅一行，甲流死亡率，以百分数形式输出，精确到小数点后$3$位。 【输入样例】110433 60 【输出样例】10.575% 【答案&amp;代码】1234567#include&lt;stdio.h&gt;int main(void)&#123; double a,b; scanf("%lf%lf",&amp;a,&amp;b); printf("%.3f%%",b/a*100); return 0;&#125; T1012 : 计算多项式的值【题目描述】对于多项式$f(x)=ax^{3}+bx^{2}+cx+d$和给定的$a,b,c,d,x$，计算$f(x)$的值，保留到小数点后$7$位。 【输入】输入仅一行，包含$5$个实数，分别是$x$，及参数$a,b,c,d$的值，每个数都是绝对值不超过$100$的双精度浮点数。数与数之间以一个空格分开。 【输出】输出一个实数，即$f(x)$的值，保留到小数点后$7$位。 【输入样例】12.31 1.2 2 2 3 【输出样例】133.0838692 【答案&amp;代码】123456789#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; double a,b,c,d,x; scanf("%lf%lf%lf%lf%lf",&amp;x,&amp;a,&amp;b,&amp;c,&amp;d); double ans=a*pow(x,3)+b*x*x+c*x+d; printf("%.7f",ans); return 0;&#125; T1013 : 温度表达转化【题目描述】利用公式$C=5×(F−32)÷9$（其中$C$表示摄氏温度，$F$表示华氏温度）进行计算转化,输入华氏温度$F$，输出摄氏温度$C$，要求精确到小数点后$5$位。 【输入】输入一行，包含一个实数$F$，表示华氏温度。$(F≥−459.67)$ 【输出】输出一行，包含一个实数，表示对应的摄氏温度，要求精确到小数点后$5$位。 【输入样例】141 【输出样例】15.00000 【答案&amp;代码】123456789#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; double F; scanf("%lf",&amp;F); double C=5*(F-32)/9; printf("%.5f",C); return 0;&#125; T1014 : 与圆相关的计算【题目描述】给出圆的半径，求圆的直径、周长和面积。输入圆的半径实数$r$，输出圆的直径、周长、面积，每个数保留小数点后$4$位。圆周率取值为$3.14159$。 【输入】输入包含一个实数$r(0 &lt; r \leq 10^{4})$，表示圆的半径。 【输出】输出一行，包含三个数，分别表示圆的直径、周长、面积，数与数之间以一个空格分开，每个数保留小数点后$4$位。 【输入样例】13.0 【输出样例】16.0000 18.8495 28.2743 【答案&amp;代码】12345678#include&lt;stdio.h&gt;#define PI 3.14159int main(void)&#123; double r; scanf("%lf",&amp;r); printf("%.4f %.4f %.4f",2*r,2*r*PI,r*r*PI); return 0;&#125; T1015 : 计算并联电阻的阻值【题目描述】对于阻值为$R_{1}$和$R_{2}$的电阻，其并联电阻阻值公式计算如下：$R=\frac{1}{\frac{1}{R_{1}}+\frac{1}{R_{2}}}$。输入两个电阻阻抗大小，浮点型。输出并联之后的阻抗大小，结果保留小数点后$2$位。 【输入】两个电阻阻抗大小，浮点型，以一个空格分开。 【输出】并联之后的阻抗大小，结果保留小数点后$2$位。 【输入样例】11 2 【输出样例】10.67 【答案&amp;代码】1234567#include&lt;stdio.h&gt;int main(void)&#123; double r1,r2; scanf("%lf%lf",&amp;r1,&amp;r2); printf("%.2f",1/(1/r1+1/r2)); return 0;&#125; 第三节 标准数据类型T1016 : 整型数据类型存储空间大小【题目描述】分别定义int，short类型的变量各一个，并依次输出它们的存储空间大小(单位：字节)。 【输入】(无） 【输出】一行，两个整数，分别是两个变量的存储空间大小，用一个空格隔开。 【答案&amp;代码】12345#include&lt;stdio.h&gt;int main(void)&#123; printf("%d %d",sizeof(int),sizeof(short)); return 0;&#125; T1017 : 浮点型数据类型存储空间大小【题目描述】分别定义float，double类型的变量各一个，并依次输出它们的存储空间大小(单位：字节)。 【输入】(无） 【输出】一行，两个整数，分别是两个变量的存储空间大小，用一个空格隔开。 【答案&amp;代码】12345#include&lt;stdio.h&gt;int main(void)&#123; printf("%d %d",sizeof(float),sizeof(double)); return 0;&#125; T1018 : 其他数据类型存储空间大小【题目描述】分别定义bool，char类型的变量各一个，并依次输出它们的存储空间大小(单位：字节)。 【输入】(无） 【输出】一行，两个整数，分别是两个变量的存储空间大小，用一个空格隔开。 【答案&amp;代码】12345#include&lt;stdio.h&gt;int main(void)&#123; printf("%d %d",sizeof(bool),sizeof(char)); return 0;&#125; T1019 : 其他数据类型存储空间大小【题目描述】输入一个单精度浮点数，将其向零舍入到整数。说明：向零舍入的含义是，正数向下舍入，负数向上舍入。提示：可以使用强制类型转换来实现。 【输入】一个单精度浮点数。 【输出】一个整数，即向零舍入到整数的结果。 【输入样例】12.3 【输出样例】12 【答案&amp;代码】1234567#include&lt;stdio.h&gt;int main(void)&#123; double num; scanf("%lf",&amp;num); printf("%d",(int)num); return 0;&#125; T1020 : 打印ASCII码【题目描述】输入一个除空格以外的可见字符（保证在函数scanf中可使用格式说明符%c读入），输出其ASCII码。 【输入】一个除空格以外的可见字符。 【输出】一个十进制整数，即该字符的ASCII码。 【输入样例】1A 【输出样例】165 【答案&amp;代码】1234567#include&lt;stdio.h&gt;int main(void)&#123; char ch; scanf("%c",&amp;ch); printf("%d",ch); return 0;&#125; T1021 : 打印字符【题目描述】输入一个整数，即字符的ASCII码，保证存在对应的可见字符。输出相对应的字符。 【输入】一个整数，即字符的ASCII码，保证存在对应的可见字符。 【输出】一行，包含相应的字符。 【输入样例】165 【输出样例】1A 【答案&amp;代码】1234567#include&lt;stdio.h&gt;int main(void)&#123; int ch; scanf("%d",&amp;ch); printf("%c",ch); return 0;&#125; T1022 : 整型与布尔型的转换【题目描述】将一个整型变量的值赋给一个布尔型变量，再将这个布尔型变量的值赋给一个整型变量，得到的值是多少？ 【输入】一个整型范围内的整数，即初始时整型变量的值。 【输出】一个整数，经过上述过程后得到的结果。 【输入样例】13 【输出样例】11 【答案&amp;代码】123456789#include&lt;stdio.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); bool temp=n; n=temp; printf("%d",n); return 0;&#125; T1023 : Hello,World!的大小【题目描述】我们曾经输出过的&quot;Hello, World!&quot;吗？它虽然不是本章所涉及的基本数据类型的数据，但我们同样可以用sizeof函数获得它所占用的空间大小。 【输入】（无） 【输出】一个整数，即&quot;Hello, World!&quot;的大小。 【答案&amp;代码】12345#include&lt;stdio.h&gt;int main(void)&#123; printf("%d",sizeof("Hello, World!")); return 0;&#125; 第四节 数据输入输出T1024 : 保留3位小数的浮点数【题目描述】读入一个单精度浮点数，保留$3$位小数输出这个浮点数。 【输入】只有一行，一个单精度浮点数。 【输出】也只有一行，读入的单精度浮点数。 【输入样例】112.34521 【输出样例】112.345 【答案&amp;代码】1234567#include&lt;stdio.h&gt;int main(void)&#123; double num; scanf("%lf",&amp;num); printf("%.3f",num); return 0;&#125; T1025 : 保留12位小数的浮点数【题目描述】读入一个双精度浮点数，保留$12$位小数，输出这个浮点数。 【输入】只有一行，一个双精度浮点数。 【输出】也只有一行，保留$12$位小数的浮点数。 【输入样例】13.1415926535798932 【输出样例】13.141592653580 【答案&amp;代码】1234567#include&lt;stdio.h&gt;int main(void)&#123; double num; scanf("%lf",&amp;num); printf("%.12lf",num); return 0;&#125; T1026 : 空格分隔输出【题目描述】读入一个字符，一个整数，一个单精度浮点数，一个双精度浮点数，然后按顺序输出它们，并且要求在他们之间用一个空格分隔。输出浮点数时保留$6$位小数。 【输入】第一行是一个字符； 第二行是一个整数； 第三行是一个单精度浮点数； 第四行是一个双精度浮点数。 【输出】输出字符、整数、单精度浮点数和双精度浮点数，之间用空格分隔。 【输入样例】1234a122.33.2 【输出样例】1a 12 2.300000 3.200000 【答案&amp;代码】123456789#include&lt;stdio.h&gt;int main(void)&#123; char ch; int n; double a,b; scanf("%c%d%lf%lf",&amp;ch,&amp;n,&amp;a,&amp;b); printf("%c %d %.6f %.6f",ch,n,a,b); return 0;&#125; T1027 : 输出浮点数【题目描述】读入一个双精度浮点数，分别按输出格式%f，%f保留$5$位小数，%e和%g的形式输出这个整数，每次在单独一行上输出。 【输入】一个双精度浮点数。 【输出】第一行是按%f输出的双精度浮点数； 第二行是按%f保留$5$位小数输出的双精度浮点数； 第三行是按%e输出的双精度浮点数； 第四行是按%g输出的双精度浮点数。 【输入样例】112.3456789 【输出样例】123412.34567912.345681.234568e+00112.3457 【答案&amp;代码】1234567#include&lt;stdio.h&gt;int main(void)&#123; double n; scanf("%lf",&amp;n); printf("%.6f\n%.5f\n%e\n%g",n,n,n,n); return 0;&#125; T1028 : 字符菱形【题目描述】给定一个字符，用它构造一个对角线长$5$个字符，倾斜放置的菱形。 【输入】输入只有一行， 包含一个字符。 【输出】该字符构成的菱形。 【输入样例】1* 【输出样例】12345 * ******** *** * 【答案&amp;代码】1234567#include&lt;stdio.h&gt;int main(void)&#123; char ch; scanf("%c",&amp;ch); printf(" %c \n %c%c%c \n%c%c%c%c%c\n %c%c%c \n %c ",ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch,ch); return 0;&#125; 第五节 顺序结构实例T1029 : 计算浮点数相除的余【题目描述】计算两个双精度浮点数$a$和$b$的相除的余数，$a$和$b$都是双精度浮点数。这里余数$r$的定义是：$a=k×b+r$，其中$k$是整数，$0≤r&lt;b$。 【输入】输入仅一行，包括两个双精度浮点数$a$和$b$。 【输出】输出也仅一行，$a÷b$的余数。 【输入样例】173.263 0.9973 【输出样例】10.4601 【答案&amp;代码】123456789#include&lt;stdio.h&gt;int main(void)&#123; double a,b; scanf("%lf%lf",&amp;a,&amp;b); int k=(int)(a/b); double r=a-k*b; printf("%g",r); return 0;&#125; T1030 : 计算球的体积【题目描述】对于半径为$r$的球，其体积的计算公式为$V=\frac{4}{3}πr^{3}$，这里取$π=3.14$。现给定$r$，即球半径，类型为$double$，求球的体积$V$，保留到小数点后$2$位。 【输入】输入为一个不超过$100$的非负实数，即球半径，类型为$double$。 【输出】输出一个实数，即球的体积，保留到小数点后$2$位。 【输入样例】14 【输出样例】1267.95 【答案&amp;代码】12345678910#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define PI 3.14int main(void)&#123; double r; scanf("%lf",&amp;r); double V=pow(r,3)*PI*4/3; printf("%.2f",V); return 0;&#125; T1031 : 反向输出一个三位数【题目描述】将一个三位数反向输出，例如输入$358$，反向输出$853$。 【输入】一个三位数$n$。 【输出】反向输出$n$。 【输入样例】1100 【输出样例】1001 【答案&amp;代码】123456789#include&lt;stdio.h&gt;int main(void)&#123; int num; scanf("%d",&amp;num); printf("%d",num%10); printf("%d",(num/10)%10); printf("%d",num/100); return 0;&#125; T1032 : 大象喝水查【题目描述】一只大象口渴了，要喝$20$升水才能解渴，但现在只有一个深$h$厘米，底面半径为$r$厘米的小圆桶($h$和$r$都是整数)。问大象至少要喝多少桶水才会解渴。 【输入】输入有一行：包行两个整数，以一个空格分开，分别表示小圆桶的深$h$和底面半径$r$，单位都是厘米。 【输出】输出一行，包含一个整数，表示大象至少要喝水的桶数。 【输入样例】123 11 【输出样例】13 【答案&amp;代码】123456789#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; double h,r; scanf("%lf%lf",&amp;h,&amp;r); double V=r*r*M_PI*h; printf("%d",(int)ceil(20000/V)); return 0;&#125; T1033 : 计算线段长度【题目描述】已知线段的两个端点的坐标$A(X_{a},Y_{b}),B(X_{b},Y_{b})$，求线段$AB$的长度，保留到小数点后$3$位。 【输入】第一行是两个实数$X_{a},Y_{b}$，即$A$的坐标。 第二行是两个实数$X_{b},Y_{b}$，即$B$的坐标。 输入中所有实数的绝对值均不超过$10000$。 【输出】一个实数，即线段$AB$的长度，保留到小数点后$3$位。 【输入样例】121 12 2 【输出样例】11.414 【答案&amp;代码】123456789#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; double Xa,Ya; double Xb,Yb; scanf("%lf%lf%lf%lf",&amp;Xa,&amp;Ya,&amp;Xb,&amp;Yb); printf("%.3f",sqrt((Xb-Xa)*(Xb-Xa)+(Yb-Ya)*(Yb-Ya))); return 0;&#125; T1034 : 计算三角形面积【题目描述】平面上有一个三角形，它的三个顶点坐标分别为$(x_{1}, y_{1}), (x_{2}, y_{2}), (x_{3}, y_{3})$，那么请问这个三角形的面积是多少，精确到小数点后两位。 【输入】输入仅一行，包括$6$个单精度浮点数，分别对应$x_{1}, y_{1}, x_{2}, y_{2}, x_{3}, y_{3}$。 【输出】输出也是一行，输出三角形的面积，精确到小数点后两位。 【输入样例】10 0 4 0 0 3 【输出样例】16.00 【答案&amp;代码】123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;math.h&gt;double len(double Xa,double Ya,double Xb,double Yb)&#123; return sqrt((Xb-Xa)*(Xb-Xa)+(Yb-Ya)*(Yb-Ya));&#125;int main(void)&#123; double X1,Y1; double X2,Y2; double X3,Y3; scanf("%lf%lf%lf%lf%lf%lf",&amp;X1,&amp;Y1,&amp;X2,&amp;Y2,&amp;X3,&amp;Y3); double len1=len(X1,Y1,X2,Y2); double len2=len(X2,Y2,X3,Y3); double len3=len(X1,Y1,X3,Y3); double q=(len1+len2+len3)/2; double S=sqrt(q*(q-len1)*(q-len2)*(q-len3)); printf("%.2f",S); return 0;&#125; T1035 : 等差数列末项计算【题目描述】给出一个等差数列的前两项$a_{1},a_{2}$，求第$n$项是多少。 【输入】一行，包含三个整数$a_{1},a_{2},n$。$−100 \leq a_{1},a_{2} \leq 100,0 &lt; n \leq 1000$。 【输出】一个整数，即第$n$项的值。 【输入样例】11 4 100 【输出样例】1298 【答案&amp;代码】12345678#include&lt;stdio.h&gt;int main(void)&#123; int a1,a2,n; scanf("%d%d%d",&amp;a1,&amp;a2,&amp;n); int gc=a2-a1; printf("%d",gc*(n-1)+a1); return 0;&#125; T1036 : A×B问题【题目描述】输入两个正整数$A$和$B$，求$A×B$的值。注意乘积的范围和数据类型的选择。 【输入】一行，包含两个正整数$A$和$B$，中间用单个空格隔开。$1 \leq A,B \leq 50000$。 【输出】一个整数，即$A×B$的值。 【输入样例】13 4 【输出样例】112 【答案&amp;代码】1234567#include&lt;stdio.h&gt;int main(void)&#123; unsigned long long a,b; scanf("%llu%llu",&amp;a,&amp;b); printf("%llu",a*b); return 0;&#125; T1037 : 计算2的幂【题目描述】给定非负整数$n$，求$2^{n}$的值，即$2$的$n$次方。 【输入】一个整数$n$。$0≤n&lt;31$。 【输出】一个整数，即$2$的$n$次方。 【输入样例】13 【输出样例】18 【答案&amp;代码】12345678#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int n; scanf("%d",&amp;n); printf("%d",1&lt;&lt;n); return 0;&#125; T1038 : 苹果和虫子【题目描述】你买了一箱$n$个苹果，很不幸的是买完时箱子里混进了一条虫子。虫子每$x$小时能吃掉一个苹果，假设虫子在吃完一个苹果之前不会吃另一个，那么经过$y$小时你还有多少个完整的苹果？ 【输入】输入仅一行，包括$n,x,y$（均为整数）。 【输出】输出也仅一行，剩下的苹果个数。 【输入样例】110 4 9 【输出样例】17 【答案&amp;代码】1234567891011#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int x,y,n; scanf("%d%d%d",&amp;n,&amp;x,&amp;y); int temp=(int)ceil((double)y/x); if(temp&gt;n) temp=n; printf("%d",n-temp); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>信息学奥赛一本通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息学奥赛一本通（C++版）第一部分 C++语言 第一章 C++语言入门]]></title>
    <url>%2FSolution%2FYBT%2F1.1%2F</url>
    <content type="text"><![CDATA[信息学奥赛一本通（C++版）第一部分 C++语言 第一章 C++语言入门 T1000 : 入门测试题目 时间限制: 1000 ms 内存限制: 32768 KB 【题目描述】&emsp;&emsp;求两个整数的和。 【输入】&emsp;&emsp;一行，两个用空格隔开的整数。 【输出】&emsp;&emsp;两个整数的和。 【输入样例】11 2 【输出样例】13 【答案&amp;代码】1234567#include&lt;stdio.h&gt;/*标准输入输出头文件*/int main(void)&#123; int a,b;/*定义a,b两个变量*/ scanf("%d%d",&amp;a,&amp;b);/*输入两个整数，即a,b的值*/ printf("%d",a+b);/*输出a+b的值*/ return 0;/*退出主函数*/&#125; T1001 : Hello,World! 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】&emsp;&emsp;编写一个能够输出Hello,World!的程序，这个程序常常作为一个初学者接触一门新的编程语言所写的第一个程序，也经常用来测试开发、编译环境是否能够正常工作。 &emsp;&emsp;提示：Hello,World!中间没空格。 【输入】&emsp;&emsp;无 【输出】&emsp;&emsp;Hello,World! 【输入样例】1（无） 【输出样例】1Hello,World! 【答案&amp;代码】12345#include&lt;stdio.h&gt;/*标准输入输出头文件*/int main(void)&#123; printf("Hello,World!");/*输出字符串"Hello,World!"*/ return 0;/*退出主函数*/&#125; T1002: 输出第二个整数 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】&emsp;&emsp;输入三个整数，整数之间由一个空格分隔，整数是$32$位有符号整数。把第二个输入的整数输出。 【输入】&emsp;&emsp;只有一行，共三个整数，整数之间由一个空格分隔。整数是$32$位有符号整数。 【输出】&emsp;&emsp;只有一行，一个整数，即输入的第二个整数。 【输入样例】1123 456 789 【输出样例】1456 【答案&amp;代码】1234567#include&lt;stdio.h&gt;/*标准输入输出头文件*/int main(void)&#123; int n;/*定义变量n*/ scanf("%*d%d%*d",&amp;n);/*读入三个整数，其中对第一、三个整数不进行操作，将第二个整数的值赋给n*/ printf("%d",n);/*输出n的值*/ return 0;/*退出主函数*/&#125; T1003: 对齐输出 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】&emsp;&emsp;读入三个整数，按每个整数占$8$个字符的宽度，右对齐输出它们，按照格式要求依次输出三个整数，之间以一个空格分开。 【输入】&emsp;&emsp;只有一行，包含三个整数，整数之间以一个空格分开。 【输出】&emsp;&emsp;只有一行，按照格式要求依次输出三个整数，之间以一个空格分开。 【输入样例】1123456789 0 -1 【输出样例】1123456789 0 -1 【答案&amp;代码】1234567#include&lt;stdio.h&gt;/*标准输入输出头文件*/int main(void)&#123; int a,b,c;/*定义三个变量a,b,c*/ scanf("%d%d%d",&amp;a,&amp;b,&amp;c);/*输入a,b,c的值*/ printf("%8d %8d %8d",a,b,c);/*%8d，每个整数占8个字符的宽度，输出a,b,c的值*/ return 0;/*退出主函数*/&#125; T1004: 字符三角形 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】&emsp;&emsp;给定一个字符，用它构造一个底边长$5$个字符，高$3$个字符的等腰字符三角形。 【输入】&emsp;&emsp;输入只有一行，包含一个字符。 【输出】&emsp;&emsp;该字符构成的等腰三角形，底边长$5$个字符，高$3$个字符。 【输入样例】1* 【输出样例】123 * ******** 【答案&amp;代码】123456789#include&lt;stdio.h&gt;/*标准输入输出头文件*/int main(void)&#123; char ch;/*定义字符变量ch*/ scanf("%c",&amp;ch);/*输入字符ch*/ printf(" %c \n",ch); printf(" %c%c%c \n",ch,ch,ch); printf("%c%c%c%c%c",ch,ch,ch,ch,ch);/*输出三角形*/ return 0;/*退出主函数*/&#125; T1005: 地球人口承载力估计 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】&emsp;&emsp;假设地球上的新生资源按恒定速度增长。照此测算，地球上现有资源加上新生资源可供$x$亿人生活$a$年，或供$y$亿人生活$b$年。 &emsp;&emsp;为了能够实现可持续发展，避免资源枯竭，地球最多能够养活多少亿人？ 【输入】&emsp;&emsp;一行，包括四个正整数$x,a,y,b$，两个整数之间用单个空格隔开。$x &gt; y , a &lt; b , ax &lt; by$，各整数均不大于$10000$。 【输出】&emsp;&emsp;一个实数$z$，表示地球最多养活$z$亿人，舍入到小数点后两位。 【输入样例】1110 90 90 210 【输出样例】175.00 【答案&amp;代码】12345678#include&lt;stdio.h&gt;/*标准输入输出头文件*/int main(void)&#123; double a,x,b,y;/*定义题中变量*/ scanf("%lf%lf%lf%lf",&amp;x,&amp;a,&amp;y,&amp;b);/*输入x,a,y,b的值*/ double z=(b*y-a*x)/(b-a);/*经过数学分析可得z=(by-ax)/(b-a)*/ printf("%.2f",z);/*输出z的值*/ return 0;/*退出主函数*/&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>信息学奥赛一本通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIp2018】【初赛】普及组原题&题解]]></title>
    <url>%2FNOIp%2F2018%2FPJ%2FPreparation-Solution%2F</url>
    <content type="text"><![CDATA[【NOIp2018】【初赛】普及组原题&amp;题解 原题&amp;答案普及组C++语言试题： 普及组答案： 题解单项选择题第$1$题以下哪一种设备属于输出设备：（ ） $$\text{A. 扫描仪}\quad\text{B. 键盘}\quad\text{C. 鼠标}\quad\text{D. 打印机}$$ 答案：$\text{D}$，打印机属于输出设备。 第$2$题下列四个不同进制的数中，与其它三项数值上不相等的是（ ）。 $$\text{A. }(269)_{16}\quad\text{B. }(617)_{10}\quad\text{C. }(1151)_{8}\quad\text{D. }(1001101011)_{2}$$ 答案：$\text{D}$，计算。 第$3$题$1\text{MB}$等于（ ）。 $$\text{A. }1000 \text{字节}\quad\text{B. }1024 \text{字节}\quad\text{C. }1000 \times 1000 \text{字节}\quad\text{D. }1024 \times 1024 \text{字节}$$ 答案：$\text{D}$，$1\text{MB}=2^{20}\text{Byte}$。 第$4$题广域网的英文缩写是（ ）。 $$\text{A. LAN}\quad\text{B. WAN}\quad\text{C. MAN}\quad\text{D. LNA}$$ 答案：$\text{B}$，广域网（$\text{Wide Area Network}$）的缩写是$\text{WAN}$。 第$5$题中国计算机学会于（ ）年创办全国青少年计算机程序设计竞赛。 $$\text{A. }1983\quad\text{B. }1984\quad\text{C. }1985\quad\text{D. }1986$$ 答案：$\text{B}$，$1984$年邓小平指出：“计算机的普及要从娃娃做起。”因此，教育部和中国科协委托中国计算机学会举办了全国青少年计算机程序设计竞赛。 第$6$题如果开始时计算机处于小写输入状态，现在有一只小老鼠反复按照CapsLock、字母键$\text{A}$、字母键$\text{S}$、字母键$\text{D}$、字母键$\text{F}$的顺序循环按键，即CapsLock、A、S、D、F、CapsLock、A、S、D、F、……，屏幕上输出的第$81$个字符是字母（ ）。 $$\text{A. A}\quad\text{B. S}\quad\text{C. D}\quad\text{D. a}$$ 答案：$\text{A}$，模拟可得结果为$\text{A}$。 第$7$题根节点深度为$0$，一棵深度为$h$的满$k(k&gt;1)$叉树，即除最后一层无任何子节点外，每一层上的所有结点都有$k$个子结点的树，共有（ ）个结点。 $$\text{A. }(k^{h+1}-1)/(k-1)\quad\text{B. }k^{h-1}\quad\text{C. }k^{h}\quad\text{D. }(k^{h-1})/(k-1)$$ 答案：$\text{A}$： 根据推理得出总的节点数$$S=\sum^{h}_{i=0}k^i$$ 再根据等比数列求和公式得：$$S=1\times\frac{1-q^{n}}{1-q}=\frac{1-k^{h+1}}{1-k}=\frac{k^{h+1}-1}{k-1},q=k$$ 第$8$题以下排序算法中，不需要进行关键字比较操作的算法是（ ）。 $$\text{A. 基数排序}\quad\text{B. 冒泡排序}\quad\text{C. 堆排序}\quad\text{D. 直接插入排序}$$ 答案：$\text{A}$。 第$9$题给定一个含$N$个不相同数字的数组，在最坏情况下，找出其中最大或最小的数，至少需要$N-1$次比较操作。则最坏情况下，在该数组中同时找最大与最小的数至少需要（ ）次比较操作。（$⌈ ⌉$表示向上取整，$⌊ ⌋$表示向下取整） $$\text{A. }⌈3N / 2⌉ - 2\quad\text{B. }⌊3N / 2⌋ - 2\quad\text{C. }2N - 2\quad\text{D. }2N - 4$$ 答案：$\text{A}$。 第$10$题下面的故事与（ ）算法有着异曲同工之妙。从前有座山，山里有座庙，庙里有个老和尚在给小和尚讲故事：“从前有座山，山里有座庙，庙里有个老和尚在给小和尚讲故事：‘从前有座山，山里有座庙，庙里有个老和尚给小和尚讲故事……’” $$\text{A. 枚举}\quad\text{B. 递归}\quad\text{C. 贪心}\quad\text{D. 分治}$$ 答案：$\text{B}$。 第$11$题由四个没有区别的点构成的简单无向连通图的个数是（ ）。 $$\text{A. }6\quad\text{B. }7\quad\text{C. }8\quad\text{D. }9$$ 答案：$\text{A}$。 如下： 第$12$题设含有$10$个元素的集合的全部子集数为$S$，其中由$7$个元素组成的子集数为$T$，则$T/S$的值为（ ）。 $$\text{A. }5 / 32\quad\text{B. }15 / 128\quad\text{C. }1 / 8\quad\text{D. }21 / 128$$ 答案：$\text{B}$。$T=120,S=1024$。 第$13$题$10000$以内，与$10000$互质的正整数有（ ）个。 $$\text{A. }2000\quad\text{B. }4000\quad\text{C. }6000\quad\text{D. }8000$$ 答案：$\text{B}$。 第$14$题为了统计一个非负整数的二进制形式中$1$的个数，代码如下： 12345678910int CountBit(int x)&#123; int ret = 0; while (x) &#123; ret++; ___________; &#125; return ret;&#125; 则空格内要填入的语句是（ ）。 $$\text{A. }x&gt;&gt;1\quad\text{B. }x\&amp;=x-1\quad\text{C. }x|=x&gt;&gt;1\quad\text{D. }x&lt;&lt;1$$ 答案：$\text{B}$。 第$15$题下图中所使用的数据结构是（ ）。 $$\text{A. 哈希表}\quad\text{B. 栈}\quad\text{C. 队列}\quad\text{D. 二叉树}$$ 答案：$\text{B}$。 问题求解第$1$题甲乙丙丁四人在考虑周末要不要外出郊游。已知①如果周末下雨，并且乙不去，则甲一定不去；②如果乙去，则丁一定去；③如果丙去，则丁一定不去；④如果丁不去，而且甲不去，则丙一定不去。如果周末丙去了，则甲____（去了/没去），乙____（去了/没去），丁____（去了/没去），周末____（下雨/没下雨）。 因为丙去了，由③知：丁没去； 因为丁没去，由②知：乙没去； 因为丁没去，丙去了，由④知：甲去了； 因为甲去了，乙没去，由①知：周末没下雨； 第$2$题从$1$到$2018$这$2018$个数中，共有__个包含数字 8 的数。 $544$个。 阅读程序写结果第$1$题1234567891011#include &lt;cstdio&gt;char st[100];int main() &#123; scanf("%s", st); for (int i = 0; st[i]; ++i) &#123; if ('A' &lt;= st[i] &amp;&amp; st[i] &lt;= 'Z') st[i] += 1; &#125; printf("%s\n", st); return 0;&#125; 输入：QuanGuoLianSai输出：_ 阅读程序可知，此程序的作用是： 将大写字母的ASCII码增加$1$，如$Q → R,G → H$； 将小写字母或其他字符原样输出。 所以结果是：RuanHuoMianTai 第$2$题12345678910111213#include &lt;cstdio&gt;int main() &#123; int x; scanf("%d", &amp;x); int res = 0; for (int i = 0; i &lt; x; ++i) &#123; if (i * i % x == 1) &#123; ++res; &#125; &#125; printf("%d", res); return 0;&#125; 输入：15输出：_ 模拟可得：答案为$4$。 第$3$题12345678910111213#include &lt;iostream&gt;using namespace std;int n, m;int findans(int n, int m) &#123; if (n == 0) return m; if (m == 0) return n % 3; return findans(n - 1, m) - findans(n, m - 1) + findans(n -1, m - 1);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; findans(n, m) &lt;&lt; endl; return 0;&#125; 输入：5 6输出：_ 模拟可得：答案为$8$ 第$4$题123456789101112131415161718192021#include &lt;cstdio&gt;int n, d[100];bool v[100];int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf("%d", d + i); v[i] = false; &#125; int cnt = 0; for (int i = 0; i &lt; n; ++i) &#123; if (!v[i]) &#123; for (int j = i; !v[j]; j = d[j]) &#123; v[j] = true; &#125; ++cnt; &#125; &#125; printf("%d\n", cnt); return 0;&#125; 输入：10 7 1 4 3 2 5 9 8 0 6输出：_ 模拟可得：答案为$6$ 完善程序第$1$题（最大公约数之和）下列程序想要求解整数𝑛的所有约数两两之间最大公约数的和对$10007$求余后的值，试补全程序。（第一空 2 分，其余 3 分） 举例来说，$4$的所有约数是$1,2,4$。$1$和$2$的最大公约数为$1$；$2$和$4$的最大公约数为$2$；$1$和$4$的最大公约数为$1$。于是答案为$1+2+1=4$。 要求getDivisor函数的复杂度为$O(\sqrt{n})$，gcd函数的复杂度为$O(logmax(a,b))$。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;const int N = 110000, P = 10007;int n;int a[N], len;int ans;void getDivisor() &#123; len = 0; for (int i = 1; (1) &lt;= n; ++i) if (n % i == 0) &#123; a[++len] = i; if ( (2) != i) a[++len] = n / i; &#125;&#125;int gcd(int a, int b) &#123; if (b == 0) &#123; (3) ; &#125; return gcd(b, (4) );&#125;int main() &#123; cin &gt;&gt; n; getDivisor(); ans = 0; for (int i = 1; i &lt;= len; ++i) &#123; for (int j = i + 1; j &lt;= len; ++j) &#123; ans = ( (5) ) % P; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 答案： i*i；枚举到$\sqrt{n}$； n/i； return a；注意没有; a%b； gcd(a[i],a[j])+ans。 第$2$题对于一个$1$到$n$的排列$P$（即$1$到$n$中每一个数在$P$中出现了恰好一次），令$q_{i}$为第$i$个位置之后第一个比$P_{i}$值更大的位置，如果不存在这样的位置，则$q_{i}=n+1$。 举例来说，如果$n=5$且$P$为$1 5 4 2 3$，则$q$为$2 6 6 5 6$。下列程序读入了排列$P$，使用双向链表求解了答案。试补全程序。（第二空$2$分，其余$3$分）数据范围$1 \leq n \leq 10^{5}$。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N = 100010;int n;int L[N], R[N], a[N];int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int x; cin &gt;&gt; x; (1) ; &#125; for (int i = 1; i &lt;= n; ++i) &#123; R[i] = (2) ; L[i] = i - 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; L[ (3) ] = L[a[i]]; R[L[a[i]]] = R[ (4) ]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; (5) &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; 答案： a[x]=i i+1 R[a[i]] a[i] R[i]]]></content>
      <categories>
        <category>NOIp</category>
      </categories>
      <tags>
        <tag>NOIp2018</tag>
        <tag>初赛</tag>
        <tag>普及组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【CodeVS 天梯】 青铜 Bronze]]></title>
    <url>%2FSolution%2FCodeVS%2FCodeVS-Bronze%2F</url>
    <content type="text"><![CDATA[原题题目请查看CodeVS 天梯 青铜 Bronze。 题解1201 最小数和最大数1234567891011121314151617181920#include &lt;cstdio&gt;#define INF 0X7FFFFFFF#define min(a, b) ((a) &lt; (b) ? (a) : (b))#define max(a, b) ((a) &gt; (b) ? (a) : (b))int n, temp;int main(void)&#123; register int Min = INF, Max = -INF; scanf("%d", &amp;n); while (n--) &#123; scanf("%d", &amp;temp); Min = min(Min, temp); Max = max(Max, temp); &#125; printf("%d %d\n", Min, Max); return 0;&#125; 1202 求和12345678910111213141516#include &lt;cstdio&gt;int n, temp;int main(void)&#123; register int sum = 0; scanf("%d", &amp;n); while (n--) &#123; scanf("%d", &amp;temp); sum += temp; &#125; printf("%d\n", sum); return 0;&#125; 1203 判断浮点数是否相等123456789101112131415#include &lt;cmath&gt;#include &lt;cstdio&gt;#define eps 1e-8double a, b;int main(void)&#123; scanf("%lf%lf", &amp;a, &amp;b); if (fabs(a - b) &lt; eps) puts("yes"); else puts("no"); return 0;&#125; 1206 保留两位小数12345678910#include &lt;cstdio&gt;double a;int main(void)&#123; scanf("%lf", &amp;a); printf("%.2f\n", a); return 0;&#125; 2235 机票打折123456789101112131415#include &lt;cstdio&gt;int a;double b;int main(void)&#123; scanf("%d%lf", &amp;a, &amp;b); a *= b / 10; if (a % 10 &gt; 4) printf("%d\n", a / 10 * 10 + 10); else printf("%d\n", a / 10 * 10); return 0;&#125; 1204 寻找子串位置1234567891011121314#include &lt;cstdio&gt;#include &lt;iostream&gt;using std::cin;#include &lt;string&gt;using std::string;string a, b;int main(void)&#123; cin &gt;&gt; a &gt;&gt; b; printf("%llu\n", a.find(b) + 1); return 0;&#125; 1205 单词翻转1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;iostream&gt;using std::cin;using std::cout;#include &lt;string&gt;using std::string;#include &lt;stack&gt;using std::stack;string temp;stack&lt;string&gt; S;int main(void)&#123; while (cin &gt;&gt; temp) S.push(temp); cout &lt;&lt; S.top(); S.pop(); while (!S.empty()) &#123; cout &lt;&lt; ' ' &lt;&lt; S.top(); S.pop(); &#125; putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CodeVS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NaOH的变质]]></title>
    <url>%2Fstudy%2Fchemistry%2F9-2%2FNaOH-into-Na2CO3%2F</url>
    <content type="text"><![CDATA[原理$$\ce{2NaOH + CO2 -&gt; Na2CO3 + H2O}$$ 问题这个知识点总共有三个问题：是否变质，变质程度以及除杂。 检验是否变质检验$\ce{NaOH}$是否变质。 分析 未变质：成分为$\ce{NaOH}$； 已变质：成分一定有$\ce{Na2CO3}$。 方法方法有三种。 取样，加足量稀盐酸。有气泡产生，则已变质； 取样，滴加$\ce{BaCl2}$溶液（或$\ce{CaCl2}$溶液）。有白色沉淀，则已变质； 取样，滴加$\ce{Ba(OH)2}$溶液（或$\ce{Ca(OH)2}$溶液）。有白色沉淀，则已变质。 检验变质程度检验$\ce{NaOH}$是完全变质还是部分变质。 分析 部分变质：成分为$\ce{NaOH},\ce{Na2CO3}$； 完全变质：成分为$\ce{Na2CO3}$。 方法 先取样，加入足量的$\ce{BaCl2}$溶液（或$\ce{CaCl2}$溶液）； 目的：除去$\ce{Na2CO3}$，排除对$\ce{NaOH}$检验的干扰。 再向溶液中滴加酚酞试液，若变红，则有$\ce{NaOH}$，为部分变质，否则是完全变质。 除杂除杂$\ce{NaOH}(\ce{Na2CO3})$。 方法原理$$\ce{Na2CO3 + Ba(OH)2 -&gt; 2NaOH + BaCO3 v}$$ 操作滴加适量$\ce{Ba(OH)2}$溶液（或$\ce{Ca(OH)2}$溶液），过滤。]]></content>
      <categories>
        <category>Study-Chemistry</category>
      </categories>
      <tags>
        <tag>化学</tag>
        <tag>初三</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【Codeforces 982A】 Row]]></title>
    <url>%2FSolution%2FCodeforces%2FCodeforces-982A%2F</url>
    <content type="text"><![CDATA[原题题面请查看Codeforces 982A Row。 也可在洛谷上查看：传送门。 题解模拟+字符串 思路此题太水，略去不写。 代码代码如下： 123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;cstring&gt;char str[1002];int n;int main(void)&#123; register int i; scanf("%d%s", &amp;n, str + 1); str[0] = str[n + 1] = '0'; for (i = 1; i &lt;= n; ++i) if (str[i] == '0' &amp;&amp; !(str[i - 1] == '1' || str[i + 1] == '1')) return puts("No"), 0; else if (str[i] == '1' &amp;&amp; (str[i - 1] == '1' || str[i + 1] == '1')) return puts("No"), 0; else continue; puts("Yes"); return 0;&#125; 我的评测记录 Codeforces； 洛谷。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>Codeforces</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杨辉三角]]></title>
    <url>%2FMath%2FPascal's-Triangle%2F</url>
    <content type="text"><![CDATA[杨辉三角是一个形如下面这样的一个三角形。 $$1 \\1 \quad 1 \\1 \quad 2 \quad 1 \\1 \quad 3 \quad 3 \quad 1 \\1 \quad 4 \quad 6 \quad 4 \quad 1 \\…$$ 注：本文中用$\dbinom{n}{k}$代替$C^{k}_{n}$。 杨辉三角的定义杨辉三角有多种定义，这里简单介绍两种： 记$P_{i,j}$表示杨辉三角从上往下第$i$行，从左往右第$j$列的数字。 那么第一种定义方法可以表示成： $$P_{i,j}=\begin{cases}1 &amp; {i=1 \quad \text{or} \quad j=i} \\P_{i-1,j-1}+P_{i-1,j} &amp; {0 &lt; j &lt; i}\end{cases}$$ 第二种定义方法可以表示为： $$P_{i,j}=\dbinom{i-1}{j-1} \quad 0 &lt; j &lt; i$$ 两种定义方法是等价的，证明极其容易，主要原理是$\dbinom{a}{0}=1$以及$\dbinom{n}{k}=\dbinom{n-1}{k-1}+\dbinom{n-1}{k}$。 杨辉三角的奇妙之处$11$的幂如果我们将杨辉三角的每一位连起来，我们就会发现第$n$行的数，正好对应$11$的$n-1$次幂。 注：在十进制下第六层以后要考虑进位。 $$1=11^{0} \\11=11^{1} \\121=11^{2} \\1331=11^{3} \\14641=11^{4} \\1 \quad 5 \quad 10 \quad 10 \quad 5 \quad 1 \to 161051=11^{5} \\…$$ 用公式表达为： $$\sum^{n}_{i=1} 10^{n-i} P_{n,i} =11^{n-1} \quad n &gt; 0$$ 使用第二种定义可表示为： $$\sum^{n}_{i=0} 10^{n-i} \dbinom{n}{i} =11^{n}$$ 规律的证明我们选择使用二项式定理证明。 二项式定理 $$(a+b)^{n}=\sum^{n}_{i=0} \dbinom{n}{i} a^{n-i} b^{i}$$ 令$a=10,b=1$，则得 $$\begin{aligned} 11^{n} &amp; = (10+1)^{n} \\ &amp; = \sum^{n}_{i=0} 10^{n-i} \dbinom{n}{i}\end{aligned}$$ 得证。 斐波那契数列斐波那契数列是一个形如这样的数列： $$1,1,2,3,5,8,13,21,34,…$$ 它的定义是： $$f_{i}=\begin{cases}1 &amp; i=1 \quad \text{or} \quad i=2 \\f_{i-1}+f_{i-2} &amp; i \geq 3\end{cases}$$ 如果我们把杨辉三角排列成一个直角三角形，我们就会发现： $$\begin{aligned}&amp;\swarrow \\&amp; 1 \swarrow \swarrow \\&amp; 1 \quad 1 \swarrow \swarrow \\&amp; 1 \quad 2 \quad 1 \swarrow \swarrow \\&amp; 1 \quad 3 \quad 3 \quad 1 \swarrow \\&amp; 1 \quad 4 \quad 6 \quad 4 \quad 1 \\…\end{aligned}$$ 如果沿着箭头方向的数字相加，我们就能得到一个斐波那契数列。 规律的证明（未完待续）]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>杨辉三角</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P4825】 [USACO15FEB]Cow Hopscotch (Silver) 牛跳房子(银)]]></title>
    <url>%2FSolution%2FLuogu%2FLuogu-P4825%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P4825 [USACO15FEB]Cow Hopscotch (Silver) 牛跳房子(银)。 题解动态规划 思路直接动态规划即可，状态转移方程为： $$f_{ij}=\begin{cases} 1 &amp; {i=j=1} \newline \sum^{i-1}\limits_{k=1} \sum^{j-1}\limits_{l=1} f_{kl} &amp; {a_{ij} \neq a_{kl}} \end{cases}$$ 时间复杂度分析时间复杂度为$\Omega (\frac{n^{4}-n^{2}}{2}),O (\frac{n^{4}}{2})$。 （注：$n$即为题目中的$R,C$） 需要注意的一点是： 如果将数据范围代入算法对应的多项式时间复杂度，所得的数字小于$5 \times 10^{7}$，则这个算法可以在$1 \text{s}$内通过。 把$n=100$带入$\frac{n^{4}}{2}$，得$T(n)=\frac{100^{4}}{2}=5 \times 10^{7}$，预计可以通过。 提示另外，程序运行时间也与计算机性能有关，主要是$\text{CPU}$主频这个参数。 在$\text{C/C++}$中，你可以运行下面这个程序来获取$\text{CPU}$型号和主频。 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#include&lt;cpuid.h&gt;static void cpuid(uint32_t func,uint32_t sub,uint32_t data[4])&#123; __cpuid_count(func,sub,data[0],data[1],data[2],data[3]);&#125;int main(void)&#123; uint32_t data[4]; char str[48]; for(int i=0;i&lt;3;i++)&#123; cpuid(0x80000002+i,0,data); for(int j=0;j&lt;4;j++) reinterpret_cast&lt;uint32_t*&gt;(str)[i*4+j]=data[j]; &#125; printf("%s\n",str); return 0;&#125; 在洛谷$\text{IDE}$下输出： 1Intel(R) Xeon(R) Gold 6149 CPU @ 3.10GHz 算法的优化假如你对算法的时间复杂度实在不放心，你可以进行常数优化。 fread();读入优化，大约可节省$100\text{ms}$的时间； 变量定义类型改为register int； 避免使用long long类型，尽量使用int。 代码代码如下： 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#define MOD 1000000007//宏定义MOD更快#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++)static char buf[100000], *p1 = buf, *p2 = buf;//fread();版读入优化inline int read(void)//读入优化函数&#123; register char ch = getchar(); register int sum = 0; while (!(ch &gt;= '0' &amp;&amp; ch &lt;= '9')) ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') sum = (sum &lt;&lt; 1) + (sum &lt;&lt; 3) + ch - 48, ch = getchar(); return sum;&#125;int n, m, a[1001][1001], f[1001][1001];//变量尽量避免使用long longint main(void)&#123; register int i, j, k, l;//尽量使用寄存器变量 f[1][1] = 1;//动态规划初始化 n = read(), m = read(), read();//k没有用，不要读入 for (i = 1; i &lt;= n; ++i) for (j = 1; j &lt;= m; ++j) &#123; a[i][j] = read(); for (k = 1; k &lt; i; ++k) for (l = 1; l &lt; j; ++l) if (a[k][l] != a[i][j]) f[i][j] = (f[i][j] + f[k][l]) % MOD;//状态转移方程 &#125; printf("%d\n", f[n][m]);//输出并换行 return 0;//结束&#125; 我的评测记录 洛谷 R16320841。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1073】 最优贸易]]></title>
    <url>%2FSolution%2FLuogu%2FLuogu-P1073%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1073 最优贸易。 题解$\text{SPFA}$ 思路进行两次$\text{SPFA}$即可。 算法的优化 fread();读入优化，大约可节省$60\text{ms}$的时间； 存图使用链式前向星； 手写循环队列； 经过优化后，算法的时间复杂度为$\text{O}(n+m+2Km+n)=\text{O}(2n+(2K+1)m)$，可以通过。 代码代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstdio&gt;#include &lt;cstring&gt;#define min(a, b) ((a) &lt; (b) ? (a) : (b))#define max(a, b) ((a) &gt; (b) ? (a) : (b))//宏定义#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++)static char buf[100000], *p1 = buf, *p2 = buf;inline int read(void)//读入优化&#123; register char ch = getchar(); register int sum = 0; while (!(ch &gt;= '0' &amp;&amp; ch &lt;= '9')) ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') sum = (sum &lt;&lt; 1) + (sum &lt;&lt; 3) + ch - 48, ch = getchar(); return sum;&#125;struct Graph&#123; int cnt, head[100001], to[1000001], w[1000001], Next[1000001]; void Add_Edge(int, int, int);&#125;;//链式前向星存图bool vis[100001][2];int a[100001];int Min[100001], Max[100001];int Q[100001], head, tail;Graph L1, L2;void SPFA1(int);void SPFA2(int);int main(void)&#123; register int n, m, i, ans = 0, x, y, z; n = read(), m = read(); for (i = 1; i &lt;= n; ++i) a[i] = read(); for (i = 1; i &lt;= m; ++i) &#123; x = read(), y = read(), z = read(); L1.Add_Edge(x, y, a[y]), L2.Add_Edge(y, x, a[x]); if (z == 2)//双向边 L1.Add_Edge(y, x, a[x]), L2.Add_Edge(x, y, a[y]); &#125; SPFA1(1), SPFA2(n);//两次SPFA for (i = 1; i &lt;= n; ++i) ans = max(ans, Max[i] - Min[i]);//max()求答案 printf("%d\n", ans);//输出并换行 return 0;//结束程序&#125;void Graph::Add_Edge(int f, int t, int val)&#123; Next[++cnt] = head[f]; to[cnt] = t; w[cnt] = val; head[f] = cnt; return;&#125;void SPFA1(int s)&#123; register int i, ID, To; head = tail = 0; memset(Q, 0, sizeof(Q)); memset(Min, 0X3F, sizeof(Min)); vis[s][1] = true; Q[tail++] = s; while (head!=tail) &#123; ID = Q[head++]; if (head &gt;= 100001) head %= 100001; vis[ID][1] = false; for (i = L1.head[ID]; i; i = L1.Next[i]) &#123; To = L1.to[i]; if (Min[To] &gt; min(Min[ID], L1.w[i])) &#123; Min[To] = min(Min[ID], L1.w[i]); if (!vis[To][1]) &#123; vis[To][1] = true; Q[tail++] = To; if (tail &gt;= 100001) tail %= 100001; &#125; &#125; &#125; &#125; return;&#125;void SPFA2(int s)&#123; register int i, ID, To; head = tail = 0; memset(Q, 0, sizeof(Q)); vis[s][0] = true; Q[tail++] = s; while (head!=tail) &#123; ID = Q[head++]; if (head &gt;= 100001) head %= 100001; vis[ID][0] = false; for (i = L2.head[ID]; i; i = L2.Next[i]) &#123; To = L2.to[i]; if (Max[To] &lt; max(Max[ID], L2.w[i])) &#123; Max[To] = max(Max[ID], L2.w[i]); if (!vis[To][0]) &#123; vis[To][0] = true; Q[tail++] = To; if (tail &gt;= 100001) tail %= 100001; &#125; &#125; &#125; &#125; return;&#125; 我的评测记录 洛谷 R16277015。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>图论</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manim的安装指南（Windows）]]></title>
    <url>%2FCourse%2FManim%2F</url>
    <content type="text"><![CDATA[网上的教程都不够详细，并且早已过时。 $\text{Manim}$项目地址。 前期准备 $\text{Manim}$基于$\text{Python}3.7$，请确保$\text{Windows}$下安装了$\text{Python}3.7$； $\text{Manim}$托管于$\text{GitHub}$，请确保$\text{Windows}$下安装了$\text{GitHub}$； 请确保$\text{pip}$的版本是最新的。 $\text{Manim}$及其环境的配置随便找一个目录，按住Shift键并右键选择在此处打开 PowerShell 窗口（$\text{Windows}10$以下的系统显示的是命令提示符）。 输入命令： 12git clone https://github.com/3b1b/manim.gitcd manim 完成后可以发现原目录下多了一个叫做manim的文件夹，这就是以后的工作目录。 继续在之前的窗口中输入命令（或者在manim文件夹中打开$\text{PowerShell}$窗口）： 1python -m pip install -r requirements.txt 问题常见问题： 在这一步中如果看到类似于Error或者Visual Build 14.0的字样，请自行上网搜索解决办法，搜索引擎推荐使用$\text{Google}$。 如果看到形如ModuleNotFoundError: No module named &lt;pack name&gt;的错误提示，请运行命令： 1pip install &lt;pack name&gt; 特别的，如果遇见ModuleNotFoundError: No module named &#39;readline&#39;，请输入： 1pip install pyreadline 测试输入命令： 1python -m manim example_scenes.py SquareToCircle -pl 如果弹出了一段下面这样的视频（分辨率为$854 \times 480$，帧率为$15 \text{FPS}$），说明$\text{Manim}$配置成功。 常见问题： 如果看到形如ModuleNotFoundError: No module named &lt;pack name&gt;的错误提示，请运行命令： 1pip install &lt;pack name&gt; 特别的，如果遇见ModuleNotFoundError: No module named &#39;readline&#39;，请输入： 1pip install pyreadline 欣赏影片以下影片分辨率为$1280 \times 720$，帧率为$30 \text{FPS}$]]></content>
      <categories>
        <category>Course</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Manim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】 树]]></title>
    <url>%2FDataStructure%2FTree%2F</url>
    <content type="text"><![CDATA[介绍树是一种数据结构，它是由$n(n \geq 1)$个有限结点组成一个具有层次关系的集合。 树的定义自然树显然，计算机的树与自然界中的树（后文简称为自然树）有所联系，否则它就不会以树为名称了。 下面我们先来看看自然树： 归纳一下自然树的特征： 有且只有一个树根； 树会分叉； 树枝的末端是叶子。 计算机中的树根据自然树的特征，我们给出树的定义：（共有$3$种） 集合定义： 树是包含$n(n \geq 0)$个结点的有穷集，其中： 每个元素称为结点； 有一个特定的结点被称为根结点或树根； 除根结点之外的其余数据元素被分为$m(m \geq 0)$个互不相交的集合$T_{1},T_{2},…,T_{m}$，其中每一个集合$T_{i}(1 \leq i \leq m)$本身也是一棵树，被称作原树的子树。 关系定义（层次定义）： 树是由根结点和若干颗子树构成的； 树是由一个集合以及在该集合上定义的一种关系构成的。集合中的元素称为树的结点，所定义的关系称为父子关系； 父子关系在树的结点之间建立了一个层次结构。在这种层次结构中有一个结点具有特殊的地位，这个结点称为该树的根结点，或称为树根。 递归定义： 单个结点是一棵树，树根就是该结点本身。 设$T_{1},T_{2},…,T_{k}$是树，它们的根结点分别为$n_{1},n_{2},…,n_{k}$。用一个新结点$n$作为$n_{1},n_{2},…,n_{k}$的父亲，则得到一棵新树，结点$n$就是新树的根。我们称$n_{1},n_{2},…,n_{k}$为一组兄弟结点，它们都是结点$n$的子结点。我们还称$T_{1},T_{2},…,T_{k}$为结点$n$的子树。 空集合也是树，称为空树。空树中没有结点。 树的表示方法图像法图像法是最常见的树的表示方法。 用图像表示树，一目了然。 遍历法此方法只适用于二叉树。 二叉树有多种遍历方法，最常见的是先序遍历，中序遍历，后序遍历以及层次遍历。 用先序遍历，中序遍历，后序遍历既可以表达二叉树又可以确定二叉树。 其先序遍历为：1 2 4 6 3 7 5 8 9； 其中序遍历为：4 2 6 1 7 3 8 5 9； 其后序遍历为：4 6 2 7 8 9 5 3 1。 除此之外还有符号法等方法可以表示树。 树的储存方法树的储存方法有多种，此处不展开说明。 推荐使用链式前向星存双向边。]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【Codeforces 579A】 Raising Bacteria]]></title>
    <url>%2FSolution%2FCodeforces%2FCodeforces-579A%2F</url>
    <content type="text"><![CDATA[原题题面请查看Codeforces 579A Raising Bacteria。 也可在洛谷上查看：传送门。 题解模拟+二进制 思路此题太水，略去不写。 代码代码如下： 1234567891011121314151617#include &lt;cstdio&gt;int x;int main(void)&#123; register int cnt = 0; scanf("%d", &amp;x); while (x) &#123; if (x &amp; 1) ++cnt; x &gt;&gt;= 1; &#125; printf("%d\n", cnt); return 0;&#125; 我的评测记录 Codeforces； 洛谷。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>Codeforces</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【Codeforces 574A】 Bear and Elections]]></title>
    <url>%2FSolution%2FCodeforces%2FCodeforces-574A%2F</url>
    <content type="text"><![CDATA[原题题面请查看Codeforces 574A Bear and Elections。 也可在洛谷上查看：传送门。 洛谷题面翻译来自@卢安来，其实就是我。 题解模拟+排序 思路根据正常人的想法和思维，选票最多的人是Limak最大的敌人，我们应该多贿赂他的支持者。 因为每次贿赂后，选票最多的人都会改变，所以我们每次操作（实行贿赂）后进行排序即可。 具体实现设vote为Limak当前选票，那么每次的操作就可以写成这样： 1234567while (a[n - 1] &gt;= vote) //如果Limak无法获胜&#123; //开始贿赂 --a[n - 1]; //贿赂选票最多的人的一名支持者 sort(a + 1, a + n); //重新排序 ++vote; //Limak的选票增加 ++ans; //计数器自增&#125; 代码代码如下： 1234567891011121314151617181920212223#include &lt;algorithm&gt;#include &lt;cstdio&gt;using std::sort; //排序int n, vote, a[101]; //变量如上文所述int main(void)&#123; register int i, ans = 0; scanf("%d%d", &amp;n, &amp;vote); //读入 for (i = 1; i &lt; n; ++i) //除去Limak还有n-1个人 scanf("%d", &amp;a[i]); sort(a + 1, a + n); //要先排序 while (a[n - 1] &gt;= vote) //如果Limak无法获胜 &#123; //开始贿赂 --a[n - 1]; //贿赂选票最多的人的一名支持者 sort(a + 1, a + n); //重新排序 ++vote; //Limak的选票增加 ++ans; //计数器自增 &#125; printf("%d\n", ans); //输出并换行 return 0;&#125; 我的评测记录 Codeforces； 洛谷。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>Codeforces</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【AtCoder Code Festival Team Relay A】 Kaiden]]></title>
    <url>%2FSolution%2FAtCoder%2FAtCoder-Code-Festival-Team-Relay-A%2F</url>
    <content type="text"><![CDATA[原题题面请查看AtCoder ABC004-C 入れ替え。 也可在洛谷上查看：传送门。 题解模拟 思路此题太水，略去不写。 代码代码如下： 123456789101112131415#include &lt;cstdio&gt;long long a, b, k;int main(void)&#123; scanf("%lld%lld%lld", &amp;k, &amp;a, &amp;b); if (k &lt;= a) puts("1"); else if (a &lt;= b) puts("-1"); else printf("%lld\n", ((k - a) / (a - b) + bool((k - a) % (a - b))) &lt;&lt; 1 | 1); return 0;&#125; 我的评测记录 AtCoder； 洛谷 R16137986。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P2683】 小岛]]></title>
    <url>%2FSolution%2FLuogu%2FLuogu-P2683%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P2683 小岛。 题解$\text{Dijkstra}$ 思路每一次查询都进行一遍$\text{Dijkstra}$求单源最短路径。 算法的优化 fread();读入优化，大约可节省$100\text{ms}$的时间； 存图应使用链式前向星； 使用堆（或者std::priority_queue）优化； 经过优化后，算法的时间复杂度为$\text{O}(mnlog_{2}n+m^{2})$。 代码代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using std::less;using std::priority_queue;using std::vector; //头文件和引用#define INF 0X3F3F3F3F //定义正无穷#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++)static char buf[100000], *p1 = buf, *p2 = buf; //fread();读入优化inline int read(void)&#123; register char ch = getchar(); register int sum = 0; while (!(ch &gt;= '0' &amp;&amp; ch &lt;= '9')) ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') sum = sum * 10 + ch - 48, ch = getchar(); return sum;&#125;struct Node&#123; int ID, dis; bool operator&lt;(const Node &amp;a) const &#123; return dis &gt; a.dis; &#125;&#125;;bool vis[101];int cnt, head[101], to[10001], w[10001], Next[10001];int dis[101];priority_queue&lt;Node, vector&lt;Node&gt;, less&lt;Node&gt;&gt; Q; //优先队列void Add_Edge(int, int, int);void Dijkstra(int);int main(void)&#123; register int m, op, s, t, u, v, e; //register变量更快些 read(); //n在本题中没有用，也无超过n的毒瘤数据，无需读入 m = read(); //读入m while (m--) &#123; op = read(); if (op == 0) &#123; s = read(), t = read(); Dijkstra(s); printf("%d\n", (dis[t] == INF) ? (-1) : (dis[t])); &#125; if (op == 1) &#123; u = read(), v = read(), e = read(); Add_Edge(u, v, e); Add_Edge(v, u, e); //双向边 &#125; &#125; return 0;&#125;void Add_Edge(int f, int t, int val) //链式前向星存图&#123; Next[++cnt] = head[f]; to[cnt] = t; w[cnt] = val; head[f] = cnt; return;&#125;void Dijkstra(int s)&#123; register int i, ID, To; Node temp; memset(vis, false, sizeof(vis)); memset(dis, 0X3F, sizeof(dis)); dis[s] = 0; //每次运行前要记得初始化 temp.ID = s, temp.dis = 0; Q.push(temp); while (!Q.empty()) &#123; temp = Q.top(); Q.pop(); ID = temp.ID; if (vis[ID]) continue; vis[ID] = true; for (i = head[ID]; i; i = Next[i]) &#123; To = to[i]; if (dis[To] &gt; dis[ID] + w[i]) &#123; dis[To] = dis[ID] + w[i]; //松弛操作 temp.ID = To, temp.dis = dis[To]; Q.push(temp); &#125; &#125; &#125; return; //返回&#125; 我的评测记录 洛谷 R16112574。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1198】 [JSOI2008]最大数]]></title>
    <url>%2FSolution%2FLuogu%2FLuogu-P1198%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1198 [JSOI2008]最大数。 题解线段树 思路为节省写代码的时间，我们采用阉割版线段树（只具有单点修改和区间查询两个功能）。 具体实现过程 定义空树Tree，记len为当前数列的长度； 模拟操作： 查询操作： 记T=Tree.Query(1,1,m,len-L+1,len)，输出T并换行即可； 插入操作： 单点修改：Tree.Update(1,1,m,++len,(num+T)%D)； 结束。 代码代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#define INF 0X3F3F3F3F3F3F3F3F//定义正无穷#define max(a, b) ((a) &gt; (b) ? (a) : (b))//定义max()函数typedef long long llstruct Segment_Tree //线段树模板&#123; ll unit[(200000 &lt;&lt; 2) + 1]; //线段树空间要开到4倍 void Update(int, int, int, int, ll); //更新函数 ll Query(int, int, int, int, int); //查询函数&#125;;char ch[2];//操作符int m, len;//len表示数列长度ll D, T, num;Segment_Tree Tree; //线段树int main(void)&#123; register int i; scanf("%d%lld", &amp;m, &amp;D);//读入 for (i = 1; i &lt;= m; ++i)//模拟 &#123; scanf("%s%lld", ch, &amp;num); if (ch[0] == 'Q') &#123; if (!num) T = 0; else T = Tree.Query(1, 1, m, len - num + 1, len) % D;//查询 printf("%lld\n", T);//输出并换行 &#125; if (ch[0] == 'A') &#123; ++len;//数列边长 Tree.Update(1, 1, m, len, (num + T) % D);//更新 &#125; &#125; return 0;&#125;void Segment_Tree::Update(int ID, int l, int r, int index, ll val)&#123; if (l == r) unit[ID] = val; else &#123; register int mid = (l + r) &gt;&gt; 1; if (index &lt;= mid) Update(ID &lt;&lt; 1, l, mid, index, val); //更新左子树 if (index &gt; mid) Update(ID &lt;&lt; 1 | 1, mid + 1, r, index, val); //更新右子树 unit[ID] = max(unit[ID &lt;&lt; 1], unit[ID &lt;&lt; 1 | 1]) % D; &#125; return;&#125;ll Segment_Tree::Query(int ID, int l, int r, int x, int y)&#123; if (x &lt;= l &amp;&amp; r &lt;= y) return unit[ID]; register int mid = (l + r) &gt;&gt; 1; register ll a = -INF, b = -INF; if (x &lt;= mid) a = Query(ID &lt;&lt; 1, l, mid, x, y); //查询左子树 if (y &gt; mid) b = Query(ID &lt;&lt; 1 | 1, mid + 1, r, x, y); //查询右子树 return max(a, b); //返回查询结果&#125; 我的评测记录 洛谷 R16096515。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>JSOI2008</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1340】 兽径管理]]></title>
    <url>%2FSolution%2FLuogu%2FLuogu-P1340%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1340 兽径管理。 题解$\text{Kruskal}$算法 思路 先读入所有边，每条边以时间为编号ID； 对边以边权为关键字进行排序； 以$1$~$w$为参数进行$\text{Kruskal}$算法： 如果这条边的编号大于所给参数，这条边不参与算法； 否则寻找最小生成树。 输出答案。 代码代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include &lt;cstdio&gt;//头文件using std::sort;//快速排序struct Edge//定义 边 的结构体&#123; int ID, f, t, val; bool operator&lt;(const Edge &amp;a) const &#123; return val &lt; a.val; &#125;&#125;;struct Union_Find//定义 并查集 的结构体&#123; int ID[201]; Union_Find(int);//析构函数，用于并查集的初始化，参数为n void connect(int, int);//并 bool search(int, int);//查 int find(int);//查&#125;;int n, w;Edge E[6001];int Kruskal(int);int main(void)&#123; register int i; scanf("%d%d", &amp;n, &amp;w); for (i = 1; i &lt;= w; ++i) &#123; E[i].ID = i;//每条边以时间为编号 scanf("%d%d%d", &amp;E[i].f, &amp;E[i].t, &amp;E[i].val);//读入 &#125; sort(E + 1, E + w + 1);//快速排序 for (i = 1; i &lt;= w; ++i) printf("%d\n", Kruskal(i));//调用函数并输出结果 return 0;//在主函数末尾加上return 0;是一个好习惯&#125;Union_Find::Union_Find(int n)//析构函数，用于并查集的初始化，参数为n&#123; register int i; for (i = 1; i &lt;= n; ++i) ID[i] = i; return;&#125;void Union_Find::connect(int a, int b)&#123; register int ra = find(a), rb = find(b); if (ra != rb) ID[rb] = ra; return;&#125;bool Union_Find::search(int a, int b)&#123; return find(a) == find(b);&#125;int Union_Find::find(int x)&#123; if (x == ID[x]) return x; else return ID[x] = find(ID[x]);//路径压缩&#125;int Kruskal(int time)&#123; register int i, cnt = 0, sum = 0; //cnt为连接边的数量 Union_Find UF(n);//先定义一个并查集UF，析构函数的参数为n for (i = 1; i &lt;= w &amp;&amp; cnt &lt; n - 1; ++i) if (E[i].ID &gt; time)//如果这条边的编号大于所给参数，这条边不参与算法 continue; else if (!UF.search(E[i].f, E[i].t))//如果这条边连接的两个点不在同一个集合内 &#123; ++cnt; sum += E[i].val; UF.connect(E[i].f, E[i].t); &#125;//统计答案 if (cnt != n - 1)//如果无法构成树 return -1;//题目要求输出-1 else return sum;//返回答案&#125; 我的评测记录 洛谷 R16089070。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P2574】 XOR的艺术]]></title>
    <url>%2FSolution%2FLuogu%2FLuogu-P2574%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P2574 XOR的艺术。 题解线段树 思路把线段树的LazyTag[]的更新方式修改一下即可，其他可照抄线段树模板。 更新LazyTag[]的方式 左右子树的LazyTag[]都要对一按位异或； 代码表示为： 12tag[ID &lt;&lt; 1] ^= 1;tag[ID &lt;&lt; 1 | 1] ^= 1; 左右子树的值全部变成区间长度减去当前值； 代码表示为： 123register int len = r - l + 1;//len为当前节点区间长度unit[ID &lt;&lt; 1] = (len - (len &gt;&gt; 1)) - unit[ID &lt;&lt; 1];//左子树根节点区间长度为(len - (len &gt;&gt; 1))unit[ID &lt;&lt; 1 | 1] = (len &gt;&gt; 1) - unit[ID &lt;&lt; 1 | 1];//右子树根节点区间长度为(len &gt;&gt; 1) 代码代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;//头文件struct Segment_Tree//线段树模板&#123; int unit[(200000 &lt;&lt; 2) + 1], tag[(200000 &lt;&lt; 2) + 1];//线段树空间要开到4倍 void Build(int, int, int, bool[]);//建树函数 void Update(int, int, int, int, int);//更新函数 int Query(int, int, int, int, int);//查询函数 void Pushdown(int, int, int);//更新LazyTag[]的函数&#125;;bool a[200001];int n, m;Segment_Tree Tree;//线段树int main(void)&#123; register int i; scanf("%d%d", &amp;n, &amp;m); for (i = 1; i &lt;= n; ++i) &#123; static int temp; scanf("%1d", &amp;temp); a[i] = temp; &#125; Tree.Build(1, 1, n, a);//建树 while (m--) &#123; static int opt, l, r; scanf("%d%d%d", &amp;opt, &amp;l, &amp;r); if (opt == 0)//更新 Tree.Update(1, 1, n, l, r); if (opt == 1)//查询 printf("%d\n", Tree.Query(1, 1, n, l, r));//输出查询结果并换行 &#125; return 0;//结束时加上return 0;是一个好习惯&#125;void Segment_Tree::Build(int ID, int l, int r, bool a[])&#123; if (l == r) unit[ID] = a[l];//递归停止 else &#123; register int mid = (l + r) &gt;&gt; 1; Build(ID &lt;&lt; 1, l, mid, a);//构建左子树 Build(ID &lt;&lt; 1 | 1, mid + 1, r, a);//构建左子树 unit[ID] = unit[ID &lt;&lt; 1] + unit[ID &lt;&lt; 1 | 1]; &#125; return;&#125;void Segment_Tree::Update(int ID, int l, int r, int x, int y)&#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; unit[ID] = (r - l + 1) - unit[ID]; tag[ID] ^= 1; &#125; else &#123; Pushdown(ID, l, r); int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) Update(ID &lt;&lt; 1, l, mid, x, y);//更新左子树 if (y &gt; mid) Update(ID &lt;&lt; 1 | 1, mid + 1, r, x, y);//更新右子树 unit[ID] = unit[ID &lt;&lt; 1] + unit[ID &lt;&lt; 1 | 1]; &#125; return;&#125;int Segment_Tree::Query(int ID, int l, int r, int x, int y)&#123; if (x &lt;= l &amp;&amp; r &lt;= y) return unit[ID]; Pushdown(ID, l, r);//更新LazyTag[] int mid = (l + r) &gt;&gt; 1, sum = 0; if (x &lt;= mid) sum += Query(ID &lt;&lt; 1, l, mid, x, y);//查询左子树 if (y &gt; mid) sum += Query(ID &lt;&lt; 1 | 1, mid + 1, r, x, y);//查询右子树 return sum;//返回查询结果&#125;void Segment_Tree::Pushdown(int ID, int l, int r)&#123; register int len = r - l + 1; if (tag[ID]) &#123; tag[ID &lt;&lt; 1] ^= 1; tag[ID &lt;&lt; 1 | 1] ^= 1; //左右子树的LazyTag[]都要对一按位异或 unit[ID &lt;&lt; 1] = (len - (len &gt;&gt; 1)) - unit[ID &lt;&lt; 1]; unit[ID &lt;&lt; 1 | 1] = (len &gt;&gt; 1) - unit[ID &lt;&lt; 1 | 1]; //左右子树的值全部变成区间长度减去当前值 tag[ID] = 0;//记得清空当前节点的标记 &#125; return;&#125; 我的评测记录 洛谷 R16079272。 其他线段树模板的代码算中等长度，下面我们来压行。 源代码共$102$行，压行后$7$行。 压行的评测记录：洛谷 R16080174。 1234567#include &lt;cstdio&gt;int n, m, opt, l, r,unit[(200000 &lt;&lt; 2) + 1], tag[(200000 &lt;&lt; 2) + 1];void Build(int ID, int l, int r)&#123;(l == r)?(scanf("%1d", &amp;unit[ID])):(Build(ID &lt;&lt; 1, l, ((l + r) &gt;&gt; 1)),Build(ID &lt;&lt; 1 | 1, ((l + r) &gt;&gt; 1) + 1, r),unit[ID] = unit[ID &lt;&lt; 1] + unit[ID &lt;&lt; 1 | 1]);&#125;void Pushdown(int ID, int l, int r)&#123;tag[ID]?(tag[ID &lt;&lt; 1] ^= 1,tag[ID &lt;&lt; 1 | 1] ^= 1,unit[ID &lt;&lt; 1] = ((r - l + 1) - ((r - l + 1) &gt;&gt; 1)) - unit[ID &lt;&lt; 1],unit[ID &lt;&lt; 1 | 1] = ((r - l + 1) &gt;&gt; 1) - unit[ID &lt;&lt; 1 | 1],tag[ID] = 0):0;&#125;void Update(int ID, int l, int r, int x, int y)&#123;(x &lt;= l &amp;&amp; r &lt;= y)?(unit[ID] = (r - l + 1) - unit[ID],tag[ID] ^= 1,0):(Pushdown(ID, l, r),((x &lt;= ((l + r) &gt;&gt; 1))?(Update(ID &lt;&lt; 1, l, ((l + r) &gt;&gt; 1), x, y),0):0),((y &gt; ((l + r) &gt;&gt; 1))?(Update(ID &lt;&lt; 1 | 1, ((l + r) &gt;&gt; 1) + 1, r, x, y),0):0),unit[ID] = unit[ID &lt;&lt; 1] + unit[ID &lt;&lt; 1 | 1],0);&#125;int Query(int ID, int l, int r, int x, int y)&#123;return ((x &lt;= l &amp;&amp; r &lt;= y)?(unit[ID]):(Pushdown(ID, l, r),((x &lt;= ((l + r) &gt;&gt; 1))?(Query(ID &lt;&lt; 1, l, ((l + r) &gt;&gt; 1), x, y)):0)+((y &gt; ((l + r) &gt;&gt; 1))?(Query(ID &lt;&lt; 1 | 1, ((l + r) &gt;&gt; 1) + 1, r, x, y)):0)));&#125;int main(void)&#123;scanf("%d%d", &amp;n, &amp;m),Build(1, 1, n);while (m--)(scanf("%d%d%d", &amp;opt, &amp;l, &amp;r),opt==0)?(Update(1, 1, n, l, r),0):(printf("%d\n",Query(1, 1, n, l, r)));&#125; 也许这就是压行的艺术。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT主题搭建博客教程（Windows）]]></title>
    <url>%2FCourse%2FHexo-NexT%2F</url>
    <content type="text"><![CDATA[网上的教程都不够详细，本人自己写一篇。 前期准备注册$\text{GitHub}$账号；先注册一个$\text{GitHub}$账号，官网传送门：$\text{GitHub}$； 安装$\text{Git}$；下载$\text{Git}$到本地并安装，你可以到官网：$\text{Git}$处下载安装包。 安装时全程按Next即可。 安装$\text{Node.js}$；下载$\text{Node.js}$到本地并安装，你可以到官网：$\text{Node.js}$处下载安装包（推荐选择$\text{LTS}$版）。 安装时全程按Next即可。 配置本地$\text{Git}$；未完待续。 在$\text{GitHub}$中新建一个Repository；未完待续。 搭建博客安装并配置$\text{Hexo}$新建一个文件夹，作为根目录用来存放博客文件（文件夹名任意，推荐命名成&lt;username&gt;.github.io，其中&lt;username&gt;是你$\text{GitHub}$的$\text{ID}$）。 然后在根目录中右键，选择Git Bash Here，然后在弹出来的窗口里输入命令npm install -g hexo（后文所说的输入命令都在此窗口输入），然后耐心等待。 注：等待时间从$2 \text{s} $到$30 \text{min}$不等，请耐心等待，中途不要进行任何操作。 如果出现了一长串代码，又没有ERROR提示出现的话，就是安装$\text{Hexo}$成功了。 接着输入：hexo init和npm install，如果弄完之后文件夹变成了这样： 那就没问题了。 预览博客在Git Bash窗口中输入hexo s，预览博客。 如果窗口中出现效果如下图，表明进行预览成功： 再打开网址http://localhost:4000/，即可对博客进行预览。 预览结束后一定要按Ctrl+C关闭预览。 至此博客搭建完成，但仍无法在公网上查看。 部署博客至$\text{GitHub}$输入命令npm install hexo-deployer-git --save安装deployer。 打开根目录下的_config.yml，按Ctrl+F搜索关键词deploy，找到形如下面的内容： 1234deploy: type: git repository: branch: 改成： 1234deploy: type: git repository: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 依次然后输入命令： 123hexo cleanhexo ghexo d 如果没有出错的话，等几分钟，再用浏览器打开&lt;username&gt;.github.io，就可以看到你的博客了。（此时别人也可以通过这个网址看到你的博客） 常见问题问题：输入hexo d后显示deployer not found:git； 解决办法： 修改根目录名称为&lt;username&gt;.github.io，某些时候有玄学问题，不是你仓库对应的名称部署不上去； 检查_config.yml文件内容是否完整，注意每一个:后面都有且只有一个空格； 输入命令npm install hexo-deployer-git --save； 再次尝试部署至$\text{GitHub}$。 美化博客博客主题作者推荐使用$\text{NexT}$主题。 未完待续。]]></content>
      <categories>
        <category>Course</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>NexT主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【AtCoder dwacon2017-prelims-A】 動画検索]]></title>
    <url>%2FSolution%2FAtCoder%2FAtCoder-dwacon2017-prelims-A%2F</url>
    <content type="text"><![CDATA[原题题面请查看AtCoder dwacon2017-prelims-A 動画検索。 也可在洛谷上查看：传送门。 题解模拟 思路模拟即可，注意答案的合法性。 代码代码如下： 123456789101112#include &lt;cstdio&gt;int n, a, b;int main(void)&#123; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); if(a+b&gt;n) printf("%d\n", a + b - n); else puts("0"); return 0;&#125; 我的评测记录 AtCoder； 洛谷 R16059768。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【AtCoder ABC004-C】 入れ替え]]></title>
    <url>%2FSolution%2FAtCoder%2FAtCoder-ABC004-C%2F</url>
    <content type="text"><![CDATA[原题题面请查看AtCoder ABC004-C 入れ替え。 也可在洛谷上查看：传送门。 题解模拟 思路答案$30$一循环，模拟即可。 代码代码如下： 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;char str[7] = "123456";int a;void swap(char&amp;, char&amp;);int main(void)&#123; register int i, now = 0; scanf("%d", &amp;a); a %= 30; for (i = 0; i &lt; a; ++i) &#123; swap(str[now], str[now + 1]); if (++now == 5) now = 0; &#125; puts(str); return 0;&#125;void swap(char&amp; a, char&amp; b)&#123; a ^= b, b = a ^ b, a ^= b; return;&#125; 我的评测记录 AtCoder； 洛谷 R16059682。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】 并查集]]></title>
    <url>%2FDataStructure%2FUnion-Find%2F</url>
    <content type="text"><![CDATA[介绍并查集是一种数据结构，体现的是森林（或者树）形态，主要操作有两种： 并，意为合并，操作函数为void connect(int,int);（注：connect vt. &amp; vi. 连接）； 查，意为查询： 查询一个节点的父亲节点，查询函数为int find(int);（注：find v. 寻找）； 查询两个节点是否在用一个集合内，查询函数为bool search(int,int);（注：search v. 搜寻）。 具体思路与实现首先，因为并查集是森林（或者树）的一种，所以我们可以用树的三种表示方法其中之一——父亲结点表示法（其它两种方法是儿子结点表示法和儿子、兄弟表示法）。 定义数组ID[n]（一般编程时数组下标从$1$开始，应使用ID[n+1]），ID[i]表示第$i$个结点当前状态下的父亲。 假设有$n$个结点，为了方便，我们将每一个结点初始的父亲设为它自己。 代码实现如下： 12345678910#define n 100000//假设n=10^5int ID[n+1];void Init(void)&#123;//初始化函数 register int i; for(i=1;i&lt;=n;++i) ID[i]=i; return;&#125; 初始化后的示意图如下： 下面重点介绍如何查询一个节点的父亲节点。 int find(int);不带路径压缩用find(x)表示x的父亲结点的编号。 代码实现如下： 123456int find(int x)&#123; if(x==ID[x])//如果x的父亲结点是自己 return x;//返回x，停止递归 else return find(ID[x]);//继续递归查找父亲结点&#125; 用图理解如下： 设$n=5$，此时并查集的状态如下： 运行find(5)，过程如下： 12345678入口--开始--&gt;运行5时5的父亲结点是3运行5时5的父亲结点是3--继续递归--&gt;运行3时3的父亲结点是2运行3时3的父亲结点是2--继续递归--&gt;运行2时2的父亲结点是1运行2时2的父亲结点是1--继续递归--&gt;运行1时1的父亲结点是自己运行1时1的父亲结点是自己--返回1--&gt;运行2时2的父亲结点是1运行2时2的父亲结点是1--返回1--&gt;运行3时3的父亲结点是2运行3时3的父亲结点是2--返回1--&gt;运行5时5的父亲结点是3运行5时5的父亲结点是3--结束 返回1--&gt;入口 如果还不能理解的话，请手动模拟。 路径压缩用find(x)表示x的父亲结点的编号。 代码实现如下： 123456int find(int x)&#123; if(x==ID[x])//如果x的父亲结点是自己 return x;//返回x，停止递归 else return ID[x]=find(ID[x]);//继续递归查找父亲结点，并赋值以压缩路径&#125; 用图理解如下： 设$n=5$，此时并查集的状态如下： 运行find(5)，过程如下： 12345678入口--开始--&gt;运行5时5的父亲结点是3运行5时5的父亲结点是3--继续递归--&gt;运行3时3的父亲结点是2运行3时3的父亲结点是2--继续递归--&gt;运行2时2的父亲结点是1运行2时2的父亲结点是1--继续递归--&gt;运行1时1的父亲结点是自己运行1时1的父亲结点是自己--返回1--&gt;运行2时2的父亲结点是1运行2时2的父亲结点是1--返回1 并将2的父亲结点改为1--&gt;运行3时3的父亲结点是2运行3时3的父亲结点是2--返回1 并将3的父亲结点改为1--&gt;运行5时5的父亲结点是3运行5时5的父亲结点是3--结束 返回1 并将5的父亲结点改为1--&gt;入口 运行过后，整个并查集的状态发生了改变，变成了这样： 在这次操作之后，再次调用find(5)只需要$\text{O} (1)$的时间。 void connect(int,int);在此之前，我们已经实现了int find(int);，那么其他的两个操作都比较简单，具体实现如下： 12345678910void connect(int a,int b)&#123; register int ra=find(a),rb=find(b);//寻找a和b的祖先节点，记为ra,rb if(ra!=rb)//假如a,b的祖先节点不同 ID[rb]=ra;//把rb的父亲节点设为ra return;&#125;bool search(int a,int b)&#123; return find(a)==find(b);//比较a,b的祖先节点是否相同&#125; 下面是一个具体的例子： 设$n=6$，此时并查集的状态如下。 123456ID[1]=1;ID[2]=1;ID[3]=2;ID[4]=5;ID[5]=5;ID[6]=6; 用图表示为： 执行操作connect(4,6)： $4$的祖先是$5$，$6$的祖先是它本身； 显然，$5 \ne 6$； 所以把$6$的祖先设置为$5$； 结束。 操作完成后： 123456ID[1]=1;ID[2]=1;ID[3]=2;ID[4]=5;ID[5]=5;ID[6]=5;//主要操作 用图表示为： 执行操作connect(6,3)： $6$的祖先是$5$，$3$的祖先是$1$； 显然，$5 \ne 1$； 所以把$1$的祖先设置为$5$； 结束。 操作完成后： 123456ID[1]=5;//主要操作ID[2]=1;ID[3]=1;//find()过程中进行了路径压缩ID[4]=5;ID[5]=5;ID[6]=5; 用图表示为： 模板题洛谷：P3367 【模板】并查集； 代码： 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int n,m,ID[10001],i,z,x,y;int find(int x)&#123; if(ID[x]==x) return x; else return ID[x]=find(ID[x]);&#125;void contact(int a,int b)&#123; int ra=find(a),rb=find(b); if(ra!=rb) ID[rb]=ra; return;&#125;bool search(int a,int b)&#123; return find(a)==find(b);&#125;int main(void)&#123; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++) ID[i]=i; for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;z,&amp;x,&amp;y); if(z==1) contact(x,y); else if(search(x,y)) puts("Y"); else puts("N"); &#125; return 0;&#125; 评测记录 R8237877。]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【Codeforces 271B】 Prime Matrix]]></title>
    <url>%2FSolution%2FCodeforces%2FCodeforces-271B%2F</url>
    <content type="text"><![CDATA[原题题面请查看Codeforces 271B Prime Matrix。 也可在洛谷上查看：传送门。 题解埃氏筛 思路 用埃氏筛求出$1$~$10^{5}+3$以内的所有素数； 求出矩阵内每个元素变为素数的操作次数； 为最后统计方便，记a[i][0]为第$i$行的操作总数，a[0][j]为第$j$列的操作总数； 统计答案。 细节$10^5$经过操作后的素数是$100003$，所以埃氏筛要筛到$100003$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#define INF 0X3F3F3F3F3F3F3F3F#define min(a, b) ((a) &lt; (b) ? (a) : (b))//头文件，正无穷，函数min()bool isNotPrime[100004];//埃氏筛的标记数组int n, m, a[501][501];int main(void)&#123; register int i, j; register long long now, temp, ans = INF; scanf("%d%d", &amp;n, &amp;m);//读入n,m /*----埃氏筛----*/ isNotPrime[1] = true; for (i = 2; i &lt;= 100003; ++i) &#123; if (!isNotPrime[i]) for (j = (i &lt;&lt; 1); j &lt;= 100003; j += i) isNotPrime[j] = true; &#125; for (i = 1; i &lt;= n; ++i) for (j = 1; j &lt;= m; ++j) &#123; scanf("%d", &amp;a[i][j]);//先读入 now = temp = a[i][j]; while (isNotPrime[now]) ++now; //寻找最近的素数now a[i][j] = now - temp;//求操作次数 a[i][0] += a[i][j]; a[0][j] += a[i][j]; //为方便统计，记a[i][0]为第i行的操作总数，a[0][j]为第j列的操作总数 &#125; for (i = 1; i &lt;= n; ++i) ans = min(ans, a[i][0]); for (j = 1; j &lt;= m; ++j) ans = min(ans, a[0][j]);//统计 printf("%lld\n", ans);//输出并换行 return 0;&#125; 我的评测记录 Codeforces； 洛谷。]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>埃氏筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1196】 [NOI2002]银河英雄传说]]></title>
    <url>%2FSolution%2FLuogu%2FLuogu-P1196%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1196 [NOI2002]银河英雄传说。 题解并查集 思路 观察合并指令：$M_{i,j}$，说到合并，就能想到一个优秀的【数据结构】并查集。 这就好比说到六六大顺，就能想到六小龄童，说到六小龄童，就想到他在西游记中的角色孙悟空。今年年初，中美合拍的西游记即将正式开机，六小龄童继续扮演美猴王孙悟空，六小龄童会用美猴王艺术形象努力创造一个正能量的形象，文体两开花，弘扬中华文化，希望大家多多关注。 观察询问指令：$C_{i,j}$，运用前缀和的思想，我们设$\text{front[x]}$为$x$前面有多少架战舰，那么查询的答案就是$| front[i]-front[j] | - 1$。 记$\text{num[i]}$为第$i$列飞船的数量，那么我们只需要对并查集的$\text{int find(int);}$函数进行魔改即可维护$\text{front[]}$数组。 代码代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;using std::cin;#define abs(a) ((a) &gt; 0 ? (a) : (-(a)))int T, ID[30001], front[30001], num[30001];int find(int);int main(void)&#123; register int i; scanf("%d", &amp;T); for (i = 1; i &lt;= 30000; ++i) &#123; ID[i] = i; num[i] = 1; &#125; while (T--) &#123; static char ch; static int x, y, fx, fy; cin &gt;&gt; ch; scanf("%d%d", &amp;x, &amp;y); fx = find(x), fy = find(y); if (ch == 'M') &#123; front[fx] += num[fy]; ID[fx] = fy; num[fy] += num[fx]; num[fx] = 0; &#125; else if (fx != fy) puts("-1"); else printf("%d\n", abs(front[x] - front[y]) - 1); &#125; return 0;&#125;int find(int x)&#123; if (ID[x] == x) return ID[x]; else &#123; register int root = find(ID[x]); front[x] += front[ID[x]]; return ID[x] = root; &#125;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>图论</tag>
        <tag>NOIp提高组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1967】 货车运输]]></title>
    <url>%2FSolution%2FLuogu%2FLuogu-P1967%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1967 货车运输。 题解$\text{Kruskal}$算法+倍增求$\text{LCA}$ 思路根据题面，假设我们有一个普通的图： 作图工具：Graph Editor 考虑从顶点$1$走到顶点$3$： 路径$1 \to 3$（最大运货量为$1$）； 路径$1 \to 2 \to 3$（最大运货量为$3$，更优）。 所以我们可以删掉$1 \to 3$这条边，形成了一棵树，通过多次观察发现，这是一颗原图的最大生成树。 问题就被转化成了求最大生成树和在树上解决原问题。 代码 求最大生成树：我们使用$\text{Kruskal}$算法； 在树上解决原问题比较简单，我们只需要通过最近公共祖先（倍增法求解）进行求解即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;algorithm&gt;#include &lt;cstdio&gt;using std::sort;#define INF 0X3F3F3F3F#define min(a, b) ((a) &lt; (b) ? (a) : (b))struct Tree&#123; bool vis[10001]; int cnt, head[10001], to[20001], w[20001], Next[20001]; int dep[10001], fa[10001][21], W[10001][21]; void DFS(int); void Add_Edge(int, int, int); void LCA_Init(void); int LCA(int, int);&#125;;struct Graph&#123; struct Kruskal &#123; struct Edge &#123; int f, t, val; bool operator&lt;(const Edge &amp;a) const &#123; return val &gt; a.val; &#125; &#125;; struct Union_Find &#123; int ID[10001]; void Init(void); void connect(int, int); bool search(int, int); int find(int); &#125;; Union_Find B; Edge E[50001]; void kruskal(void); &#125;; int n, m; Kruskal K; void Read(void);&#125;;int q;Tree T;Graph G;int main(void)&#123; G.Read(); G.K.B.Init(); G.K.kruskal(); T.LCA_Init(); scanf("%d", &amp;q); while (q--) &#123; static int x, y; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", T.LCA(x, y)); &#125; return 0;&#125;void Tree::Add_Edge(int f, int t, int val)&#123; Next[++cnt] = head[f]; to[cnt] = t; w[cnt] = val; head[f] = cnt; return;&#125;void Tree::DFS(int ID)&#123; register int i, To; vis[ID] = true; for (i = head[ID]; i; i = Next[i]) &#123; To = to[i]; if (vis[To]) continue; dep[To] = dep[ID] + 1; fa[To][0] = ID; W[To][0] = w[i]; DFS(To); &#125; return;&#125;void Tree::LCA_Init(void)&#123; register int i, j; for (i = 1; i &lt;= G.n; ++i) if (!vis[i]) &#123; dep[i] = 1; DFS(i); fa[i][0] = i; W[i][0] = INF; &#125; for (i = 1; i &lt;= 20; ++i) for (j = 1; j &lt;= G.n; ++j) &#123; fa[j][i] = fa[fa[j][i - 1]][i - 1]; W[j][i] = min(W[j][i - 1], W[fa[j][i - 1]][i - 1]); &#125; return;&#125;int Tree::LCA(int x, int y)&#123; if (!G.K.B.search(x, y)) return -1; register int i, ans = INF; if (dep[x] &gt; dep[y]) &#123; int temp = x; x = y; y = temp; &#125; for (i = 20; i &gt;= 0; --i) if (dep[fa[y][i]] &gt;= dep[x]) &#123; ans = min(ans, W[y][i]); y = fa[y][i]; &#125; if (x == y) return ans; for (i = 20; i &gt;= 0; --i) if (fa[x][i] != fa[y][i]) &#123; ans = min(ans, min(W[x][i], W[y][i])); x = fa[x][i]; y = fa[y][i]; &#125; ans = min(ans, min(W[x][0], W[y][0])); return ans;&#125;void Graph::Kruskal::Union_Find::Init(void)&#123; register int i; for (i = 1; i &lt;= G.n; ++i) ID[i] = i; return;&#125;void Graph::Kruskal::Union_Find::connect(int a, int b)&#123; register int ra = find(a), rb = find(b); if (ra != rb) ID[rb] = ra; return;&#125;bool Graph::Kruskal::Union_Find::search(int a, int b)&#123; return find(a) == find(b);&#125;int Graph::Kruskal::Union_Find::find(int x)&#123; if (x == ID[x]) return x; else return ID[x] = find(ID[x]);&#125;void Graph::Kruskal::kruskal(void)&#123; register int i, cnt = 0; sort(E + 1, E + G.m + 1); for (i = 1; i &lt;= G.m &amp;&amp; cnt &lt; G.n - 1; ++i) &#123; if (!B.search(E[i].f, E[i].t)) &#123; B.connect(E[i].f, E[i].t); ++cnt; T.Add_Edge(E[i].f, E[i].t, E[i].val); T.Add_Edge(E[i].t, E[i].f, E[i].val); &#125; &#125; return;&#125;void Graph::Read(void)&#123; register int i; scanf("%d%d", &amp;n, &amp;m); for (i = 1; i &lt;= m; ++i) scanf("%d%d%d", &amp;K.E[i].f, &amp;K.E[i].t, &amp;K.E[i].val); return;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>图论</tag>
        <tag>NOIp提高组</tag>
        <tag>Kruskal</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
</search>
