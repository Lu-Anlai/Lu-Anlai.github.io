<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1196】 [NOI2002]银河英雄传说]]></title>
    <url>%2F2019%2F02%2F03%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P1196%E3%80%91-NOI2002-%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1196 [NOI2002]银河英雄传说。 题解并查集 思路 观察合并指令：$M_{i,j}$，说到合并，就能想到一个优秀的【数据结构】并查集。 这就好比说到六六大顺，就能想到六小龄童，说到六小龄童，就想到他在西游记中的角色孙悟空。今年年初，中美合拍的西游记即将正式开机，六小龄童继续扮演美猴王孙悟空，六小龄童会用美猴王艺术形象努力创造一个正能量的形象，文体两开花，弘扬中华文化，希望大家多多关注。 观察询问指令：$C_{i,j}$，运用前缀和的思想，我们设$\text{front[x]}$为$x$前面有多少架战舰，那么查询的答案就是$| front[i]-front[j] | - 1$。 记$\text{num[i]}$为第$i$列飞船的数量，那么我们只需要对并查集的$\text{int find(int);}$函数进行魔改即可维护$\text{front[]}$数组。 代码代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;using std::cin;#define abs(a) ((a) &gt; 0 ? (a) : (-(a)))int T, ID[30001], front[30001], num[30001];int find(int);int main(void)&#123; register int i; scanf("%d", &amp;T); for (i = 1; i &lt;= 30000; ++i) &#123; ID[i] = i; num[i] = 1; &#125; while (T--) &#123; static char ch; static int x, y, fx, fy; cin &gt;&gt; ch; scanf("%d%d", &amp;x, &amp;y); fx = find(x), fy = find(y); if (ch == 'M') &#123; front[fx] += num[fy]; ID[fx] = fy; num[fy] += num[fx]; num[fx] = 0; &#125; else if (fx != fy) puts("-1"); else printf("%d\n", abs(front[x] - front[y]) - 1); &#125; return 0;&#125;int find(int x)&#123; if (ID[x] == x) return ID[x]; else &#123; register int root = find(ID[x]); front[x] += front[ID[x]]; return ID[x] = root; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>NOIp提高组</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1967】 货车运输]]></title>
    <url>%2F2019%2F02%2F03%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P1967%E3%80%91-%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1967 货车运输。 题解$\text{Kruskal}$算法+倍增求$\text{LCA}$ 思路根据题面，假设我们有一个普通的图： 作图工具：Graph Editor 考虑从顶点$1$走到顶点$3$： 路径$1 \to 3$（最大运货量为$1$）； 路径$1 \to 2 \to 3$（最大运货量为$3$，更优）。 所以我们可以删掉$1 \to 3$这条边，形成了一棵树，通过多次观察发现，这是一颗原图的最大生成树。 问题就被转化成了求最大生成树和在树上解决原问题。 代码 求最大生成树：我们使用$\text{Kruskal}$算法； 在树上解决原问题比较简单，我们只需要通过最近公共祖先（倍增法求解）进行求解即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;algorithm&gt;#include &lt;cstdio&gt;using std::sort;#define INF 0X3F3F3F3F#define min(a, b) ((a) &lt; (b) ? (a) : (b))struct Tree&#123; bool vis[10001]; int cnt, head[10001], to[20001], w[20001], Next[20001]; int dep[10001], fa[10001][21], W[10001][21]; void DFS(int); void Add_Edge(int, int, int); void LCA_Init(void); int LCA(int, int);&#125;;struct Graph&#123; struct Kruskal &#123; struct Edge &#123; int f, t, val; bool operator&lt;(const Edge &amp;a) const &#123; return val &gt; a.val; &#125; &#125;; struct Union_Find &#123; int ID[10001]; void Init(void); void connect(int, int); bool search(int, int); int find(int); &#125;; Union_Find B; Edge E[50001]; void kruskal(void); &#125;; int n, m; Kruskal K; void Read(void);&#125;;int q;Tree T;Graph G;int main(void)&#123; G.Read(); G.K.B.Init(); G.K.kruskal(); T.LCA_Init(); scanf("%d", &amp;q); while (q--) &#123; static int x, y; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", T.LCA(x, y)); &#125; return 0;&#125;void Tree::Add_Edge(int f, int t, int val)&#123; Next[++cnt] = head[f]; to[cnt] = t; w[cnt] = val; head[f] = cnt; return;&#125;void Tree::DFS(int ID)&#123; register int i, To; vis[ID] = true; for (i = head[ID]; i; i = Next[i]) &#123; To = to[i]; if (vis[To]) continue; dep[To] = dep[ID] + 1; fa[To][0] = ID; W[To][0] = w[i]; DFS(To); &#125; return;&#125;void Tree::LCA_Init(void)&#123; register int i, j; for (i = 1; i &lt;= G.n; ++i) if (!vis[i]) &#123; dep[i] = 1; DFS(i); fa[i][0] = i; W[i][0] = INF; &#125; for (i = 1; i &lt;= 20; ++i) for (j = 1; j &lt;= G.n; ++j) &#123; fa[j][i] = fa[fa[j][i - 1]][i - 1]; W[j][i] = min(W[j][i - 1], W[fa[j][i - 1]][i - 1]); &#125; return;&#125;int Tree::LCA(int x, int y)&#123; if (!G.K.B.search(x, y)) return -1; register int i, ans = INF; if (dep[x] &gt; dep[y]) &#123; int temp = x; x = y; y = temp; &#125; for (i = 20; i &gt;= 0; --i) if (dep[fa[y][i]] &gt;= dep[x]) &#123; ans = min(ans, W[y][i]); y = fa[y][i]; &#125; if (x == y) return ans; for (i = 20; i &gt;= 0; --i) if (fa[x][i] != fa[y][i]) &#123; ans = min(ans, min(W[x][i], W[y][i])); x = fa[x][i]; y = fa[y][i]; &#125; ans = min(ans, min(W[x][0], W[y][0])); return ans;&#125;void Graph::Kruskal::Union_Find::Init(void)&#123; register int i; for (i = 1; i &lt;= G.n; ++i) ID[i] = i; return;&#125;void Graph::Kruskal::Union_Find::connect(int a, int b)&#123; register int ra = find(a), rb = find(b); if (ra != rb) ID[rb] = ra; return;&#125;bool Graph::Kruskal::Union_Find::search(int a, int b)&#123; return find(a) == find(b);&#125;int Graph::Kruskal::Union_Find::find(int x)&#123; if (x == ID[x]) return x; else return ID[x] = find(ID[x]);&#125;void Graph::Kruskal::kruskal(void)&#123; register int i, cnt = 0; sort(E + 1, E + G.m + 1); for (i = 1; i &lt;= G.m &amp;&amp; cnt &lt; G.n - 1; ++i) &#123; if (!B.search(E[i].f, E[i].t)) &#123; B.connect(E[i].f, E[i].t); ++cnt; T.Add_Edge(E[i].f, E[i].t, E[i].val); T.Add_Edge(E[i].t, E[i].f, E[i].val); &#125; &#125; return;&#125;void Graph::Read(void)&#123; register int i; scanf("%d%d", &amp;n, &amp;m); for (i = 1; i &lt;= m; ++i) scanf("%d%d%d", &amp;K.E[i].f, &amp;K.E[i].t, &amp;K.E[i].val); return;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>NOIp提高组</tag>
        <tag>图论</tag>
        <tag>Kruskal</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
</search>
