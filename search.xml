<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[欢迎]]></title>
    <url>%2F2038%2F01%2F19%2F%E6%AC%A2%E8%BF%8E%2F</url>
    <content type="text"><![CDATA[欢迎来到$\text{Lu-Anlai’s Blog}$本博客由 Hexo 强力驱动 v3.8.0 | 主题 – NexT.Gemini v7.0.0 背景是随机二次元图片$\text{API}$，您可以点击右侧的资源查看更多。 博客主要内容是题解（水题题解），之前在洛谷博客和$\text{CSDN}$博客发布的文章不久就会转移到这个博客上来（咕咕咕）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P4825】 [USACO15FEB]Cow Hopscotch (Silver) 牛跳房子(银)]]></title>
    <url>%2F2019%2F02%2F14%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P4825%E3%80%91-USACO15FEB-Cow-Hopscotch-Silver-%E7%89%9B%E8%B7%B3%E6%88%BF%E5%AD%90-%E9%93%B6%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P4825 [USACO15FEB]Cow Hopscotch (Silver) 牛跳房子(银)。 题解动态规划 思路直接动态规划即可，状态转移方程为： $$f_{ij}=\begin{cases} 1 &amp; {i=j=1} \newline \sum^{i-1}\limits_{k=1} \sum^{j-1}\limits_{l=1} f_{kl} &amp; {a_{ij} \neq a_{kl}} \end{cases}$$ 时间复杂度分析时间复杂度为$\Omega (\frac{n^{4}-n^{2}}{2}),O (\frac{n^{4}}{2})$。 （注：$n$即为题目中的$R,C$） 需要注意的一点是： 如果将数据范围代入算法对应的多项式时间复杂度，所得的数字小于$5 \times 10^{7}$，则这个算法可以在$1 \text{s}$内通过。 把$n=100$带入$\frac{n^{4}}{2}$，得$T(n)=\frac{100^{4}}{2}=5 \times 10^{7}$，预计可以通过。 提示另外，程序运行时间也与计算机性能有关，主要是$\text{CPU}$主频这个参数。 在$\text{C/C++}$中，你可以运行下面这个程序来获取$\text{CPU}$型号和主频。 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#include&lt;cpuid.h&gt;static void cpuid(uint32_t func,uint32_t sub,uint32_t data[4])&#123; __cpuid_count(func,sub,data[0],data[1],data[2],data[3]);&#125;int main(void)&#123; uint32_t data[4]; char str[48]; for(int i=0;i&lt;3;i++)&#123; cpuid(0x80000002+i,0,data); for(int j=0;j&lt;4;j++) reinterpret_cast&lt;uint32_t*&gt;(str)[i*4+j]=data[j]; &#125; printf("%s\n",str); return 0;&#125; 在洛谷$\text{IDE}$下输出： 1Intel(R) Xeon(R) Gold 6149 CPU @ 3.10GHz 算法的优化假如你对算法的时间复杂度实在不放心，你可以进行常数优化。 fread();读入优化，大约可节省$100\text{ms}$的时间； 变量定义类型改为register int； 避免使用long long类型，尽量使用int。 代码代码如下： 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#define MOD 1000000007//宏定义MOD更快#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++)static char buf[100000], *p1 = buf, *p2 = buf;//fread();版读入优化inline int read(void)//读入优化函数&#123; register char ch = getchar(); register int sum = 0; while (!(ch &gt;= '0' &amp;&amp; ch &lt;= '9')) ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') sum = (sum &lt;&lt; 1) + (sum &lt;&lt; 3) + ch - 48, ch = getchar(); return sum;&#125;int n, m, a[1001][1001], f[1001][1001];//变量尽量避免使用long longint main(void)&#123; register int i, j, k, l;//尽量使用寄存器变量 f[1][1] = 1;//动态规划初始化 n = read(), m = read(), read();//k没有用，不要读入 for (i = 1; i &lt;= n; ++i) for (j = 1; j &lt;= m; ++j) &#123; a[i][j] = read(); for (k = 1; k &lt; i; ++k) for (l = 1; l &lt; j; ++l) if (a[k][l] != a[i][j]) f[i][j] = (f[i][j] + f[k][l]) % MOD;//状态转移方程 &#125; printf("%d\n", f[n][m]);//输出并换行 return 0;//结束&#125; 我的评测记录 洛谷 R16320841。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1073】 最优贸易]]></title>
    <url>%2F2019%2F02%2F13%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P1073%E3%80%91-%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1073 最优贸易。 题解$\text{SPFA}$ 思路进行两次$\text{SPFA}$即可。 算法的优化 fread();读入优化，大约可节省$60\text{ms}$的时间； 存图使用链式前向星； 手写循环队列； 经过优化后，算法的时间复杂度为$\text{O}(n+m+2Km+n)=\text{O}(2n+(2K+1)m)$，可以通过。 代码代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstdio&gt;#include &lt;cstring&gt;#define min(a, b) ((a) &lt; (b) ? (a) : (b))#define max(a, b) ((a) &gt; (b) ? (a) : (b))//宏定义#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++)static char buf[100000], *p1 = buf, *p2 = buf;inline int read(void)//读入优化&#123; register char ch = getchar(); register int sum = 0; while (!(ch &gt;= '0' &amp;&amp; ch &lt;= '9')) ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') sum = (sum &lt;&lt; 1) + (sum &lt;&lt; 3) + ch - 48, ch = getchar(); return sum;&#125;struct Graph&#123; int cnt, head[100001], to[1000001], w[1000001], Next[1000001]; void Add_Edge(int, int, int);&#125;;//链式前向星存图bool vis[100001][2];int a[100001];int Min[100001], Max[100001];int Q[100001], head, tail;Graph L1, L2;void SPFA1(int);void SPFA2(int);int main(void)&#123; register int n, m, i, ans = 0, x, y, z; n = read(), m = read(); for (i = 1; i &lt;= n; ++i) a[i] = read(); for (i = 1; i &lt;= m; ++i) &#123; x = read(), y = read(), z = read(); L1.Add_Edge(x, y, a[y]), L2.Add_Edge(y, x, a[x]); if (z == 2)//双向边 L1.Add_Edge(y, x, a[x]), L2.Add_Edge(x, y, a[y]); &#125; SPFA1(1), SPFA2(n);//两次SPFA for (i = 1; i &lt;= n; ++i) ans = max(ans, Max[i] - Min[i]);//max()求答案 printf("%d\n", ans);//输出并换行 return 0;//结束程序&#125;void Graph::Add_Edge(int f, int t, int val)&#123; Next[++cnt] = head[f]; to[cnt] = t; w[cnt] = val; head[f] = cnt; return;&#125;void SPFA1(int s)&#123; register int i, ID, To; head = tail = 0; memset(Q, 0, sizeof(Q)); memset(Min, 0X3F, sizeof(Min)); vis[s][1] = true; Q[tail++] = s; while (head!=tail) &#123; ID = Q[head++]; if (head &gt;= 100001) head %= 100001; vis[ID][1] = false; for (i = L1.head[ID]; i; i = L1.Next[i]) &#123; To = L1.to[i]; if (Min[To] &gt; min(Min[ID], L1.w[i])) &#123; Min[To] = min(Min[ID], L1.w[i]); if (!vis[To][1]) &#123; vis[To][1] = true; Q[tail++] = To; if (tail &gt;= 100001) tail %= 100001; &#125; &#125; &#125; &#125; return;&#125;void SPFA2(int s)&#123; register int i, ID, To; head = tail = 0; memset(Q, 0, sizeof(Q)); vis[s][0] = true; Q[tail++] = s; while (head!=tail) &#123; ID = Q[head++]; if (head &gt;= 100001) head %= 100001; vis[ID][0] = false; for (i = L2.head[ID]; i; i = L2.Next[i]) &#123; To = L2.to[i]; if (Max[To] &lt; max(Max[ID], L2.w[i])) &#123; Max[To] = max(Max[ID], L2.w[i]); if (!vis[To][0]) &#123; vis[To][0] = true; Q[tail++] = To; if (tail &gt;= 100001) tail %= 100001; &#125; &#125; &#125; &#125; return;&#125; 我的评测记录 洛谷 R16277015。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>图论</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manim的安装指南（Windows）]]></title>
    <url>%2F2019%2F02%2F13%2FManim%E7%9A%84%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97%EF%BC%88Windows%EF%BC%89%2F</url>
    <content type="text"><![CDATA[网上的教程都不够详细，并且早已过时。 $\text{Manim}$项目地址。 前期准备 $\text{Manim}$基于$\text{Python}3.7$，请确保$\text{Windows}$下安装了$\text{Python}3.7$； $\text{Manim}$托管于$\text{GitHub}$，请确保$\text{Windows}$下安装了$\text{GitHub}$； 请确保$\text{pip}$的版本是最新的。 $\text{Manim}$及其环境的配置随便找一个目录，按住Shift键并右键选择在此处打开 PowerShell 窗口（$\text{Windows}10$以下的系统显示的是命令提示符）。 输入命令： 12git clone https://github.com/3b1b/manim.gitcd manim 完成后可以发现原目录下多了一个叫做manim的文件夹，这就是以后的工作目录。 继续在之前的窗口中输入命令（或者在manim文件夹中打开$\text{PowerShell}$窗口）： 1python -m pip install -r requirements.txt 问题常见问题： 在这一步中如果看到类似于Error或者Visual Build 14.0的字样，请自行上网搜索解决办法，搜索引擎推荐使用$\text{Google}$。 如果看到形如ModuleNotFoundError: No module named &lt;pack name&gt;的错误提示，请运行命令： 1pip install &lt;pack name&gt; 特别的，如果遇见ModuleNotFoundError: No module named &#39;readline&#39;，请输入： 1pip install pyreadline 测试输入命令： 1python -m manim example_scenes.py SquareToCircle -pl 如果弹出了一段下面这样的视频（分辨率为$854 \times 480$，帧率为$15 \text{FPS}$），说明$\text{Manim}$配置成功。 常见问题： 如果看到形如ModuleNotFoundError: No module named &lt;pack name&gt;的错误提示，请运行命令： 1pip install &lt;pack name&gt; 特别的，如果遇见ModuleNotFoundError: No module named &#39;readline&#39;，请输入： 1pip install pyreadline 欣赏影片以下影片分辨率为$1280 \times 720$，帧率为$30 \text{FPS}$]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Manim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】 树]]></title>
    <url>%2F2019%2F02%2F12%2F%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[介绍树是一种数据结构，它是由$n(n \geq 1)$个有限结点组成一个具有层次关系的集合。 树的定义自然树显然，计算机的树与自然界中的树（后文简称为自然树）有所联系，否则它就不会以树为名称了。 下面我们先来看看自然树： 归纳一下自然树的特征： 有且只有一个树根； 树会分叉； 树枝的末端是叶子。 计算机中的树根据自然树的特征，我们给出树的定义：（共有$3$种） 集合定义： 树是包含$n(n \geq 0)$个结点的有穷集，其中： 每个元素称为结点； 有一个特定的结点被称为根结点或树根； 除根结点之外的其余数据元素被分为$m(m \geq 0)$个互不相交的集合$T_{1},T_{2},…,T_{m}$，其中每一个集合$T_{i}(1 \leq i \leq m)$本身也是一棵树，被称作原树的子树。 关系定义（层次定义）： 树是由根结点和若干颗子树构成的； 树是由一个集合以及在该集合上定义的一种关系构成的。集合中的元素称为树的结点，所定义的关系称为父子关系； 父子关系在树的结点之间建立了一个层次结构。在这种层次结构中有一个结点具有特殊的地位，这个结点称为该树的根结点，或称为树根。 递归定义： 单个结点是一棵树，树根就是该结点本身。 设$T_{1},T_{2},…,T_{k}$是树，它们的根结点分别为$n_{1},n_{2},…,n_{k}$。用一个新结点$n$作为$n_{1},n_{2},…,n_{k}$的父亲，则得到一棵新树，结点$n$就是新树的根。我们称$n_{1},n_{2},…,n_{k}$为一组兄弟结点，它们都是结点$n$的子结点。我们还称$T_{1},T_{2},…,T_{k}$为结点$n$的子树。 空集合也是树，称为空树。空树中没有结点。 树的表示方法图像法图像法是最常见的树的表示方法。 用图像表示树，一目了然。 遍历法此方法只适用于二叉树。 二叉树有多种遍历方法，最常见的是先序遍历，中序遍历，后序遍历以及层次遍历。 用先序遍历，中序遍历，后序遍历既可以表达二叉树又可以确定二叉树。 其先序遍历为：1 2 4 6 3 7 5 8 9； 其中序遍历为：4 2 6 1 7 3 8 5 9； 其后序遍历为：4 6 2 7 8 9 5 3 1。 除此之外还有符号法等方法可以表示树。 树的储存方法树的储存方法有多种，此处不展开说明。 推荐使用链式前向星存双向边。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解（水）】【Codeforces 579A】 Raising Bacteria]]></title>
    <url>%2F2019%2F02%2F12%2F%E3%80%90%E9%A2%98%E8%A7%A3%EF%BC%88%E6%B0%B4%EF%BC%89%E3%80%91%E3%80%90Codeforces-579A%E3%80%91-Raising-Bacteria%2F</url>
    <content type="text"><![CDATA[原题题面请查看Codeforces 579A Raising Bacteria。 也可在洛谷上查看：传送门。 题解模拟+二进制 思路此题太水，略去不写。 代码代码如下： 1234567891011121314151617#include &lt;cstdio&gt;int x;int main(void)&#123; register int cnt = 0; scanf("%d", &amp;x); while (x) &#123; if (x &amp; 1) ++cnt; x &gt;&gt;= 1; &#125; printf("%d\n", cnt); return 0;&#125; 我的评测记录 Codeforces； 洛谷。]]></content>
      <categories>
        <category>题解（水）</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>模拟</tag>
        <tag>题解（水）</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【Codeforces 574A】 Bear and Elections]]></title>
    <url>%2F2019%2F02%2F09%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90Codeforces-574A%E3%80%91-Bear-and-Elections%2F</url>
    <content type="text"><![CDATA[原题题面请查看Codeforces 574A Bear and Elections。 也可在洛谷上查看：传送门。 洛谷题面翻译来自@卢安来，其实就是我。 题解模拟+排序 思路根据正常人的想法和思维，选票最多的人是Limak最大的敌人，我们应该多贿赂他的支持者。 因为每次贿赂后，选票最多的人都会改变，所以我们每次操作（实行贿赂）后进行排序即可。 具体实现设vote为Limak当前选票，那么每次的操作就可以写成这样： 1234567while (a[n - 1] &gt;= vote) //如果Limak无法获胜&#123; //开始贿赂 --a[n - 1]; //贿赂选票最多的人的一名支持者 sort(a + 1, a + n); //重新排序 ++vote; //Limak的选票增加 ++ans; //计数器自增&#125; 代码代码如下： 1234567891011121314151617181920212223#include &lt;algorithm&gt;#include &lt;cstdio&gt;using std::sort; //排序int n, vote, a[101]; //变量如上文所述int main(void)&#123; register int i, ans = 0; scanf("%d%d", &amp;n, &amp;vote); //读入 for (i = 1; i &lt; n; ++i) //除去Limak还有n-1个人 scanf("%d", &amp;a[i]); sort(a + 1, a + n); //要先排序 while (a[n - 1] &gt;= vote) //如果Limak无法获胜 &#123; //开始贿赂 --a[n - 1]; //贿赂选票最多的人的一名支持者 sort(a + 1, a + n); //重新排序 ++vote; //Limak的选票增加 ++ans; //计数器自增 &#125; printf("%d\n", ans); //输出并换行 return 0;&#125; 我的评测记录 Codeforces； 洛谷。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>模拟</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解（水）】【AtCoder Code Festival Team Relay A】 Kaiden]]></title>
    <url>%2F2019%2F02%2F09%2F%E3%80%90%E9%A2%98%E8%A7%A3%EF%BC%88%E6%B0%B4%EF%BC%89%E3%80%91%E3%80%90AtCoder-Code-Festival-Team-Relay-A%E3%80%91-Kaiden%2F</url>
    <content type="text"><![CDATA[原题题面请查看AtCoder ABC004-C 入れ替え。 也可在洛谷上查看：传送门。 题解模拟 思路此题太水，略去不写。 代码代码如下： 123456789101112131415#include &lt;cstdio&gt;long long a, b, k;int main(void)&#123; scanf("%lld%lld%lld", &amp;k, &amp;a, &amp;b); if (k &lt;= a) puts("1"); else if (a &lt;= b) puts("-1"); else printf("%lld\n", ((k - a) / (a - b) + bool((k - a) % (a - b))) &lt;&lt; 1 | 1); return 0;&#125; 我的评测记录 AtCoder； 洛谷 R16137986。]]></content>
      <categories>
        <category>题解（水）</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>模拟</tag>
        <tag>题解（水）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P2683】 小岛]]></title>
    <url>%2F2019%2F02%2F07%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P2683%E3%80%91-%E5%B0%8F%E5%B2%9B%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P2683 小岛。 题解$\text{Dijkstra}$ 思路每一次查询都进行一遍$\text{Dijkstra}$求单源最短路径。 算法的优化 fread();读入优化，大约可节省$100\text{ms}$的时间； 存图应使用链式前向星； 使用堆（或者std::priority_queue）优化； 经过优化后，算法的时间复杂度为$\text{O}(mnlog_{2}n+m^{2})$。 代码代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using std::less;using std::priority_queue;using std::vector; //头文件和引用#define INF 0X3F3F3F3F //定义正无穷#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++)static char buf[100000], *p1 = buf, *p2 = buf; //fread();读入优化inline int read(void)&#123; register char ch = getchar(); register int sum = 0; while (!(ch &gt;= '0' &amp;&amp; ch &lt;= '9')) ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') sum = sum * 10 + ch - 48, ch = getchar(); return sum;&#125;struct Node&#123; int ID, dis; bool operator&lt;(const Node &amp;a) const &#123; return dis &gt; a.dis; &#125;&#125;;bool vis[101];int cnt, head[101], to[10001], w[10001], Next[10001];int dis[101];priority_queue&lt;Node, vector&lt;Node&gt;, less&lt;Node&gt;&gt; Q; //优先队列void Add_Edge(int, int, int);void Dijkstra(int);int main(void)&#123; register int m, op, s, t, u, v, e; //register变量更快些 read(); //n在本题中没有用，也无超过n的毒瘤数据，无需读入 m = read(); //读入m while (m--) &#123; op = read(); if (op == 0) &#123; s = read(), t = read(); Dijkstra(s); printf("%d\n", (dis[t] == INF) ? (-1) : (dis[t])); &#125; if (op == 1) &#123; u = read(), v = read(), e = read(); Add_Edge(u, v, e); Add_Edge(v, u, e); //双向边 &#125; &#125; return 0;&#125;void Add_Edge(int f, int t, int val) //链式前向星存图&#123; Next[++cnt] = head[f]; to[cnt] = t; w[cnt] = val; head[f] = cnt; return;&#125;void Dijkstra(int s)&#123; register int i, ID, To; Node temp; memset(vis, false, sizeof(vis)); memset(dis, 0X3F, sizeof(dis)); dis[s] = 0; //每次运行前要记得初始化 temp.ID = s, temp.dis = 0; Q.push(temp); while (!Q.empty()) &#123; temp = Q.top(); Q.pop(); ID = temp.ID; if (vis[ID]) continue; vis[ID] = true; for (i = head[ID]; i; i = Next[i]) &#123; To = to[i]; if (dis[To] &gt; dis[ID] + w[i]) &#123; dis[To] = dis[ID] + w[i]; //松弛操作 temp.ID = To, temp.dis = dis[To]; Q.push(temp); &#125; &#125; &#125; return; //返回&#125; 我的评测记录 洛谷 R16112574。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1198】 [JSOI2008]最大数]]></title>
    <url>%2F2019%2F02%2F07%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P1198%E3%80%91-JSOI2008-%E6%9C%80%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1198 [JSOI2008]最大数。 题解线段树 思路为节省写代码的时间，我们采用阉割版线段树（只具有单点修改和区间查询两个功能）。 具体实现过程 定义空树Tree，记len为当前数列的长度； 模拟操作： 查询操作： 记T=Tree.Query(1,1,m,len-L+1,len)，输出T并换行即可； 插入操作： 单点修改：Tree.Update(1,1,m,++len,(num+T)%D)； 结束。 代码代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#define INF 0X3F3F3F3F3F3F3F3F//定义正无穷#define max(a, b) ((a) &gt; (b) ? (a) : (b))//定义max()函数typedef long long llstruct Segment_Tree //线段树模板&#123; ll unit[(200000 &lt;&lt; 2) + 1]; //线段树空间要开到4倍 void Update(int, int, int, int, ll); //更新函数 ll Query(int, int, int, int, int); //查询函数&#125;;char ch[2];//操作符int m, len;//len表示数列长度ll D, T, num;Segment_Tree Tree; //线段树int main(void)&#123; register int i; scanf("%d%lld", &amp;m, &amp;D);//读入 for (i = 1; i &lt;= m; ++i)//模拟 &#123; scanf("%s%lld", ch, &amp;num); if (ch[0] == 'Q') &#123; if (!num) T = 0; else T = Tree.Query(1, 1, m, len - num + 1, len) % D;//查询 printf("%lld\n", T);//输出并换行 &#125; if (ch[0] == 'A') &#123; ++len;//数列边长 Tree.Update(1, 1, m, len, (num + T) % D);//更新 &#125; &#125; return 0;&#125;void Segment_Tree::Update(int ID, int l, int r, int index, ll val)&#123; if (l == r) unit[ID] = val; else &#123; register int mid = (l + r) &gt;&gt; 1; if (index &lt;= mid) Update(ID &lt;&lt; 1, l, mid, index, val); //更新左子树 if (index &gt; mid) Update(ID &lt;&lt; 1 | 1, mid + 1, r, index, val); //更新右子树 unit[ID] = max(unit[ID &lt;&lt; 1], unit[ID &lt;&lt; 1 | 1]) % D; &#125; return;&#125;ll Segment_Tree::Query(int ID, int l, int r, int x, int y)&#123; if (x &lt;= l &amp;&amp; r &lt;= y) return unit[ID]; register int mid = (l + r) &gt;&gt; 1; register ll a = -INF, b = -INF; if (x &lt;= mid) a = Query(ID &lt;&lt; 1, l, mid, x, y); //查询左子树 if (y &gt; mid) b = Query(ID &lt;&lt; 1 | 1, mid + 1, r, x, y); //查询右子树 return max(a, b); //返回查询结果&#125; 我的评测记录 洛谷 R16096515。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>JSOI2008</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1340】 兽径管理]]></title>
    <url>%2F2019%2F02%2F06%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P1340%E3%80%91-%E5%85%BD%E5%BE%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1340 兽径管理。 题解$\text{Kruskal}$算法 思路 先读入所有边，每条边以时间为编号ID； 对边以边权为关键字进行排序； 以$1$~$w$为参数进行$\text{Kruskal}$算法： 如果这条边的编号大于所给参数，这条边不参与算法； 否则寻找最小生成树。 输出答案。 代码代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include &lt;cstdio&gt;//头文件using std::sort;//快速排序struct Edge//定义 边 的结构体&#123; int ID, f, t, val; bool operator&lt;(const Edge &amp;a) const &#123; return val &lt; a.val; &#125;&#125;;struct Union_Find//定义 并查集 的结构体&#123; int ID[201]; Union_Find(int);//析构函数，用于并查集的初始化，参数为n void connect(int, int);//并 bool search(int, int);//查 int find(int);//查&#125;;int n, w;Edge E[6001];int Kruskal(int);int main(void)&#123; register int i; scanf("%d%d", &amp;n, &amp;w); for (i = 1; i &lt;= w; ++i) &#123; E[i].ID = i;//每条边以时间为编号 scanf("%d%d%d", &amp;E[i].f, &amp;E[i].t, &amp;E[i].val);//读入 &#125; sort(E + 1, E + w + 1);//快速排序 for (i = 1; i &lt;= w; ++i) printf("%d\n", Kruskal(i));//调用函数并输出结果 return 0;//在主函数末尾加上return 0;是一个好习惯&#125;Union_Find::Union_Find(int n)//析构函数，用于并查集的初始化，参数为n&#123; register int i; for (i = 1; i &lt;= n; ++i) ID[i] = i; return;&#125;void Union_Find::connect(int a, int b)&#123; register int ra = find(a), rb = find(b); if (ra != rb) ID[rb] = ra; return;&#125;bool Union_Find::search(int a, int b)&#123; return find(a) == find(b);&#125;int Union_Find::find(int x)&#123; if (x == ID[x]) return x; else return ID[x] = find(ID[x]);//路径压缩&#125;int Kruskal(int time)&#123; register int i, cnt = 0, sum = 0; //cnt为连接边的数量 Union_Find UF(n);//先定义一个并查集UF，析构函数的参数为n for (i = 1; i &lt;= w &amp;&amp; cnt &lt; n - 1; ++i) if (E[i].ID &gt; time)//如果这条边的编号大于所给参数，这条边不参与算法 continue; else if (!UF.search(E[i].f, E[i].t))//如果这条边连接的两个点不在同一个集合内 &#123; ++cnt; sum += E[i].val; UF.connect(E[i].f, E[i].t); &#125;//统计答案 if (cnt != n - 1)//如果无法构成树 return -1;//题目要求输出-1 else return sum;//返回答案&#125; 我的评测记录 洛谷 R16089070。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P2574】 XOR的艺术]]></title>
    <url>%2F2019%2F02%2F05%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P2574%E3%80%91-XOR%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P2574 XOR的艺术。 题解线段树 思路把线段树的LazyTag[]的更新方式修改一下即可，其他可照抄线段树模板。 更新LazyTag[]的方式 左右子树的LazyTag[]都要对一按位异或； 代码表示为： 12tag[ID &lt;&lt; 1] ^= 1;tag[ID &lt;&lt; 1 | 1] ^= 1; 左右子树的值全部变成区间长度减去当前值； 代码表示为： 123register int len = r - l + 1;//len为当前节点区间长度unit[ID &lt;&lt; 1] = (len - (len &gt;&gt; 1)) - unit[ID &lt;&lt; 1];//左子树根节点区间长度为(len - (len &gt;&gt; 1))unit[ID &lt;&lt; 1 | 1] = (len &gt;&gt; 1) - unit[ID &lt;&lt; 1 | 1];//右子树根节点区间长度为(len &gt;&gt; 1) 代码代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;//头文件struct Segment_Tree//线段树模板&#123; int unit[(200000 &lt;&lt; 2) + 1], tag[(200000 &lt;&lt; 2) + 1];//线段树空间要开到4倍 void Build(int, int, int, bool[]);//建树函数 void Update(int, int, int, int, int);//更新函数 int Query(int, int, int, int, int);//查询函数 void Pushdown(int, int, int);//更新LazyTag[]的函数&#125;;bool a[200001];int n, m;Segment_Tree Tree;//线段树int main(void)&#123; register int i; scanf("%d%d", &amp;n, &amp;m); for (i = 1; i &lt;= n; ++i) &#123; static int temp; scanf("%1d", &amp;temp); a[i] = temp; &#125; Tree.Build(1, 1, n, a);//建树 while (m--) &#123; static int opt, l, r; scanf("%d%d%d", &amp;opt, &amp;l, &amp;r); if (opt == 0)//更新 Tree.Update(1, 1, n, l, r); if (opt == 1)//查询 printf("%d\n", Tree.Query(1, 1, n, l, r));//输出查询结果并换行 &#125; return 0;//结束时加上return 0;是一个好习惯&#125;void Segment_Tree::Build(int ID, int l, int r, bool a[])&#123; if (l == r) unit[ID] = a[l];//递归停止 else &#123; register int mid = (l + r) &gt;&gt; 1; Build(ID &lt;&lt; 1, l, mid, a);//构建左子树 Build(ID &lt;&lt; 1 | 1, mid + 1, r, a);//构建左子树 unit[ID] = unit[ID &lt;&lt; 1] + unit[ID &lt;&lt; 1 | 1]; &#125; return;&#125;void Segment_Tree::Update(int ID, int l, int r, int x, int y)&#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; unit[ID] = (r - l + 1) - unit[ID]; tag[ID] ^= 1; &#125; else &#123; Pushdown(ID, l, r); int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) Update(ID &lt;&lt; 1, l, mid, x, y);//更新左子树 if (y &gt; mid) Update(ID &lt;&lt; 1 | 1, mid + 1, r, x, y);//更新右子树 unit[ID] = unit[ID &lt;&lt; 1] + unit[ID &lt;&lt; 1 | 1]; &#125; return;&#125;int Segment_Tree::Query(int ID, int l, int r, int x, int y)&#123; if (x &lt;= l &amp;&amp; r &lt;= y) return unit[ID]; Pushdown(ID, l, r);//更新LazyTag[] int mid = (l + r) &gt;&gt; 1, sum = 0; if (x &lt;= mid) sum += Query(ID &lt;&lt; 1, l, mid, x, y);//查询左子树 if (y &gt; mid) sum += Query(ID &lt;&lt; 1 | 1, mid + 1, r, x, y);//查询右子树 return sum;//返回查询结果&#125;void Segment_Tree::Pushdown(int ID, int l, int r)&#123; register int len = r - l + 1; if (tag[ID]) &#123; tag[ID &lt;&lt; 1] ^= 1; tag[ID &lt;&lt; 1 | 1] ^= 1; //左右子树的LazyTag[]都要对一按位异或 unit[ID &lt;&lt; 1] = (len - (len &gt;&gt; 1)) - unit[ID &lt;&lt; 1]; unit[ID &lt;&lt; 1 | 1] = (len &gt;&gt; 1) - unit[ID &lt;&lt; 1 | 1]; //左右子树的值全部变成区间长度减去当前值 tag[ID] = 0;//记得清空当前节点的标记 &#125; return;&#125; 我的评测记录 洛谷 R16079272。 其他线段树模板的代码算中等长度，下面我们来压行。 源代码共$102$行，压行后$7$行。 压行的评测记录：洛谷 R16080174。 1234567#include &lt;cstdio&gt;int n, m, opt, l, r,unit[(200000 &lt;&lt; 2) + 1], tag[(200000 &lt;&lt; 2) + 1];void Build(int ID, int l, int r)&#123;(l == r)?(scanf("%1d", &amp;unit[ID])):(Build(ID &lt;&lt; 1, l, ((l + r) &gt;&gt; 1)),Build(ID &lt;&lt; 1 | 1, ((l + r) &gt;&gt; 1) + 1, r),unit[ID] = unit[ID &lt;&lt; 1] + unit[ID &lt;&lt; 1 | 1]);&#125;void Pushdown(int ID, int l, int r)&#123;tag[ID]?(tag[ID &lt;&lt; 1] ^= 1,tag[ID &lt;&lt; 1 | 1] ^= 1,unit[ID &lt;&lt; 1] = ((r - l + 1) - ((r - l + 1) &gt;&gt; 1)) - unit[ID &lt;&lt; 1],unit[ID &lt;&lt; 1 | 1] = ((r - l + 1) &gt;&gt; 1) - unit[ID &lt;&lt; 1 | 1],tag[ID] = 0):0;&#125;void Update(int ID, int l, int r, int x, int y)&#123;(x &lt;= l &amp;&amp; r &lt;= y)?(unit[ID] = (r - l + 1) - unit[ID],tag[ID] ^= 1,0):(Pushdown(ID, l, r),((x &lt;= ((l + r) &gt;&gt; 1))?(Update(ID &lt;&lt; 1, l, ((l + r) &gt;&gt; 1), x, y),0):0),((y &gt; ((l + r) &gt;&gt; 1))?(Update(ID &lt;&lt; 1 | 1, ((l + r) &gt;&gt; 1) + 1, r, x, y),0):0),unit[ID] = unit[ID &lt;&lt; 1] + unit[ID &lt;&lt; 1 | 1],0);&#125;int Query(int ID, int l, int r, int x, int y)&#123;return ((x &lt;= l &amp;&amp; r &lt;= y)?(unit[ID]):(Pushdown(ID, l, r),((x &lt;= ((l + r) &gt;&gt; 1))?(Query(ID &lt;&lt; 1, l, ((l + r) &gt;&gt; 1), x, y)):0)+((y &gt; ((l + r) &gt;&gt; 1))?(Query(ID &lt;&lt; 1 | 1, ((l + r) &gt;&gt; 1) + 1, r, x, y)):0)));&#125;int main(void)&#123;scanf("%d%d", &amp;n, &amp;m),Build(1, 1, n);while (m--)(scanf("%d%d%d", &amp;opt, &amp;l, &amp;r),opt==0)?(Update(1, 1, n, l, r),0):(printf("%d\n",Query(1, 1, n, l, r)));&#125; 也许这就是压行的艺术。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT主题搭建博客教程（Windows）]]></title>
    <url>%2F2019%2F02%2F05%2FHexo-NexT%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%88Windows%EF%BC%89%2F</url>
    <content type="text"><![CDATA[网上的教程都不够详细，本人自己写一篇。 前期准备注册$\text{GitHub}$账号；先注册一个$\text{GitHub}$账号，官网传送门：$\text{GitHub}$； 安装$\text{Git}$；下载$\text{Git}$到本地并安装，你可以到官网：$\text{Git}$处下载安装包。 安装时全程按Next即可。 安装$\text{Node.js}$；下载$\text{Node.js}$到本地并安装，你可以到官网：$\text{Node.js}$处下载安装包（推荐选择$\text{LTS}$版）。 安装时全程按Next即可。 配置本地$\text{Git}$；未完待续。 在$\text{GitHub}$中新建一个Repository；未完待续。 搭建博客安装并配置$\text{Hexo}$新建一个文件夹，作为根目录用来存放博客文件（文件夹名任意，推荐命名成&lt;username&gt;.github.io，其中&lt;username&gt;是你$\text{GitHub}$的$\text{ID}$）。 然后在根目录中右键，选择Git Bash Here，然后在弹出来的窗口里输入命令npm install -g hexo（后文所说的输入命令都在此窗口输入），然后耐心等待。 注：等待时间从$2 \text{s} $到$30 \text{min}$不等，请耐心等待，中途不要进行任何操作。 如果出现了一长串代码，又没有ERROR提示出现的话，就是安装$\text{Hexo}$成功了。 接着输入：hexo init和npm install，如果弄完之后文件夹变成了这样： 那就没问题了。 预览博客在Git Bash窗口中输入hexo s，预览博客。 如果窗口中出现效果如下图，表明进行预览成功： 再打开网址http://localhost:4000/，即可对博客进行预览。 预览结束后一定要按Ctrl+C关闭预览。 至此博客搭建完成，但仍无法在公网上查看。 部署博客至$\text{GitHub}$输入命令npm install hexo-deployer-git --save安装deployer。 打开根目录下的_config.yml，按Ctrl+F搜索关键词deploy，找到形如下面的内容： 1234deploy: type: git repository: branch: 改成： 1234deploy: type: git repository: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 依次然后输入命令： 123hexo cleanhexo ghexo d 如果没有出错的话，等几分钟，再用浏览器打开&lt;username&gt;.github.io，就可以看到你的博客了。（此时别人也可以通过这个网址看到你的博客） 常见问题问题：输入hexo d后显示deployer not found:git； 解决办法： 修改根目录名称为&lt;username&gt;.github.io，某些时候有玄学问题，不是你仓库对应的名称部署不上去； 检查_config.yml文件内容是否完整，注意每一个:后面都有且只有一个空格； 输入命令npm install hexo-deployer-git --save； 再次尝试部署至$\text{GitHub}$。 美化博客博客主题作者推荐使用$\text{NexT}$主题。 未完待续。]]></content>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>NexT主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【AtCoder dwacon2017-prelims-A】 動画検索]]></title>
    <url>%2F2019%2F02%2F04%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90AtCoder-dwacon2017-prelims-A%E3%80%91-%E5%8B%95%E7%94%BB%E6%A4%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[原题题面请查看AtCoder dwacon2017-prelims-A 動画検索。 也可在洛谷上查看：传送门。 题解模拟 思路模拟即可，注意答案的合法性。 代码代码如下： 123456789101112#include &lt;cstdio&gt;int n, a, b;int main(void)&#123; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); if(a+b&gt;n) printf("%d\n", a + b - n); else puts("0"); return 0;&#125; 我的评测记录 AtCoder； 洛谷 R16059768。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【AtCoder ABC004-C】 入れ替え]]></title>
    <url>%2F2019%2F02%2F04%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90AtCoder-ABC004-C%E3%80%91-%E5%85%A5%E3%82%8C%E6%9B%BF%E3%81%88%2F</url>
    <content type="text"><![CDATA[原题题面请查看AtCoder ABC004-C 入れ替え。 也可在洛谷上查看：传送门。 题解模拟 思路答案$30$一循环，模拟即可。 代码代码如下： 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;char str[7] = "123456";int a;void swap(char&amp;, char&amp;);int main(void)&#123; register int i, now = 0; scanf("%d", &amp;a); a %= 30; for (i = 0; i &lt; a; ++i) &#123; swap(str[now], str[now + 1]); if (++now == 5) now = 0; &#125; puts(str); return 0;&#125;void swap(char&amp; a, char&amp; b)&#123; a ^= b, b = a ^ b, a ^= b; return;&#125; 我的评测记录 AtCoder； 洛谷 R16059682。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】 并查集]]></title>
    <url>%2F2019%2F02%2F04%2F%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[介绍并查集是一种数据结构，体现的是森林（或者树）形态，主要操作有两种： 并，意为合并，操作函数为void connect(int,int);（注：connect vt. &amp; vi. 连接）； 查，意为查询： 查询一个节点的父亲节点，查询函数为int find(int);（注：find v. 寻找）； 查询两个节点是否在用一个集合内，查询函数为bool search(int,int);（注：search v. 搜寻）。 具体思路与实现首先，因为并查集是森林（或者树）的一种，所以我们可以用树的三种表示方法其中之一——父亲结点表示法（其它两种方法是儿子结点表示法和儿子、兄弟表示法）。 定义数组ID[n]（一般编程时数组下标从$1$开始，应使用ID[n+1]），ID[i]表示第$i$个结点当前状态下的父亲。 假设有$n$个结点，为了方便，我们将每一个结点初始的父亲设为它自己。 代码实现如下： 12345678910#define n 100000//假设n=10^5int ID[n+1];void Init(void)&#123;//初始化函数 register int i; for(i=1;i&lt;=n;++i) ID[i]=i; return;&#125; 初始化后的示意图如下： 下面重点介绍如何查询一个节点的父亲节点。 int find(int);不带路径压缩用find(x)表示x的父亲结点的编号。 代码实现如下： 123456int find(int x)&#123; if(x==ID[x])//如果x的父亲结点是自己 return x;//返回x，停止递归 else return find(ID[x]);//继续递归查找父亲结点&#125; 用图理解如下： 设$n=5$，此时并查集的状态如下： 运行find(5)，过程如下： 12345678入口--开始--&gt;运行5时5的父亲结点是3运行5时5的父亲结点是3--继续递归--&gt;运行3时3的父亲结点是2运行3时3的父亲结点是2--继续递归--&gt;运行2时2的父亲结点是1运行2时2的父亲结点是1--继续递归--&gt;运行1时1的父亲结点是自己运行1时1的父亲结点是自己--返回1--&gt;运行2时2的父亲结点是1运行2时2的父亲结点是1--返回1--&gt;运行3时3的父亲结点是2运行3时3的父亲结点是2--返回1--&gt;运行5时5的父亲结点是3运行5时5的父亲结点是3--结束 返回1--&gt;入口 如果还不能理解的话，请手动模拟。 路径压缩用find(x)表示x的父亲结点的编号。 代码实现如下： 123456int find(int x)&#123; if(x==ID[x])//如果x的父亲结点是自己 return x;//返回x，停止递归 else return ID[x]=find(ID[x]);//继续递归查找父亲结点，并赋值以压缩路径&#125; 用图理解如下： 设$n=5$，此时并查集的状态如下： 运行find(5)，过程如下： 12345678入口--开始--&gt;运行5时5的父亲结点是3运行5时5的父亲结点是3--继续递归--&gt;运行3时3的父亲结点是2运行3时3的父亲结点是2--继续递归--&gt;运行2时2的父亲结点是1运行2时2的父亲结点是1--继续递归--&gt;运行1时1的父亲结点是自己运行1时1的父亲结点是自己--返回1--&gt;运行2时2的父亲结点是1运行2时2的父亲结点是1--返回1 并将2的父亲结点改为1--&gt;运行3时3的父亲结点是2运行3时3的父亲结点是2--返回1 并将3的父亲结点改为1--&gt;运行5时5的父亲结点是3运行5时5的父亲结点是3--结束 返回1 并将5的父亲结点改为1--&gt;入口 运行过后，整个并查集的状态发生了改变，变成了这样： 在这次操作之后，再次调用find(5)只需要$\text{O} (1)$的时间。 void connect(int,int);在此之前，我们已经实现了int find(int);，那么其他的两个操作都比较简单，具体实现如下： 12345678910void connect(int a,int b)&#123; register int ra=find(a),rb=find(b);//寻找a和b的祖先节点，记为ra,rb if(ra!=rb)//假如a,b的祖先节点不同 ID[rb]=ra;//把rb的父亲节点设为ra return;&#125;bool search(int a,int b)&#123; return find(a)==find(b);//比较a,b的祖先节点是否相同&#125; 下面是一个具体的例子： 设$n=6$，此时并查集的状态如下。 123456ID[1]=1;ID[2]=1;ID[3]=2;ID[4]=5;ID[5]=5;ID[6]=6; 用图表示为： 执行操作connect(4,6)： $4$的祖先是$5$，$6$的祖先是它本身； 显然，$5 \ne 6$； 所以把$6$的祖先设置为$5$； 结束。 操作完成后： 123456ID[1]=1;ID[2]=1;ID[3]=2;ID[4]=5;ID[5]=5;ID[6]=5;//主要操作 用图表示为： 执行操作connect(6,3)： $6$的祖先是$5$，$3$的祖先是$1$； 显然，$5 \ne 1$； 所以把$1$的祖先设置为$5$； 结束。 操作完成后： 123456ID[1]=5;//主要操作ID[2]=1;ID[3]=1;//find()过程中进行了路径压缩ID[4]=5;ID[5]=5;ID[6]=5; 用图表示为： 模板题洛谷：P3367 【模板】并查集； 代码： 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int n,m,ID[10001],i,z,x,y;int find(int x)&#123; if(ID[x]==x) return x; else return ID[x]=find(ID[x]);&#125;void contact(int a,int b)&#123; int ra=find(a),rb=find(b); if(ra!=rb) ID[rb]=ra; return;&#125;bool search(int a,int b)&#123; return find(a)==find(b);&#125;int main(void)&#123; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++) ID[i]=i; for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;z,&amp;x,&amp;y); if(z==1) contact(x,y); else if(search(x,y)) puts("Y"); else puts("N"); &#125; return 0;&#125; 评测记录 R8237877。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【Codeforces 271B】 Prime Matrix]]></title>
    <url>%2F2019%2F02%2F03%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90Codeforces-271B%E3%80%91-Prime-Matrix%2F</url>
    <content type="text"><![CDATA[原题题面请查看Codeforces 271B Prime Matrix。 也可在洛谷上查看：传送门。 题解埃氏筛 思路 用埃氏筛求出$1$~$10^{5}+3$以内的所有素数； 求出矩阵内每个元素变为素数的操作次数； 为最后统计方便，记a[i][0]为第$i$行的操作总数，a[0][j]为第$j$列的操作总数； 统计答案。 细节$10^5$经过操作后的素数是$100003$，所以埃氏筛要筛到$100003$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#define INF 0X3F3F3F3F3F3F3F3F#define min(a, b) ((a) &lt; (b) ? (a) : (b))//头文件，正无穷，函数min()bool isNotPrime[100004];//埃氏筛的标记数组int n, m, a[501][501];int main(void)&#123; register int i, j; register long long now, temp, ans = INF; scanf("%d%d", &amp;n, &amp;m);//读入n,m /*----埃氏筛----*/ isNotPrime[1] = true; for (i = 2; i &lt;= 100003; ++i) &#123; if (!isNotPrime[i]) for (j = (i &lt;&lt; 1); j &lt;= 100003; j += i) isNotPrime[j] = true; &#125; for (i = 1; i &lt;= n; ++i) for (j = 1; j &lt;= m; ++j) &#123; scanf("%d", &amp;a[i][j]);//先读入 now = temp = a[i][j]; while (isNotPrime[now]) ++now; //寻找最近的素数now a[i][j] = now - temp;//求操作次数 a[i][0] += a[i][j]; a[0][j] += a[i][j]; //为方便统计，记a[i][0]为第i行的操作总数，a[0][j]为第j列的操作总数 &#125; for (i = 1; i &lt;= n; ++i) ans = min(ans, a[i][0]); for (j = 1; j &lt;= m; ++j) ans = min(ans, a[0][j]);//统计 printf("%lld\n", ans);//输出并换行 return 0;&#125; 我的评测记录 Codeforces； 洛谷。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>埃氏筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1196】 [NOI2002]银河英雄传说]]></title>
    <url>%2F2019%2F02%2F03%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P1196%E3%80%91-NOI2002-%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1196 [NOI2002]银河英雄传说。 题解并查集 思路 观察合并指令：$M_{i,j}$，说到合并，就能想到一个优秀的【数据结构】并查集。 这就好比说到六六大顺，就能想到六小龄童，说到六小龄童，就想到他在西游记中的角色孙悟空。今年年初，中美合拍的西游记即将正式开机，六小龄童继续扮演美猴王孙悟空，六小龄童会用美猴王艺术形象努力创造一个正能量的形象，文体两开花，弘扬中华文化，希望大家多多关注。 观察询问指令：$C_{i,j}$，运用前缀和的思想，我们设$\text{front[x]}$为$x$前面有多少架战舰，那么查询的答案就是$| front[i]-front[j] | - 1$。 记$\text{num[i]}$为第$i$列飞船的数量，那么我们只需要对并查集的$\text{int find(int);}$函数进行魔改即可维护$\text{front[]}$数组。 代码代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;using std::cin;#define abs(a) ((a) &gt; 0 ? (a) : (-(a)))int T, ID[30001], front[30001], num[30001];int find(int);int main(void)&#123; register int i; scanf("%d", &amp;T); for (i = 1; i &lt;= 30000; ++i) &#123; ID[i] = i; num[i] = 1; &#125; while (T--) &#123; static char ch; static int x, y, fx, fy; cin &gt;&gt; ch; scanf("%d%d", &amp;x, &amp;y); fx = find(x), fy = find(y); if (ch == 'M') &#123; front[fx] += num[fy]; ID[fx] = fy; num[fy] += num[fx]; num[fx] = 0; &#125; else if (fx != fy) puts("-1"); else printf("%d\n", abs(front[x] - front[y]) - 1); &#125; return 0;&#125;int find(int x)&#123; if (ID[x] == x) return ID[x]; else &#123; register int root = find(ID[x]); front[x] += front[ID[x]]; return ID[x] = root; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>图论</tag>
        <tag>NOIp提高组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1967】 货车运输]]></title>
    <url>%2F2019%2F02%2F03%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P1967%E3%80%91-%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1967 货车运输。 题解$\text{Kruskal}$算法+倍增求$\text{LCA}$ 思路根据题面，假设我们有一个普通的图： 作图工具：Graph Editor 考虑从顶点$1$走到顶点$3$： 路径$1 \to 3$（最大运货量为$1$）； 路径$1 \to 2 \to 3$（最大运货量为$3$，更优）。 所以我们可以删掉$1 \to 3$这条边，形成了一棵树，通过多次观察发现，这是一颗原图的最大生成树。 问题就被转化成了求最大生成树和在树上解决原问题。 代码 求最大生成树：我们使用$\text{Kruskal}$算法； 在树上解决原问题比较简单，我们只需要通过最近公共祖先（倍增法求解）进行求解即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;algorithm&gt;#include &lt;cstdio&gt;using std::sort;#define INF 0X3F3F3F3F#define min(a, b) ((a) &lt; (b) ? (a) : (b))struct Tree&#123; bool vis[10001]; int cnt, head[10001], to[20001], w[20001], Next[20001]; int dep[10001], fa[10001][21], W[10001][21]; void DFS(int); void Add_Edge(int, int, int); void LCA_Init(void); int LCA(int, int);&#125;;struct Graph&#123; struct Kruskal &#123; struct Edge &#123; int f, t, val; bool operator&lt;(const Edge &amp;a) const &#123; return val &gt; a.val; &#125; &#125;; struct Union_Find &#123; int ID[10001]; void Init(void); void connect(int, int); bool search(int, int); int find(int); &#125;; Union_Find B; Edge E[50001]; void kruskal(void); &#125;; int n, m; Kruskal K; void Read(void);&#125;;int q;Tree T;Graph G;int main(void)&#123; G.Read(); G.K.B.Init(); G.K.kruskal(); T.LCA_Init(); scanf("%d", &amp;q); while (q--) &#123; static int x, y; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", T.LCA(x, y)); &#125; return 0;&#125;void Tree::Add_Edge(int f, int t, int val)&#123; Next[++cnt] = head[f]; to[cnt] = t; w[cnt] = val; head[f] = cnt; return;&#125;void Tree::DFS(int ID)&#123; register int i, To; vis[ID] = true; for (i = head[ID]; i; i = Next[i]) &#123; To = to[i]; if (vis[To]) continue; dep[To] = dep[ID] + 1; fa[To][0] = ID; W[To][0] = w[i]; DFS(To); &#125; return;&#125;void Tree::LCA_Init(void)&#123; register int i, j; for (i = 1; i &lt;= G.n; ++i) if (!vis[i]) &#123; dep[i] = 1; DFS(i); fa[i][0] = i; W[i][0] = INF; &#125; for (i = 1; i &lt;= 20; ++i) for (j = 1; j &lt;= G.n; ++j) &#123; fa[j][i] = fa[fa[j][i - 1]][i - 1]; W[j][i] = min(W[j][i - 1], W[fa[j][i - 1]][i - 1]); &#125; return;&#125;int Tree::LCA(int x, int y)&#123; if (!G.K.B.search(x, y)) return -1; register int i, ans = INF; if (dep[x] &gt; dep[y]) &#123; int temp = x; x = y; y = temp; &#125; for (i = 20; i &gt;= 0; --i) if (dep[fa[y][i]] &gt;= dep[x]) &#123; ans = min(ans, W[y][i]); y = fa[y][i]; &#125; if (x == y) return ans; for (i = 20; i &gt;= 0; --i) if (fa[x][i] != fa[y][i]) &#123; ans = min(ans, min(W[x][i], W[y][i])); x = fa[x][i]; y = fa[y][i]; &#125; ans = min(ans, min(W[x][0], W[y][0])); return ans;&#125;void Graph::Kruskal::Union_Find::Init(void)&#123; register int i; for (i = 1; i &lt;= G.n; ++i) ID[i] = i; return;&#125;void Graph::Kruskal::Union_Find::connect(int a, int b)&#123; register int ra = find(a), rb = find(b); if (ra != rb) ID[rb] = ra; return;&#125;bool Graph::Kruskal::Union_Find::search(int a, int b)&#123; return find(a) == find(b);&#125;int Graph::Kruskal::Union_Find::find(int x)&#123; if (x == ID[x]) return x; else return ID[x] = find(ID[x]);&#125;void Graph::Kruskal::kruskal(void)&#123; register int i, cnt = 0; sort(E + 1, E + G.m + 1); for (i = 1; i &lt;= G.m &amp;&amp; cnt &lt; G.n - 1; ++i) &#123; if (!B.search(E[i].f, E[i].t)) &#123; B.connect(E[i].f, E[i].t); ++cnt; T.Add_Edge(E[i].f, E[i].t, E[i].val); T.Add_Edge(E[i].t, E[i].f, E[i].val); &#125; &#125; return;&#125;void Graph::Read(void)&#123; register int i; scanf("%d%d", &amp;n, &amp;m); for (i = 1; i &lt;= m; ++i) scanf("%d%d%d", &amp;K.E[i].f, &amp;K.E[i].t, &amp;K.E[i].val); return;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>图论</tag>
        <tag>NOIp提高组</tag>
        <tag>Kruskal</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
</search>
