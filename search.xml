<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【题解】【AtCoder ABC004-C】 入れ替え]]></title>
    <url>%2F2019%2F02%2F04%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90AtCoder-ABC004-C%E3%80%91-%E5%85%A5%E3%82%8C%E6%9B%BF%E3%81%88%2F</url>
    <content type="text"><![CDATA[原题题面请查看AtCoder ABC004-C 入れ替え。 也可在洛谷上查看：传送门。 题解模拟 思路答案$30$一循环，模拟即可。 代码代码如下： 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;char str[7] = "123456";int a;void swap(char&amp;, char&amp;);int main(void)&#123; register int i, now = 0; scanf("%d", &amp;a); a %= 30; for (i = 0; i &lt; a; ++i) &#123; swap(str[now], str[now + 1]); if (++now == 5) now = 0; &#125; puts(str); return 0;&#125;void swap(char&amp; a, char&amp; b)&#123; a ^= b, b = a ^ b, a ^= b; return;&#125; 我的评测记录 AtCoder； 洛谷 R16059682。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】 并查集]]></title>
    <url>%2F2019%2F02%2F04%2F%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[介绍并查集是一种数据结构，体现的是森林（或者树）形态，主要操作有两种： 并，意为合并，操作函数为void connect(int,int);（注：connect vt. &amp; vi. 连接）； 查，意为查询： 查询一个节点的父亲节点，查询函数为int find(int);（注：find v. 寻找）； 查询两个节点是否在用一个集合内，查询函数为bool search(int,int);（注：search v. 搜寻）。 具体思路与实现首先，因为并查集是森林（或者树）的一种，所以我们可以用树的三种表示方法其中之一——父亲结点表示法（其它两种方法是儿子结点表示法和儿子、兄弟表示法）。 定义数组ID[n]（一般编程时数组下标从$1$开始，应使用ID[n+1]），ID[i]表示第$i$个结点当前状态下的父亲。 假设有$n$个结点，为了方便，我们将每一个结点初始的父亲设为它自己。 代码实现如下： 12345678910#define n 100000//假设n=10^5int ID[n+1];void Init(void)&#123;//初始化函数 register int i; for(i=1;i&lt;=n;++i) ID[i]=i; return;&#125; 初始化后的示意图如下： 12345graph TD; 1--&gt;1; 2--&gt;2; ... n--&gt;n; 下面重点介绍如何查询一个节点的父亲节点。 int find(int);不带路径压缩用find(x)表示x的父亲结点的编号。 代码实现如下： 123456int find(int x)&#123; if(x==ID[x])//如果x的父亲结点是自己 return x;//返回x，停止递归 else return find(ID[x]);//继续递归查找父亲结点&#125; 用图理解如下： 设$n=5$，此时并查集的状态如下： 123456graph BT; 1--&gt;1 2--&gt;1 3--&gt;2 4--&gt;1 5--&gt;3 运行find(5)，过程如下： 123456789graph TB; 入口--开始--&gt;运行5时5的父亲结点是3 运行5时5的父亲结点是3--继续递归--&gt;运行3时3的父亲结点是2 运行3时3的父亲结点是2--继续递归--&gt;运行2时2的父亲结点是1 运行2时2的父亲结点是1--继续递归--&gt;运行1时1的父亲结点是自己 运行1时1的父亲结点是自己--返回1--&gt;运行2时2的父亲结点是1 运行2时2的父亲结点是1--返回1--&gt;运行3时3的父亲结点是2 运行3时3的父亲结点是2--返回1--&gt;运行5时5的父亲结点是3 运行5时5的父亲结点是3--结束 返回1--&gt;入口 如果还不能理解的话，请手动模拟。 路径压缩用find(x)表示x的父亲结点的编号。 代码实现如下： 123456int find(int x)&#123; if(x==ID[x])//如果x的父亲结点是自己 return x;//返回x，停止递归 else return ID[x]=find(ID[x]);//继续递归查找父亲结点，并赋值以压缩路径&#125; 用图理解如下： 设$n=5$，此时并查集的状态如下： 123456graph BT; 1--&gt;1 2--&gt;1 3--&gt;2 4--&gt;1 5--&gt;3 运行find(5)，过程如下： 123456789graph TB; 入口--开始--&gt;运行5时5的父亲结点是3 运行5时5的父亲结点是3--继续递归--&gt;运行3时3的父亲结点是2 运行3时3的父亲结点是2--继续递归--&gt;运行2时2的父亲结点是1 运行2时2的父亲结点是1--继续递归--&gt;运行1时1的父亲结点是自己 运行1时1的父亲结点是自己--返回1--&gt;运行2时2的父亲结点是1 运行2时2的父亲结点是1--返回1 并将2的父亲结点改为1--&gt;运行3时3的父亲结点是2 运行3时3的父亲结点是2--返回1 并将3的父亲结点改为1--&gt;运行5时5的父亲结点是3 运行5时5的父亲结点是3--结束 返回1 并将5的父亲结点改为1--&gt;入口 运行过后，整个并查集的状态发生了改变，变成了这样： 123456graph BT; 1--&gt;1 2--&gt;1 3--&gt;1 4--&gt;1 5--&gt;1 在这次操作之后，再次调用find(5)只需要$O(1)$的时间。 void connect(int,int);在此之前，我们已经实现了int find(int);，那么其他的两个操作都比较简单，具体实现如下： 12345678910void connect(int a,int b)&#123; register int ra=find(a),rb=find(b);//寻找a和b的祖先节点，记为ra,rb if(ra!=rb)//假如a,b的祖先节点不同 ID[rb]=ra;//把rb的父亲节点设为ra return;&#125;bool search(int a,int b)&#123; return find(a)==find(b);//比较a,b的祖先节点是否相同&#125; 下面是一个具体的例子： 设$n=6$，此时并查集的状态如下。 123456ID[1]=1;ID[2]=1;ID[3]=2;ID[4]=5;ID[5]=5;ID[6]=6; 用图表示为： 1234567graph BT; 1--&gt;1 2--&gt;1 3--&gt;2 4--&gt;5 5--&gt;5 6--&gt;6 执行操作connect(4,6)： $4$的祖先是$5$，$6$的祖先是它本身； 显然，$5 \ne 6$； 所以把$6$的祖先设置为$5$； 结束。 操作完成后： 123456ID[1]=1;ID[2]=1;ID[3]=2;ID[4]=5;ID[5]=5;ID[6]=5;//主要操作 用图表示为： 1234567graph BT; 1--&gt;1 2--&gt;1 3--&gt;2 4--&gt;5 5--&gt;5 6--&gt;5 执行操作connect(6,3)： $6$的祖先是$5$，$3$的祖先是$1$； 显然，$5 \ne 1$； 所以把$1$的祖先设置为$5$； 结束。 操作完成后： 123456ID[1]=5;//主要操作ID[2]=1;ID[3]=1;//find()过程中进行了路径压缩ID[4]=5;ID[5]=5;ID[6]=5; 用图表示为： 1234567graph BT; 1--&gt;5 2--&gt;1 3--&gt;1 4--&gt;5 5--&gt;5 6--&gt;5 模板题洛谷：P3367 【模板】并查集； 代码： 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int n,m,ID[10001],i,z,x,y;int find(int x)&#123; if(ID[x]==x) return x; else return ID[x]=find(ID[x]);&#125;void contact(int a,int b)&#123; int ra=find(a),rb=find(b); if(ra!=rb) ID[rb]=ra; return;&#125;bool search(int a,int b)&#123; return find(a)==find(b);&#125;int main(void)&#123; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++) ID[i]=i; for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;z,&amp;x,&amp;y); if(z==1) contact(x,y); else if(search(x,y)) puts("Y"); else puts("N"); &#125; return 0;&#125; 评测记录 R8237877。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【Codeforces 271B】 Prime Matrix]]></title>
    <url>%2F2019%2F02%2F03%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90Codeforces-271B%E3%80%91-Prime-Matrix%2F</url>
    <content type="text"><![CDATA[原题题面请查看Codeforces 271B Prime Matrix。 也可在洛谷上查看：传送门。 题解埃氏筛 思路 用埃氏筛求出$1$~$10^{5}+3$以内的所有素数； 求出矩阵内每个元素变为素数的操作次数； 为最后统计方便，记a[i][0]为第$i$行的操作总数，a[0][j]为第$j$列的操作总数； 统计答案。 细节$10^5$经过操作后的素数是$100003$，所以埃氏筛要筛到$100003$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#define INF 0X3F3F3F3F3F3F3F3F#define min(a, b) ((a) &lt; (b) ? (a) : (b))//头文件，正无穷，函数min()bool isNotPrime[100004];//埃氏筛的标记数组int n, m, a[501][501];int main(void)&#123; register int i, j; register long long now, temp, ans = INF; scanf("%d%d", &amp;n, &amp;m);//读入n,m /*----埃氏筛----*/ isNotPrime[1] = true; for (i = 2; i &lt;= 100003; ++i) &#123; if (!isNotPrime[i]) for (j = (i &lt;&lt; 1); j &lt;= 100003; j += i) isNotPrime[j] = true; &#125; for (i = 1; i &lt;= n; ++i) for (j = 1; j &lt;= m; ++j) &#123; scanf("%d", &amp;a[i][j]);//先读入 now = temp = a[i][j]; while (isNotPrime[now]) ++now; //寻找最近的素数now a[i][j] = now - temp;//求操作次数 a[i][0] += a[i][j]; a[0][j] += a[i][j]; //为方便统计，记a[i][0]为第i行的操作总数，a[0][j]为第j列的操作总数 &#125; for (i = 1; i &lt;= n; ++i) ans = min(ans, a[i][0]); for (j = 1; j &lt;= m; ++j) ans = min(ans, a[0][j]);//统计 printf("%lld\n", ans);//输出并换行 return 0;&#125; 我的评测记录 Codeforces； 洛谷。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>埃氏筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1196】 [NOI2002]银河英雄传说]]></title>
    <url>%2F2019%2F02%2F03%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P1196%E3%80%91-NOI2002-%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1196 [NOI2002]银河英雄传说。 题解并查集 思路 观察合并指令：$M_{i,j}$，说到合并，就能想到一个优秀的【数据结构】并查集。 这就好比说到六六大顺，就能想到六小龄童，说到六小龄童，就想到他在西游记中的角色孙悟空。今年年初，中美合拍的西游记即将正式开机，六小龄童继续扮演美猴王孙悟空，六小龄童会用美猴王艺术形象努力创造一个正能量的形象，文体两开花，弘扬中华文化，希望大家多多关注。 观察询问指令：$C_{i,j}$，运用前缀和的思想，我们设$\text{front[x]}$为$x$前面有多少架战舰，那么查询的答案就是$| front[i]-front[j] | - 1$。 记$\text{num[i]}$为第$i$列飞船的数量，那么我们只需要对并查集的$\text{int find(int);}$函数进行魔改即可维护$\text{front[]}$数组。 代码代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;using std::cin;#define abs(a) ((a) &gt; 0 ? (a) : (-(a)))int T, ID[30001], front[30001], num[30001];int find(int);int main(void)&#123; register int i; scanf("%d", &amp;T); for (i = 1; i &lt;= 30000; ++i) &#123; ID[i] = i; num[i] = 1; &#125; while (T--) &#123; static char ch; static int x, y, fx, fy; cin &gt;&gt; ch; scanf("%d%d", &amp;x, &amp;y); fx = find(x), fy = find(y); if (ch == 'M') &#123; front[fx] += num[fy]; ID[fx] = fy; num[fy] += num[fx]; num[fx] = 0; &#125; else if (fx != fy) puts("-1"); else printf("%d\n", abs(front[x] - front[y]) - 1); &#125; return 0;&#125;int find(int x)&#123; if (ID[x] == x) return ID[x]; else &#123; register int root = find(ID[x]); front[x] += front[ID[x]]; return ID[x] = root; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
        <tag>洛谷</tag>
        <tag>NOIp提高组</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】【洛谷 P1967】 货车运输]]></title>
    <url>%2F2019%2F02%2F03%2F%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P1967%E3%80%91-%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%2F</url>
    <content type="text"><![CDATA[原题题面请查看洛谷 P1967 货车运输。 题解$\text{Kruskal}$算法+倍增求$\text{LCA}$ 思路根据题面，假设我们有一个普通的图： 作图工具：Graph Editor 考虑从顶点$1$走到顶点$3$： 路径$1 \to 3$（最大运货量为$1$）； 路径$1 \to 2 \to 3$（最大运货量为$3$，更优）。 所以我们可以删掉$1 \to 3$这条边，形成了一棵树，通过多次观察发现，这是一颗原图的最大生成树。 问题就被转化成了求最大生成树和在树上解决原问题。 代码 求最大生成树：我们使用$\text{Kruskal}$算法； 在树上解决原问题比较简单，我们只需要通过最近公共祖先（倍增法求解）进行求解即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;algorithm&gt;#include &lt;cstdio&gt;using std::sort;#define INF 0X3F3F3F3F#define min(a, b) ((a) &lt; (b) ? (a) : (b))struct Tree&#123; bool vis[10001]; int cnt, head[10001], to[20001], w[20001], Next[20001]; int dep[10001], fa[10001][21], W[10001][21]; void DFS(int); void Add_Edge(int, int, int); void LCA_Init(void); int LCA(int, int);&#125;;struct Graph&#123; struct Kruskal &#123; struct Edge &#123; int f, t, val; bool operator&lt;(const Edge &amp;a) const &#123; return val &gt; a.val; &#125; &#125;; struct Union_Find &#123; int ID[10001]; void Init(void); void connect(int, int); bool search(int, int); int find(int); &#125;; Union_Find B; Edge E[50001]; void kruskal(void); &#125;; int n, m; Kruskal K; void Read(void);&#125;;int q;Tree T;Graph G;int main(void)&#123; G.Read(); G.K.B.Init(); G.K.kruskal(); T.LCA_Init(); scanf("%d", &amp;q); while (q--) &#123; static int x, y; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", T.LCA(x, y)); &#125; return 0;&#125;void Tree::Add_Edge(int f, int t, int val)&#123; Next[++cnt] = head[f]; to[cnt] = t; w[cnt] = val; head[f] = cnt; return;&#125;void Tree::DFS(int ID)&#123; register int i, To; vis[ID] = true; for (i = head[ID]; i; i = Next[i]) &#123; To = to[i]; if (vis[To]) continue; dep[To] = dep[ID] + 1; fa[To][0] = ID; W[To][0] = w[i]; DFS(To); &#125; return;&#125;void Tree::LCA_Init(void)&#123; register int i, j; for (i = 1; i &lt;= G.n; ++i) if (!vis[i]) &#123; dep[i] = 1; DFS(i); fa[i][0] = i; W[i][0] = INF; &#125; for (i = 1; i &lt;= 20; ++i) for (j = 1; j &lt;= G.n; ++j) &#123; fa[j][i] = fa[fa[j][i - 1]][i - 1]; W[j][i] = min(W[j][i - 1], W[fa[j][i - 1]][i - 1]); &#125; return;&#125;int Tree::LCA(int x, int y)&#123; if (!G.K.B.search(x, y)) return -1; register int i, ans = INF; if (dep[x] &gt; dep[y]) &#123; int temp = x; x = y; y = temp; &#125; for (i = 20; i &gt;= 0; --i) if (dep[fa[y][i]] &gt;= dep[x]) &#123; ans = min(ans, W[y][i]); y = fa[y][i]; &#125; if (x == y) return ans; for (i = 20; i &gt;= 0; --i) if (fa[x][i] != fa[y][i]) &#123; ans = min(ans, min(W[x][i], W[y][i])); x = fa[x][i]; y = fa[y][i]; &#125; ans = min(ans, min(W[x][0], W[y][0])); return ans;&#125;void Graph::Kruskal::Union_Find::Init(void)&#123; register int i; for (i = 1; i &lt;= G.n; ++i) ID[i] = i; return;&#125;void Graph::Kruskal::Union_Find::connect(int a, int b)&#123; register int ra = find(a), rb = find(b); if (ra != rb) ID[rb] = ra; return;&#125;bool Graph::Kruskal::Union_Find::search(int a, int b)&#123; return find(a) == find(b);&#125;int Graph::Kruskal::Union_Find::find(int x)&#123; if (x == ID[x]) return x; else return ID[x] = find(ID[x]);&#125;void Graph::Kruskal::kruskal(void)&#123; register int i, cnt = 0; sort(E + 1, E + G.m + 1); for (i = 1; i &lt;= G.m &amp;&amp; cnt &lt; G.n - 1; ++i) &#123; if (!B.search(E[i].f, E[i].t)) &#123; B.connect(E[i].f, E[i].t); ++cnt; T.Add_Edge(E[i].f, E[i].t, E[i].val); T.Add_Edge(E[i].t, E[i].f, E[i].val); &#125; &#125; return;&#125;void Graph::Read(void)&#123; register int i; scanf("%d%d", &amp;n, &amp;m); for (i = 1; i &lt;= m; ++i) scanf("%d%d%d", &amp;K.E[i].f, &amp;K.E[i].t, &amp;K.E[i].val); return;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>NOIp提高组</tag>
        <tag>图论</tag>
        <tag>Kruskal</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
</search>
