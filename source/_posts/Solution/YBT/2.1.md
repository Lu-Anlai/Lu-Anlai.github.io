---
title: 信息学奥赛一本通（C++版）第二部分 基础算法 第一章 高精度计算
date: 2019-03-09 21:35:49
categories: Solution
tags:
- 题解
- 信息学奥赛一本通
---

信息学奥赛一本通（C++版）第二部分 基础算法 第一章 高精度计算

<!-- more -->

### T1307 : 高精度乘法

> 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$

#### 【题目描述】

输入两个高精度正整数$M$和$N$（$M$和$N$均小于$100$位）。求这两个高精度数的积。

#### 【输入】

输入两个高精度正整数$M$和$N$。

#### 【输出】

求这两个高精度数的积。

#### 【输入样例】

```
36
3
```

#### 【输出样例】

```
108
```

#### 【答案&代码】

```cpp
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<iostream>
#include<string>
using std::string;
using std::cin;
using std::cout;
using std::istream;
using std::ostream;
using std::endl;
using std::max;
#define MAX_LENGTH 2005
struct BIG_NUMBER{
	int len,s[MAX_LENGTH];
	bool sign;
	
	BIG_NUMBER(void);
	BIG_NUMBER(const char*);
	BIG_NUMBER(int);
	~BIG_NUMBER(void);
	void clean(void);
	string toStr(void)const;
	friend istream& operator>>(istream&,BIG_NUMBER&);
	friend ostream& operator<<(ostream&,BIG_NUMBER&);
	BIG_NUMBER operator=(const char*);
	BIG_NUMBER operator=(int);
	BIG_NUMBER operator=(const string);
	bool operator>(const BIG_NUMBER&)const;
	bool operator>=(const BIG_NUMBER&)const;
	bool operator<(const BIG_NUMBER&)const;
	bool operator<=(const BIG_NUMBER&)const;
	bool operator==(const BIG_NUMBER&)const;
	bool operator!=(const BIG_NUMBER&)const;
	BIG_NUMBER operator+(const BIG_NUMBER&)const;
	BIG_NUMBER operator++(void);
	BIG_NUMBER operator++(int);
	BIG_NUMBER operator+=(const BIG_NUMBER&);
	BIG_NUMBER operator-(const BIG_NUMBER &) const;
	BIG_NUMBER operator--(void);
	BIG_NUMBER operator--(int);
	BIG_NUMBER operator-=(const BIG_NUMBER&);
	BIG_NUMBER operator*(const BIG_NUMBER &)const;
	BIG_NUMBER operator*(const int num)const;
	BIG_NUMBER operator*=(const BIG_NUMBER&);
	BIG_NUMBER operator/(const BIG_NUMBER&)const;
	BIG_NUMBER operator/=(const BIG_NUMBER&);
	BIG_NUMBER operator%(const BIG_NUMBER&)const;
	BIG_NUMBER factorial(void)const;
	BIG_NUMBER sqrt(void)const;
	BIG_NUMBER pow(const BIG_NUMBER&)const;
};
BIG_NUMBER::BIG_NUMBER(void){
	memset(s, 0, sizeof(s));
	len = 1;
	sign = 1;
}
BIG_NUMBER::BIG_NUMBER(const char*num){
	*this = num;
}
BIG_NUMBER::BIG_NUMBER(int num){
	*this = num;
}
string BIG_NUMBER::toStr(void)const{
	string res;
	res = "";
	for (int i = 0; i < len; i++)
		res = (char)(s[i] + '0') + res;
	if (res == "")
		res = "0";
	if (!sign&&res != "0")
		res = "-" + res;
	return res;
}
istream &operator>>(istream &in,BIG_NUMBER&num){
	string str;
	in>>str;
	num=str;
	return in;
}
ostream &operator<<(ostream &out,BIG_NUMBER&num){
	out<<num.toStr();
	return out;
}
BIG_NUMBER BIG_NUMBER::operator=(const char*num){
	memset(s, 0, sizeof(s));
	char a[MAX_LENGTH] = "";
	if (num[0] != '-')
		strcpy(a, num);
	else
		for (int i = 1; i < strlen(num); i++)
			a[i - 1] = num[i];
	sign = !(num[0] == '-');
	len = strlen(a);
	for (int i = 0; i < strlen(a); i++)
		s[i] = a[len - i - 1] - 48;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator=(int num){
	char temp[MAX_LENGTH];
	sprintf(temp, "%d", num);
	*this = temp;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator=(const string num){
	const char *tmp;
	tmp = num.c_str();
	*this = tmp;
	return *this;
}
bool BIG_NUMBER::operator<(const BIG_NUMBER&num)const{
	if (sign^num.sign)
		return num.sign;
	if (len != num.len)
		return len < num.len;
	for (int i = len - 1; i >= 0; i--)
		if (s[i] != num.s[i])
			return sign ? (s[i] < num.s[i]) : (!(s[i] < num.s[i]));
	return !sign;
}
bool BIG_NUMBER::operator>(const BIG_NUMBER&num)const{
	return num < *this;
}
bool BIG_NUMBER::operator<=(const BIG_NUMBER&num)const{
	return !(*this>num);
}
bool BIG_NUMBER::operator>=(const BIG_NUMBER&num)const{
	return !(*this<num);
}
bool BIG_NUMBER::operator!=(const BIG_NUMBER&num)const{
	return *this > num || *this < num;
}
bool BIG_NUMBER::operator==(const BIG_NUMBER&num)const{
	return !(num != *this);
}
BIG_NUMBER BIG_NUMBER::operator+(const BIG_NUMBER &num)const{
	if (sign^num.sign) {
		BIG_NUMBER tmp = sign ? num : *this;
		tmp.sign = 1;
		return sign ? *this - tmp : num - tmp;
	}
	BIG_NUMBER result;
	result.len = 0;
	int temp = 0;
	for (int i = 0; temp || i < (max(len, num.len)); i++) {
		int t = s[i] + num.s[i] + temp;
		result.s[result.len++] = t % 10;
		temp = t / 10;
	}
	result.sign = sign;
	return result;
}
BIG_NUMBER BIG_NUMBER::operator++(void){
	*this = *this + 1;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator++(int){
	BIG_NUMBER old = *this;
	++(*this);
	return old;
}
BIG_NUMBER BIG_NUMBER::operator+=(const BIG_NUMBER &num){
	*this = *this + num;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator-(const BIG_NUMBER &num) const{
	BIG_NUMBER b=num,a=*this;
	if (!num.sign && !sign) {
		b.sign=1;
		a.sign=1;
		return b-a;
	}
	if (!b.sign) {
		b.sign=1;
		return a+b;
	}
	if (!a.sign) {
		a.sign=1;
		b=BIG_NUMBER(0)-(a+b);
		return b;
	}
	if (a<b) {
		BIG_NUMBER c=(b-a);
		c.sign=false;
		return c;
	}
	BIG_NUMBER result;
	result.len = 0;
	for (int i = 0, g = 0; i < a.len; i++) {
		int x = a.s[i] - g;
		if (i < b.len) x -= b.s[i];
		if (x >= 0) g = 0;
		else {
			g = 1;
			x += 10;
		}
		result.s[result.len++] = x;
	}
	result.clean();
	return result;
}
BIG_NUMBER BIG_NUMBER::operator*(const BIG_NUMBER &num)const{
	BIG_NUMBER result;
	result.len = len + num.len;

	for (int i = 0; i < len; i++)
		for (int j = 0; j < num.len; j++)
			result.s[i + j] += s[i] * num.s[j];

	for (int i = 0; i < result.len; i++) {
		result.s[i + 1] += result.s[i] / 10;
		result.s[i] %= 10;
	}
	result.clean();
	result.sign = !(sign^num.sign);
	return result;
}
BIG_NUMBER BIG_NUMBER::operator*(const int num)const{
	BIG_NUMBER x = num;
	BIG_NUMBER z = *this;
	return x*z;
}
BIG_NUMBER BIG_NUMBER::operator*=(const BIG_NUMBER&num){
	*this = *this * num;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator/(const BIG_NUMBER&num)const{
	BIG_NUMBER ans;
	ans.len = len - num.len + 1;
	if (ans.len < 0) {
		ans.len = 1;
		return ans;
	}

	BIG_NUMBER divisor = *this, divid = num;
	divisor.sign = divid.sign = 1;
	int k = ans.len - 1;
	int j = len - 1;
	while (k >= 0) {
		while (divisor.s[j] == 0) j--;
		if (k > j) k = j;
		char z[MAX_LENGTH];
		memset(z, 0, sizeof(z));
		for (int i = j; i >= k; i--)
			z[j - i] = divisor.s[i] + '0';
		BIG_NUMBER dividend = z;
		if (dividend < divid) {
			k--;
			continue;
		}
		int key = 0;
		while (divid*key <= dividend) key++;
		key--;
		ans.s[k] = key;
		BIG_NUMBER temp = divid*key;
		for (int i = 0; i < k; i++)
			temp = temp * 10;
		divisor = divisor - temp;
		k--;
	}
	ans.clean();
	ans.sign = !(sign^num.sign);
	return ans;
}
BIG_NUMBER BIG_NUMBER::operator/=(const BIG_NUMBER&num){
	*this = *this / num;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator%(const BIG_NUMBER& num)const{
	BIG_NUMBER a = *this, b = num;
	a.sign = b.sign = 1;
	BIG_NUMBER result, temp = a / b*b;
	result = a - temp;
	result.sign = sign;
	return result;
}
BIG_NUMBER BIG_NUMBER::pow(const BIG_NUMBER& num)const{
	BIG_NUMBER result = 1;
	for (BIG_NUMBER i = 0; i < num; i++)
		result = result*(*this);
	return result;
}
BIG_NUMBER BIG_NUMBER::factorial(void)const{
	BIG_NUMBER result = 1;
	for (BIG_NUMBER i = 1; i <= *this; i++)
		result *= i;
	return result;
}
void BIG_NUMBER::clean(void){
	if (len == 0) len++;
	while (len > 1 && s[len - 1] == '\0')
		len--;
}
BIG_NUMBER BIG_NUMBER::sqrt(void)const{
	if(*this<0)return -1;
	if(*this<=1)return *this;
	BIG_NUMBER l=0,r=*this,mid;
	while(r-l>1) {
		mid=(l+r)/2;
		if(mid*mid>*this)
			r=mid;
		else
			l=mid;
	}
	return l;
}
BIG_NUMBER::~BIG_NUMBER(void){
}
int main(void){
	BIG_NUMBER m,n,res;
	cin>>m>>n;
	res=m*n;
	cout<<res;
	return 0;
}
```

---

### T1308 : 高精除

> 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$

#### 【题目描述】

高精除以高精，求它们的商和余数。

#### 【输入】

输入两个低于$300$位的正整数。

#### 【输出】

输出商和余数。

#### 【输入样例】

```
1231312318457577687897987642324567864324567876543245671425346756786867867867
1231312318767141738178325678412414124141425346756786867867867
```

#### 【输出样例】

```
999999999748590
179780909068307566598992807564736854549985603543237528310337
```

#### 【答案&代码】

```cpp
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<iostream>
#include<string>
using std::string;
using std::cin;
using std::cout;
using std::istream;
using std::ostream;
using std::endl;
using std::max;
#define MAX_LENGTH 2005
struct BIG_NUMBER{
	int len,s[MAX_LENGTH];
	bool sign;
	
	BIG_NUMBER(void);
	BIG_NUMBER(const char*);
	BIG_NUMBER(int);
	~BIG_NUMBER(void);
	void clean(void);
	string toStr(void)const;
	friend istream& operator>>(istream&,BIG_NUMBER&);
	friend ostream& operator<<(ostream&,BIG_NUMBER&);
	BIG_NUMBER operator=(const char*);
	BIG_NUMBER operator=(int);
	BIG_NUMBER operator=(const string);
	bool operator>(const BIG_NUMBER&)const;
	bool operator>=(const BIG_NUMBER&)const;
	bool operator<(const BIG_NUMBER&)const;
	bool operator<=(const BIG_NUMBER&)const;
	bool operator==(const BIG_NUMBER&)const;
	bool operator!=(const BIG_NUMBER&)const;
	BIG_NUMBER operator+(const BIG_NUMBER&)const;
	BIG_NUMBER operator++(void);
	BIG_NUMBER operator++(int);
	BIG_NUMBER operator+=(const BIG_NUMBER&);
	BIG_NUMBER operator-(const BIG_NUMBER &) const;
	BIG_NUMBER operator--(void);
	BIG_NUMBER operator--(int);
	BIG_NUMBER operator-=(const BIG_NUMBER&);
	BIG_NUMBER operator*(const BIG_NUMBER &)const;
	BIG_NUMBER operator*(const int num)const;
	BIG_NUMBER operator*=(const BIG_NUMBER&);
	BIG_NUMBER operator/(const BIG_NUMBER&)const;
	BIG_NUMBER operator/=(const BIG_NUMBER&);
	BIG_NUMBER operator%(const BIG_NUMBER&)const;
	BIG_NUMBER factorial(void)const;
	BIG_NUMBER sqrt(void)const;
	BIG_NUMBER pow(const BIG_NUMBER&)const;
};
BIG_NUMBER::BIG_NUMBER(void){
	memset(s, 0, sizeof(s));
	len = 1;
	sign = 1;
}
BIG_NUMBER::BIG_NUMBER(const char*num){
	*this = num;
}
BIG_NUMBER::BIG_NUMBER(int num){
	*this = num;
}
string BIG_NUMBER::toStr(void)const{
	string res;
	res = "";
	for (int i = 0; i < len; i++)
		res = (char)(s[i] + '0') + res;
	if (res == "")
		res = "0";
	if (!sign&&res != "0")
		res = "-" + res;
	return res;
}
istream &operator>>(istream &in,BIG_NUMBER&num){
	string str;
	in>>str;
	num=str;
	return in;
}
ostream &operator<<(ostream &out,BIG_NUMBER&num){
	out<<num.toStr();
	return out;
}
BIG_NUMBER BIG_NUMBER::operator=(const char*num){
	memset(s, 0, sizeof(s));
	char a[MAX_LENGTH] = "";
	if (num[0] != '-')
		strcpy(a, num);
	else
		for (int i = 1; i < strlen(num); i++)
			a[i - 1] = num[i];
	sign = !(num[0] == '-');
	len = strlen(a);
	for (int i = 0; i < strlen(a); i++)
		s[i] = a[len - i - 1] - 48;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator=(int num){
	char temp[MAX_LENGTH];
	sprintf(temp, "%d", num);
	*this = temp;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator=(const string num){
	const char *tmp;
	tmp = num.c_str();
	*this = tmp;
	return *this;
}
bool BIG_NUMBER::operator<(const BIG_NUMBER&num)const{
	if (sign^num.sign)
		return num.sign;
	if (len != num.len)
		return len < num.len;
	for (int i = len - 1; i >= 0; i--)
		if (s[i] != num.s[i])
			return sign ? (s[i] < num.s[i]) : (!(s[i] < num.s[i]));
	return !sign;
}
bool BIG_NUMBER::operator>(const BIG_NUMBER&num)const{
	return num < *this;
}
bool BIG_NUMBER::operator<=(const BIG_NUMBER&num)const{
	return !(*this>num);
}
bool BIG_NUMBER::operator>=(const BIG_NUMBER&num)const{
	return !(*this<num);
}
bool BIG_NUMBER::operator!=(const BIG_NUMBER&num)const{
	return *this > num || *this < num;
}
bool BIG_NUMBER::operator==(const BIG_NUMBER&num)const{
	return !(num != *this);
}
BIG_NUMBER BIG_NUMBER::operator+(const BIG_NUMBER &num)const{
	if (sign^num.sign) {
		BIG_NUMBER tmp = sign ? num : *this;
		tmp.sign = 1;
		return sign ? *this - tmp : num - tmp;
	}
	BIG_NUMBER result;
	result.len = 0;
	int temp = 0;
	for (int i = 0; temp || i < (max(len, num.len)); i++) {
		int t = s[i] + num.s[i] + temp;
		result.s[result.len++] = t % 10;
		temp = t / 10;
	}
	result.sign = sign;
	return result;
}
BIG_NUMBER BIG_NUMBER::operator++(void){
	*this = *this + 1;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator++(int){
	BIG_NUMBER old = *this;
	++(*this);
	return old;
}
BIG_NUMBER BIG_NUMBER::operator+=(const BIG_NUMBER &num){
	*this = *this + num;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator-(const BIG_NUMBER &num) const{
	BIG_NUMBER b=num,a=*this;
	if (!num.sign && !sign) {
		b.sign=1;
		a.sign=1;
		return b-a;
	}
	if (!b.sign) {
		b.sign=1;
		return a+b;
	}
	if (!a.sign) {
		a.sign=1;
		b=BIG_NUMBER(0)-(a+b);
		return b;
	}
	if (a<b) {
		BIG_NUMBER c=(b-a);
		c.sign=false;
		return c;
	}
	BIG_NUMBER result;
	result.len = 0;
	for (int i = 0, g = 0; i < a.len; i++) {
		int x = a.s[i] - g;
		if (i < b.len) x -= b.s[i];
		if (x >= 0) g = 0;
		else {
			g = 1;
			x += 10;
		}
		result.s[result.len++] = x;
	}
	result.clean();
	return result;
}
BIG_NUMBER BIG_NUMBER::operator*(const BIG_NUMBER &num)const{
	BIG_NUMBER result;
	result.len = len + num.len;

	for (int i = 0; i < len; i++)
		for (int j = 0; j < num.len; j++)
			result.s[i + j] += s[i] * num.s[j];

	for (int i = 0; i < result.len; i++) {
		result.s[i + 1] += result.s[i] / 10;
		result.s[i] %= 10;
	}
	result.clean();
	result.sign = !(sign^num.sign);
	return result;
}
BIG_NUMBER BIG_NUMBER::operator*(const int num)const{
	BIG_NUMBER x = num;
	BIG_NUMBER z = *this;
	return x*z;
}
BIG_NUMBER BIG_NUMBER::operator*=(const BIG_NUMBER&num){
	*this = *this * num;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator/(const BIG_NUMBER&num)const{
	BIG_NUMBER ans;
	ans.len = len - num.len + 1;
	if (ans.len < 0) {
		ans.len = 1;
		return ans;
	}

	BIG_NUMBER divisor = *this, divid = num;
	divisor.sign = divid.sign = 1;
	int k = ans.len - 1;
	int j = len - 1;
	while (k >= 0) {
		while (divisor.s[j] == 0) j--;
		if (k > j) k = j;
		char z[MAX_LENGTH];
		memset(z, 0, sizeof(z));
		for (int i = j; i >= k; i--)
			z[j - i] = divisor.s[i] + '0';
		BIG_NUMBER dividend = z;
		if (dividend < divid) {
			k--;
			continue;
		}
		int key = 0;
		while (divid*key <= dividend) key++;
		key--;
		ans.s[k] = key;
		BIG_NUMBER temp = divid*key;
		for (int i = 0; i < k; i++)
			temp = temp * 10;
		divisor = divisor - temp;
		k--;
	}
	ans.clean();
	ans.sign = !(sign^num.sign);
	return ans;
}
BIG_NUMBER BIG_NUMBER::operator/=(const BIG_NUMBER&num){
	*this = *this / num;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator%(const BIG_NUMBER& num)const{
	BIG_NUMBER a = *this, b = num;
	a.sign = b.sign = 1;
	BIG_NUMBER result, temp = a / b*b;
	result = a - temp;
	result.sign = sign;
	return result;
}
BIG_NUMBER BIG_NUMBER::pow(const BIG_NUMBER& num)const{
	BIG_NUMBER result = 1;
	for (BIG_NUMBER i = 0; i < num; i++)
		result = result*(*this);
	return result;
}
BIG_NUMBER BIG_NUMBER::factorial(void)const{
	BIG_NUMBER result = 1;
	for (BIG_NUMBER i = 1; i <= *this; i++)
		result *= i;
	return result;
}
void BIG_NUMBER::clean(void){
	if (len == 0) len++;
	while (len > 1 && s[len - 1] == '\0')
		len--;
}
BIG_NUMBER BIG_NUMBER::sqrt(void)const{
	if(*this<0)return -1;
	if(*this<=1)return *this;
	BIG_NUMBER l=0,r=*this,mid;
	while(r-l>1) {
		mid=(l+r)/2;
		if(mid*mid>*this)
			r=mid;
		else
			l=mid;
	}
	return l;
}
BIG_NUMBER::~BIG_NUMBER(void){
}
int main(void){
	BIG_NUMBER m,n,r1,r2;
	cin>>m>>n;
	r1=m/n,r2=m%n;
	cout<<r1<<'\n'<<r2;
	return 0;
}
```

---

### T1309 : 回文数

> 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$

#### 【题目描述】

若一个数（首位不为零）从左向右读与从右向左读都是一样，我们就将其称之为回文数。例如：给定一个$10$进制数$56$，将$56$加$65$（即把$56$从右向左读），得到$121$是一个回文数。
写一个程序，给定一个$N(2 < N \leq 10\text{or}N=16)$进制数$M$。求最少经过几步可以得到回文数。如果在$30$步以内（包含$30$步）不可能得到回文数，则输出`Impossible`。

#### 【输入】

给定一个$N(2 < N \leq 10\text{or}N=16)$进制数$M$。

#### 【输出】

最少几步。如果在$30$步以内（包含$30$步）不可能得到回文数，则输出`Impossible`。

#### 【输入样例】

```
9 87
```

#### 【输出样例】

```
6
```

#### 【答案&代码】

```cpp
#include<stdio.h>
#include<string.h>
int n,m[512],size=0;
bool check(void){
	for(int i=0,j=size-1;i<j;i++,j--)
		if(m[i]!=m[j])
			return false;
	return true;
}
void add(void){
	int temp[512]={0};
	for(int i=0,j=size-1;i<size;i++,j--)
		temp[i]=m[i]+m[j];
	for(int i=0;i<size;i++)
		m[i]=temp[i];
	for(int i=0;i<511;i++)
		if(m[i]>=n)
			m[i+1]+=m[i]/n,m[i]%=n;
	size=0;
	for(int i=511;i>=0;i--)
		if(m[i]!=0){
			size=i+1;
			break;
		}
	if(size==0)
		size=1;
	return;
}
int main(void){
	scanf("%d\n",&n);
	char temp[512];
	scanf("%s",temp);
	size=strlen(temp);
	for(int j=strlen(temp)-1,index=0;j>=0;j--,index++)
		if('0'<=temp[j]&&temp[j]<='9')
			m[index]=temp[j]-'0';
		else if('a'<=temp[j]&&temp[j]<='f')
			m[index]=temp[j]-'a'+10;
		else
			m[index]=temp[j]-'A'+10;
	for(int i=0;i<=30;i++){
		if(check())
			return printf("%d",i),0;
		add();
	}
	printf("Impossible");
	return 0;
}
```

---

### T1168 : 大整数加法

> 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$

#### 【题目描述】

求两个不超过$200$位的非负整数的和。

#### 【输入】

有两行，每行是一个不超过$200$位的非负整数，可能有多余的前导$0$。

#### 【输出】

一行，即相加后的结果。结果里不能有多余的前导$0$，即如果结果是$342$，那么就不能输出为$0342$。

#### 【输入样例】

```
22222222222222222222
33333333333333333333
```

#### 【输出样例】

```
55555555555555555555
```

#### 【答案&代码】

```cpp
#include<stdio.h>
#include<string.h>
#define jz 10
unsigned int a[201]={0},b[201]={0};

int main(void) {
	char str[201];
	scanf("%s",str);
	for(int i=0,j=strlen(str)-1;j>=0;i++,j--)
		a[i]=str[j]-'0';
	scanf("%s",str);
	for(int i=0,j=strlen(str)-1;j>=0;i++,j--)
		b[i]=str[j]-'0';
	for(int i=0;i<201;i++)
		a[i]+=b[i],a[i+1]+=a[i]/jz,a[i]%=jz;
	a[201]+=b[201],a[201]%=jz;
	int size=0;
	for(int i=201;i>=0;i--)
		if(a[i]!=0){
			size=i;
			break;
		}
	for(int i=size;i>=0;i--)
		printf("%d",a[i]);
	return 0;
}
```

---

### T1169 : 大整数减法

> 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$

#### 【题目描述】

求两个大的正整数相减的差。

#### 【输入】

共$2$行，第$1$行是被减数$a$，第$2$行是减数$b(a > b)$。每个大整数不超过$200$位，不会有多余的前导零。

#### 【输出】

一行，即所求的差。

#### 【输入样例】

```
9999999999999999999999999999999999999
9999999999999
```

#### 【输出样例】

```
9999999999999999999999990000000000000
```

#### 【答案&代码】

```cpp
#include<iostream>  
#include<string>  
#include<cstring>  
#include<cstdio>  
using namespace std;  
const int maxn=1000;
struct bign{  
    int d[maxn],len;
    void clean(void){ while(len > 1 && !d[len-1]) len--;}
    bign(void){ memset(d, 0, sizeof(d)); len = 1; }  
    bign(int num)   { *this = num; }   
    bign(char* num) { *this = num; }  
    bign operator = (const char* num){  
        memset(d, 0, sizeof(d)); len = strlen(num);  
        for(int i = 0; i < len; i++) d[i] = num[len-1-i] - '0';  
        clean();  
        return *this;  
    }  
    bign operator = (int num){  
        char s[20]; sprintf(s, "%d", num);  
        *this = s;  
        return *this;  
    }  
  
    bign operator + (const bign& b){  
        bign c = *this; int i;  
        for (i = 0; i < b.len; i++){  
            c.d[i] += b.d[i];  
            if (c.d[i] > 9) c.d[i]%=10, c.d[i+1]++;  
        }  
        while (c.d[i] > 9) c.d[i++]%=10, c.d[i]++;  
        c.len = max(len, b.len);  
        if (c.d[i] && c.len <= i) c.len = i+1;  
        return c;  
    }  
    bign operator - (const bign& b){  
        bign c = *this; int i;  
        for (i = 0; i < b.len; i++){  
            c.d[i] -= b.d[i];  
            if (c.d[i] < 0) c.d[i]+=10, c.d[i+1]--;  
        }  
        while (c.d[i] < 0) c.d[i++]+=10, c.d[i]--;  
        c.clean();  
        return c;  
    }  
    bign operator * (const bign& b)const{  
        int i, j; bign c; c.len = len + b.len;   
        for(j = 0; j < b.len; j++) for(i = 0; i < len; i++)   
            c.d[i+j] += d[i] * b.d[j];  
        for(i = 0; i < c.len-1; i++)  
            c.d[i+1] += c.d[i]/10, c.d[i] %= 10;  
        c.clean();  
        return c;  
    }  
    bign operator / (const bign& b){  
        int i, j;  
        bign c = *this, a = 0;  
        for (i = len - 1; i >= 0; i--)  
        {  
            a = a*10 + d[i];  
            for (j = 0; j < 10; j++) if (a < b*(j+1)) break;  
            c.d[i] = j;  
            a = a - b*j;  
        }  
        c.clean();  
        return c;  
    }  
    bign operator % (const bign& b){  
        int i, j;  
        bign a = 0;  
        for (i = len - 1; i >= 0; i--)  
        {  
            a = a*10 + d[i];  
            for (j = 0; j < 10; j++) if (a < b*(j+1)) break;  
            a = a - b*j;  
        }  
        return a;  
    }  
    bign operator += (const bign& b){  
        *this = *this + b;  
        return *this;  
    }  
  
    bool operator <(const bign& b){  
        if(len != b.len) return len < b.len;  
        for(int i = len-1; i >= 0; i--)  
            if(d[i] != b.d[i]) return d[i] < b.d[i];  
        return false;  
    }  
    void Print(){  
        char s[maxn]={0};  
        for(int i = 0; i < len; i++) s[len-1-i] = d[i]+'0';  
        printf("%s",s);
        return;  
    }  
};
int main(void){
	char num[201];
	scanf("%s",num);
	bign a=num;
	scanf("%s",num);
	bign b=num;
	(a-b).Print();
	return 0;
} 
```

---

### T1170 : 计算2的N次方

> 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$

#### 【题目描述】

任意给定一个正整数$N(N \leq 100)$，计算$2$的$n$次方的值。

#### 【输入】

输入一个正整数$N$。

#### 【输出】

输出$2$的$N$次方的值。

#### 【输入样例】

```
5
```

#### 【输出样例】

```
32
```

#### 【答案&代码】

```cpp
#include<stdio.h>
unsigned short num[100];
int main(void){
	int n;
	scanf("%d",&n);
	num[0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<100;j++)
			num[j]*=2;
		for(int j=0;j<99;j++)
			num[j+1]+=num[j]/10,num[j]%=10;
		num[99]%=10;
	}
	int size=0;
	for(int i=99;i>=0;i--)
		if(num[i]!=0){
			size=i;
			break;
		}
	for(int i=size;i>=0;i--)
		printf("%d",num[i]);
	return 0;
}
```

---

### T1171 : 大整数的因子

> 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$

#### 【题目描述】

已知正整数$k$满足$2 \leq k \leq 9$，现给出长度最大为$30$位的十进制非负整数$c$，求所有能整除$c$的$k$。

#### 【输入】

一个非负整数$c$，$c$的位数不超过$30$。

#### 【输出】

若存在满足$c \% k = 0$的$k$，从小到大输出所有这样的$k$，相邻两个数之间用单个空格隔开；若没有这样的$k$，则输出`none`。

#### 【输入样例】

```
30
```

#### 【输出样例】

```
2 3 5 6 
```

#### 【答案&代码】

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a[50],b[50];
char str[50];
int divide(int x){
    int i=a[0],res=0;
    while(i>0)
        res*=10,
        res+=a[i],
        res%=x,
        i--;
    return res;
}
int main(void){
    int len;
    bool flag=false;
    int i;
    cin>>str;
    len=strlen(str);
    int k=1;
    for(i=len-1;i>=0;i--)
        a[k]=str[i]-'0',
        k++;
    a[0]=len;
    for(i=2;i<=9;i++)
        if(divide(i)==false)
            flag=true,
            cout<<i<<" ";
    if(flag==false)
        cout<<"none"<<endl;
    return 0;
}
```

---

### T1172 : 求10000以内n的阶乘

> 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$

#### 【题目描述】

求$10000$以内$n$的阶乘。

#### 【输入】

只有一行输入，整数$n(0 \leq n \leq 10000)$。

#### 【输出】

一行，即$n!$的值。

#### 【输入样例】

```
4
```

#### 【输出样例】

```
24
```

#### 【答案&代码】

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iomanip>
 
using namespace std;
 
int c[10005]={0};
 
void factoriala(int a[],int b){
	for(int i=1;i<=a[0];i++){
		a[i]=a[i]*b;
	}
	for(int i=1;i<=a[0];i++){
		a[i+1]=a[i+1]+a[i]/10000;
		a[i]=a[i]%10000;
	}
	while(a[a[0]+1]>0){
		a[0]++;
		a[a[0]+1]=a[a[0]]/10000;
		a[a[0]]=a[a[0]]%10000;
	}
}
 
void printa(int a[]){
	for(int i=1;i<=a[0];i++){
		if(i==1) cout<<a[a[0]+1-i];
		else cout <<setw(4)<<setfill('0')<<a[a[0]+1-i];
	}
}
 
int main(){
	int n;
	cin>>n;
	c[0]=1;
	c[1]=1;
	if(n==0) ;
	else for(int i=1;i<=n;i++){
		factoriala(c,i);
	}
	printa(c);
	return 0;
}
```

---

### T1173 : 阶乘和

> 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$

#### 【题目描述】

用高精度计算出$S=1!+2!+3!+…+n!(n \leq 50)$,其中$!$表示阶乘，例如：$5!=5 \times 4 \times 3 \times 2 \times 1$。

输入正整数$n$，输出计算结果$S$。

#### 【输入】

一个正整数$n$。

#### 【输出】

计算结果$S$。

#### 【输入样例】

```
5
```

#### 【输出样例】

```
153
```

#### 【答案&代码】

```cpp
#include<iostream>  
#include<string>  
#include<cstring>  
#include<cstdio>  
using namespace std;  
const int maxn=1000;
struct bign{  
    int d[maxn],len;
    void clean(void){ while(len > 1 && !d[len-1]) len--;}
    bign(void){ memset(d, 0, sizeof(d)); len = 1; }  
    bign(int num)   { *this = num; }   
    bign(char* num) { *this = num; }  
    bign operator = (const char* num){  
        memset(d, 0, sizeof(d)); len = strlen(num);  
        for(int i = 0; i < len; i++) d[i] = num[len-1-i] - '0';  
        clean();  
        return *this;  
    }  
    bign operator = (int num){  
        char s[20]; sprintf(s, "%d", num);  
        *this = s;  
        return *this;  
    }  
  
    bign operator + (const bign& b){  
        bign c = *this; int i;  
        for (i = 0; i < b.len; i++){  
            c.d[i] += b.d[i];  
            if (c.d[i] > 9) c.d[i]%=10, c.d[i+1]++;  
        }  
        while (c.d[i] > 9) c.d[i++]%=10, c.d[i]++;  
        c.len = max(len, b.len);  
        if (c.d[i] && c.len <= i) c.len = i+1;  
        return c;  
    }  
    bign operator - (const bign& b){  
        bign c = *this; int i;  
        for (i = 0; i < b.len; i++){  
            c.d[i] -= b.d[i];  
            if (c.d[i] < 0) c.d[i]+=10, c.d[i+1]--;  
        }  
        while (c.d[i] < 0) c.d[i++]+=10, c.d[i]--;  
        c.clean();  
        return c;  
    }  
    bign operator * (const bign& b)const{  
        int i, j; bign c; c.len = len + b.len;   
        for(j = 0; j < b.len; j++) for(i = 0; i < len; i++)   
            c.d[i+j] += d[i] * b.d[j];  
        for(i = 0; i < c.len-1; i++)  
            c.d[i+1] += c.d[i]/10, c.d[i] %= 10;  
        c.clean();  
        return c;  
    }  
    bign operator / (const bign& b){  
        int i, j;  
        bign c = *this, a = 0;  
        for (i = len - 1; i >= 0; i--)  
        {  
            a = a*10 + d[i];  
            for (j = 0; j < 10; j++) if (a < b*(j+1)) break;  
            c.d[i] = j;  
            a = a - b*j;  
        }  
        c.clean();  
        return c;  
    }  
    bign operator % (const bign& b){  
        int i, j;  
        bign a = 0;  
        for (i = len - 1; i >= 0; i--)  
        {  
            a = a*10 + d[i];  
            for (j = 0; j < 10; j++) if (a < b*(j+1)) break;  
            a = a - b*j;  
        }  
        return a;  
    }  
    bign operator += (const bign& b){  
        *this = *this + b;  
        return *this;  
    }  
  	bign operator *= (const bign& b){  
        *this = *this * b;  
        return *this;  
    }  
    bool operator <(const bign& b){  
        if(len != b.len) return len < b.len;  
        for(int i = len-1; i >= 0; i--)  
            if(d[i] != b.d[i]) return d[i] < b.d[i];  
        return false;  
    }  
    /*bool operator >(const bign& b){return b < *this;}  
    bool operator<=(const bign& b){return !(b < *this);}  
    bool operator>=(const bign& b){return !(*this < b);}  
    bool operator!=(const bign& b){return b < *this || *this < b;}  
    bool operator==(const bign& b){return !(b < *this) && !(b > *this);}  
  	*/
    void Print(){  
        char s[maxn]={0};  
        for(int i = 0; i < len; i++) s[len-1-i] = d[i]+'0';  
        printf("%s",s);
        return;  
    }  
};
int main(void){
	int n;
	scanf("%d",&n);
	bign sum=0,temp=1;
	for(int i=1;i<=n;i++)
		temp*=i,sum+=temp;
	sum.Print();
	return 0;
}
```

---

### T1174 : 大整数乘法

> 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$

#### 【题目描述】

求两个不超过$200$位的非负整数的积。

#### 【输入】

有两行，每行是一个不超过$200$位的非负整数，没有多余的前导$0$。

#### 【输出】

一行，即相乘后的结果。结果里不能有多余的前导$0$，即如果结果是$342$，那么就不能输出为$0342$。

#### 【输入样例】

```
12345678900
98765432100
```

#### 【输出样例】

```
1219326311126352690000
```

#### 【答案&代码】

```cpp
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<iostream>
#include<string>
using std::string;
using std::cin;
using std::cout;
using std::istream;
using std::ostream;
using std::endl;
using std::max;
#define MAX_LENGTH 2005
struct BIG_NUMBER{
	int len,s[MAX_LENGTH];
	bool sign;
	
	BIG_NUMBER(void);
	BIG_NUMBER(const char*);
	BIG_NUMBER(int);
	~BIG_NUMBER(void);
	void clean(void);
	string toStr(void)const;
	friend istream& operator>>(istream&,BIG_NUMBER&);
	friend ostream& operator<<(ostream&,BIG_NUMBER&);
	BIG_NUMBER operator=(const char*);
	BIG_NUMBER operator=(int);
	BIG_NUMBER operator=(const string);
	bool operator>(const BIG_NUMBER&)const;
	bool operator>=(const BIG_NUMBER&)const;
	bool operator<(const BIG_NUMBER&)const;
	bool operator<=(const BIG_NUMBER&)const;
	bool operator==(const BIG_NUMBER&)const;
	bool operator!=(const BIG_NUMBER&)const;
	BIG_NUMBER operator+(const BIG_NUMBER&)const;
	BIG_NUMBER operator++(void);
	BIG_NUMBER operator++(int);
	BIG_NUMBER operator+=(const BIG_NUMBER&);
	BIG_NUMBER operator-(const BIG_NUMBER &) const;
	BIG_NUMBER operator--(void);
	BIG_NUMBER operator--(int);
	BIG_NUMBER operator-=(const BIG_NUMBER&);
	BIG_NUMBER operator*(const BIG_NUMBER &)const;
	BIG_NUMBER operator*(const int num)const;
	BIG_NUMBER operator*=(const BIG_NUMBER&);
	BIG_NUMBER operator/(const BIG_NUMBER&)const;
	BIG_NUMBER operator/=(const BIG_NUMBER&);
	BIG_NUMBER operator%(const BIG_NUMBER&)const;
	BIG_NUMBER factorial(void)const;
	BIG_NUMBER sqrt(void)const;
	BIG_NUMBER pow(const BIG_NUMBER&)const;
};
BIG_NUMBER::BIG_NUMBER(void){
	memset(s, 0, sizeof(s));
	len = 1;
	sign = 1;
}
BIG_NUMBER::BIG_NUMBER(const char*num){
	*this = num;
}
BIG_NUMBER::BIG_NUMBER(int num){
	*this = num;
}
string BIG_NUMBER::toStr(void)const{
	string res;
	res = "";
	for (int i = 0; i < len; i++)
		res = (char)(s[i] + '0') + res;
	if (res == "")
		res = "0";
	if (!sign&&res != "0")
		res = "-" + res;
	return res;
}
istream &operator>>(istream &in,BIG_NUMBER&num){
	string str;
	in>>str;
	num=str;
	return in;
}
ostream &operator<<(ostream &out,BIG_NUMBER&num){
	out<<num.toStr();
	return out;
}
BIG_NUMBER BIG_NUMBER::operator=(const char*num){
	memset(s, 0, sizeof(s));
	char a[MAX_LENGTH] = "";
	if (num[0] != '-')
		strcpy(a, num);
	else
		for (int i = 1; i < strlen(num); i++)
			a[i - 1] = num[i];
	sign = !(num[0] == '-');
	len = strlen(a);
	for (int i = 0; i < strlen(a); i++)
		s[i] = a[len - i - 1] - 48;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator=(int num){
	char temp[MAX_LENGTH];
	sprintf(temp, "%d", num);
	*this = temp;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator=(const string num){
	const char *tmp;
	tmp = num.c_str();
	*this = tmp;
	return *this;
}
bool BIG_NUMBER::operator<(const BIG_NUMBER&num)const{
	if (sign^num.sign)
		return num.sign;
	if (len != num.len)
		return len < num.len;
	for (int i = len - 1; i >= 0; i--)
		if (s[i] != num.s[i])
			return sign ? (s[i] < num.s[i]) : (!(s[i] < num.s[i]));
	return !sign;
}
bool BIG_NUMBER::operator>(const BIG_NUMBER&num)const{
	return num < *this;
}
bool BIG_NUMBER::operator<=(const BIG_NUMBER&num)const{
	return !(*this>num);
}
bool BIG_NUMBER::operator>=(const BIG_NUMBER&num)const{
	return !(*this<num);
}
bool BIG_NUMBER::operator!=(const BIG_NUMBER&num)const{
	return *this > num || *this < num;
}
bool BIG_NUMBER::operator==(const BIG_NUMBER&num)const{
	return !(num != *this);
}
BIG_NUMBER BIG_NUMBER::operator+(const BIG_NUMBER &num)const{
	if (sign^num.sign) {
		BIG_NUMBER tmp = sign ? num : *this;
		tmp.sign = 1;
		return sign ? *this - tmp : num - tmp;
	}
	BIG_NUMBER result;
	result.len = 0;
	int temp = 0;
	for (int i = 0; temp || i < (max(len, num.len)); i++) {
		int t = s[i] + num.s[i] + temp;
		result.s[result.len++] = t % 10;
		temp = t / 10;
	}
	result.sign = sign;
	return result;
}
BIG_NUMBER BIG_NUMBER::operator++(void){
	*this = *this + 1;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator++(int){
	BIG_NUMBER old = *this;
	++(*this);
	return old;
}
BIG_NUMBER BIG_NUMBER::operator+=(const BIG_NUMBER &num){
	*this = *this + num;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator-(const BIG_NUMBER &num) const{
	BIG_NUMBER b=num,a=*this;
	if (!num.sign && !sign) {
		b.sign=1;
		a.sign=1;
		return b-a;
	}
	if (!b.sign) {
		b.sign=1;
		return a+b;
	}
	if (!a.sign) {
		a.sign=1;
		b=BIG_NUMBER(0)-(a+b);
		return b;
	}
	if (a<b) {
		BIG_NUMBER c=(b-a);
		c.sign=false;
		return c;
	}
	BIG_NUMBER result;
	result.len = 0;
	for (int i = 0, g = 0; i < a.len; i++) {
		int x = a.s[i] - g;
		if (i < b.len) x -= b.s[i];
		if (x >= 0) g = 0;
		else {
			g = 1;
			x += 10;
		}
		result.s[result.len++] = x;
	}
	result.clean();
	return result;
}
BIG_NUMBER BIG_NUMBER::operator*(const BIG_NUMBER &num)const{
	BIG_NUMBER result;
	result.len = len + num.len;

	for (int i = 0; i < len; i++)
		for (int j = 0; j < num.len; j++)
			result.s[i + j] += s[i] * num.s[j];

	for (int i = 0; i < result.len; i++) {
		result.s[i + 1] += result.s[i] / 10;
		result.s[i] %= 10;
	}
	result.clean();
	result.sign = !(sign^num.sign);
	return result;
}
BIG_NUMBER BIG_NUMBER::operator*(const int num)const{
	BIG_NUMBER x = num;
	BIG_NUMBER z = *this;
	return x*z;
}
BIG_NUMBER BIG_NUMBER::operator*=(const BIG_NUMBER&num){
	*this = *this * num;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator/(const BIG_NUMBER&num)const{
	BIG_NUMBER ans;
	ans.len = len - num.len + 1;
	if (ans.len < 0) {
		ans.len = 1;
		return ans;
	}

	BIG_NUMBER divisor = *this, divid = num;
	divisor.sign = divid.sign = 1;
	int k = ans.len - 1;
	int j = len - 1;
	while (k >= 0) {
		while (divisor.s[j] == 0) j--;
		if (k > j) k = j;
		char z[MAX_LENGTH];
		memset(z, 0, sizeof(z));
		for (int i = j; i >= k; i--)
			z[j - i] = divisor.s[i] + '0';
		BIG_NUMBER dividend = z;
		if (dividend < divid) {
			k--;
			continue;
		}
		int key = 0;
		while (divid*key <= dividend) key++;
		key--;
		ans.s[k] = key;
		BIG_NUMBER temp = divid*key;
		for (int i = 0; i < k; i++)
			temp = temp * 10;
		divisor = divisor - temp;
		k--;
	}
	ans.clean();
	ans.sign = !(sign^num.sign);
	return ans;
}
BIG_NUMBER BIG_NUMBER::operator/=(const BIG_NUMBER&num){
	*this = *this / num;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator%(const BIG_NUMBER& num)const{
	BIG_NUMBER a = *this, b = num;
	a.sign = b.sign = 1;
	BIG_NUMBER result, temp = a / b*b;
	result = a - temp;
	result.sign = sign;
	return result;
}
BIG_NUMBER BIG_NUMBER::pow(const BIG_NUMBER& num)const{
	BIG_NUMBER result = 1;
	for (BIG_NUMBER i = 0; i < num; i++)
		result = result*(*this);
	return result;
}
BIG_NUMBER BIG_NUMBER::factorial(void)const{
	BIG_NUMBER result = 1;
	for (BIG_NUMBER i = 1; i <= *this; i++)
		result *= i;
	return result;
}
void BIG_NUMBER::clean(void){
	if (len == 0) len++;
	while (len > 1 && s[len - 1] == '\0')
		len--;
}
BIG_NUMBER BIG_NUMBER::sqrt(void)const{
	if(*this<0)return -1;
	if(*this<=1)return *this;
	BIG_NUMBER l=0,r=*this,mid;
	while(r-l>1) {
		mid=(l+r)/2;
		if(mid*mid>*this)
			r=mid;
		else
			l=mid;
	}
	return l;
}
BIG_NUMBER::~BIG_NUMBER(void){
}
int main(void){
	BIG_NUMBER m,n,res;
	cin>>m>>n;
	res=m*n;
	cout<<res;
	return 0;
}
```

---

### T1175 : 除以13

> 时间限制: $1000 \text{ms}$ 内存限制: $65536 \text{KB}$

#### 【题目描述】

输入一个大于$0$的大整数$N$，长度不超过$100$位，要求输出其除以$13$得到的商和余数。

#### 【输入】

一个大于$0$的大整数，长度不超过$100$位。

#### 【输出】

两行，分别为整数除法得到的商和余数。

#### 【输入样例】

```
2132104848488485
```

#### 【输出样例】

```
164008065268345
0
```

#### 【答案&代码】

```cpp
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<iostream>
#include<string>
using std::string;
using std::cin;
using std::cout;
using std::istream;
using std::ostream;
using std::endl;
using std::max;
#define MAX_LENGTH 2005
struct BIG_NUMBER{
	int len,s[MAX_LENGTH];
	bool sign;
	
	BIG_NUMBER(void);
	BIG_NUMBER(const char*);
	BIG_NUMBER(int);
	~BIG_NUMBER(void);
	void clean(void);
	string toStr(void)const;
	friend istream& operator>>(istream&,BIG_NUMBER&);
	friend ostream& operator<<(ostream&,BIG_NUMBER&);
	BIG_NUMBER operator=(const char*);
	BIG_NUMBER operator=(int);
	BIG_NUMBER operator=(const string);
	bool operator>(const BIG_NUMBER&)const;
	bool operator>=(const BIG_NUMBER&)const;
	bool operator<(const BIG_NUMBER&)const;
	bool operator<=(const BIG_NUMBER&)const;
	bool operator==(const BIG_NUMBER&)const;
	bool operator!=(const BIG_NUMBER&)const;
	BIG_NUMBER operator+(const BIG_NUMBER&)const;
	BIG_NUMBER operator++(void);
	BIG_NUMBER operator++(int);
	BIG_NUMBER operator+=(const BIG_NUMBER&);
	BIG_NUMBER operator-(const BIG_NUMBER &) const;
	BIG_NUMBER operator--(void);
	BIG_NUMBER operator--(int);
	BIG_NUMBER operator-=(const BIG_NUMBER&);
	BIG_NUMBER operator*(const BIG_NUMBER &)const;
	BIG_NUMBER operator*(const int num)const;
	BIG_NUMBER operator*=(const BIG_NUMBER&);
	BIG_NUMBER operator/(const BIG_NUMBER&)const;
	BIG_NUMBER operator/=(const BIG_NUMBER&);
	BIG_NUMBER operator%(const BIG_NUMBER&)const;
	BIG_NUMBER factorial(void)const;
	BIG_NUMBER sqrt(void)const;
	BIG_NUMBER pow(const BIG_NUMBER&)const;
};
BIG_NUMBER::BIG_NUMBER(void){
	memset(s, 0, sizeof(s));
	len = 1;
	sign = 1;
}
BIG_NUMBER::BIG_NUMBER(const char*num){
	*this = num;
}
BIG_NUMBER::BIG_NUMBER(int num){
	*this = num;
}
string BIG_NUMBER::toStr(void)const{
	string res;
	res = "";
	for (int i = 0; i < len; i++)
		res = (char)(s[i] + '0') + res;
	if (res == "")
		res = "0";
	if (!sign&&res != "0")
		res = "-" + res;
	return res;
}
istream &operator>>(istream &in,BIG_NUMBER&num){
	string str;
	in>>str;
	num=str;
	return in;
}
ostream &operator<<(ostream &out,BIG_NUMBER&num){
	out<<num.toStr();
	return out;
}
BIG_NUMBER BIG_NUMBER::operator=(const char*num){
	memset(s, 0, sizeof(s));
	char a[MAX_LENGTH] = "";
	if (num[0] != '-')
		strcpy(a, num);
	else
		for (int i = 1; i < strlen(num); i++)
			a[i - 1] = num[i];
	sign = !(num[0] == '-');
	len = strlen(a);
	for (int i = 0; i < strlen(a); i++)
		s[i] = a[len - i - 1] - 48;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator=(int num){
	char temp[MAX_LENGTH];
	sprintf(temp, "%d", num);
	*this = temp;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator=(const string num){
	const char *tmp;
	tmp = num.c_str();
	*this = tmp;
	return *this;
}
bool BIG_NUMBER::operator<(const BIG_NUMBER&num)const{
	if (sign^num.sign)
		return num.sign;
	if (len != num.len)
		return len < num.len;
	for (int i = len - 1; i >= 0; i--)
		if (s[i] != num.s[i])
			return sign ? (s[i] < num.s[i]) : (!(s[i] < num.s[i]));
	return !sign;
}
bool BIG_NUMBER::operator>(const BIG_NUMBER&num)const{
	return num < *this;
}
bool BIG_NUMBER::operator<=(const BIG_NUMBER&num)const{
	return !(*this>num);
}
bool BIG_NUMBER::operator>=(const BIG_NUMBER&num)const{
	return !(*this<num);
}
bool BIG_NUMBER::operator!=(const BIG_NUMBER&num)const{
	return *this > num || *this < num;
}
bool BIG_NUMBER::operator==(const BIG_NUMBER&num)const{
	return !(num != *this);
}
BIG_NUMBER BIG_NUMBER::operator+(const BIG_NUMBER &num)const{
	if (sign^num.sign) {
		BIG_NUMBER tmp = sign ? num : *this;
		tmp.sign = 1;
		return sign ? *this - tmp : num - tmp;
	}
	BIG_NUMBER result;
	result.len = 0;
	int temp = 0;
	for (int i = 0; temp || i < (max(len, num.len)); i++) {
		int t = s[i] + num.s[i] + temp;
		result.s[result.len++] = t % 10;
		temp = t / 10;
	}
	result.sign = sign;
	return result;
}
BIG_NUMBER BIG_NUMBER::operator++(void){
	*this = *this + 1;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator++(int){
	BIG_NUMBER old = *this;
	++(*this);
	return old;
}
BIG_NUMBER BIG_NUMBER::operator+=(const BIG_NUMBER &num){
	*this = *this + num;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator-(const BIG_NUMBER &num) const{
	BIG_NUMBER b=num,a=*this;
	if (!num.sign && !sign) {
		b.sign=1;
		a.sign=1;
		return b-a;
	}
	if (!b.sign) {
		b.sign=1;
		return a+b;
	}
	if (!a.sign) {
		a.sign=1;
		b=BIG_NUMBER(0)-(a+b);
		return b;
	}
	if (a<b) {
		BIG_NUMBER c=(b-a);
		c.sign=false;
		return c;
	}
	BIG_NUMBER result;
	result.len = 0;
	for (int i = 0, g = 0; i < a.len; i++) {
		int x = a.s[i] - g;
		if (i < b.len) x -= b.s[i];
		if (x >= 0) g = 0;
		else {
			g = 1;
			x += 10;
		}
		result.s[result.len++] = x;
	}
	result.clean();
	return result;
}
BIG_NUMBER BIG_NUMBER::operator*(const BIG_NUMBER &num)const{
	BIG_NUMBER result;
	result.len = len + num.len;

	for (int i = 0; i < len; i++)
		for (int j = 0; j < num.len; j++)
			result.s[i + j] += s[i] * num.s[j];

	for (int i = 0; i < result.len; i++) {
		result.s[i + 1] += result.s[i] / 10;
		result.s[i] %= 10;
	}
	result.clean();
	result.sign = !(sign^num.sign);
	return result;
}
BIG_NUMBER BIG_NUMBER::operator*(const int num)const{
	BIG_NUMBER x = num;
	BIG_NUMBER z = *this;
	return x*z;
}
BIG_NUMBER BIG_NUMBER::operator*=(const BIG_NUMBER&num){
	*this = *this * num;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator/(const BIG_NUMBER&num)const{
	BIG_NUMBER ans;
	ans.len = len - num.len + 1;
	if (ans.len < 0) {
		ans.len = 1;
		return ans;
	}

	BIG_NUMBER divisor = *this, divid = num;
	divisor.sign = divid.sign = 1;
	int k = ans.len - 1;
	int j = len - 1;
	while (k >= 0) {
		while (divisor.s[j] == 0) j--;
		if (k > j) k = j;
		char z[MAX_LENGTH];
		memset(z, 0, sizeof(z));
		for (int i = j; i >= k; i--)
			z[j - i] = divisor.s[i] + '0';
		BIG_NUMBER dividend = z;
		if (dividend < divid) {
			k--;
			continue;
		}
		int key = 0;
		while (divid*key <= dividend) key++;
		key--;
		ans.s[k] = key;
		BIG_NUMBER temp = divid*key;
		for (int i = 0; i < k; i++)
			temp = temp * 10;
		divisor = divisor - temp;
		k--;
	}
	ans.clean();
	ans.sign = !(sign^num.sign);
	return ans;
}
BIG_NUMBER BIG_NUMBER::operator/=(const BIG_NUMBER&num){
	*this = *this / num;
	return *this;
}
BIG_NUMBER BIG_NUMBER::operator%(const BIG_NUMBER& num)const{
	BIG_NUMBER a = *this, b = num;
	a.sign = b.sign = 1;
	BIG_NUMBER result, temp = a / b*b;
	result = a - temp;
	result.sign = sign;
	return result;
}
BIG_NUMBER BIG_NUMBER::pow(const BIG_NUMBER& num)const{
	BIG_NUMBER result = 1;
	for (BIG_NUMBER i = 0; i < num; i++)
		result = result*(*this);
	return result;
}
BIG_NUMBER BIG_NUMBER::factorial(void)const{
	BIG_NUMBER result = 1;
	for (BIG_NUMBER i = 1; i <= *this; i++)
		result *= i;
	return result;
}
void BIG_NUMBER::clean(void){
	if (len == 0) len++;
	while (len > 1 && s[len - 1] == '\0')
		len--;
}
BIG_NUMBER BIG_NUMBER::sqrt(void)const{
	if(*this<0)return -1;
	if(*this<=1)return *this;
	BIG_NUMBER l=0,r=*this,mid;
	while(r-l>1) {
		mid=(l+r)/2;
		if(mid*mid>*this)
			r=mid;
		else
			l=mid;
	}
	return l;
}
BIG_NUMBER::~BIG_NUMBER(void){
}
int main(void){
	BIG_NUMBER m,r1,r2;
	cin>>m;
	r1=m/13,r2=m%13;
	cout<<r1<<'\n'<<r2;
	return 0;
}
```
